PR#3
PREFIX /A2OSX.BUILD
NEW
INC 1
AUTO 6
				.LIST OFF	
*--------------------------------------
CSH.Reset		ldy #CSH.hStack
				lda (pData),y
				bne .1
				
				>LDYAI 256
				>SYSCALL GetMemYA
				bcs .9
				txa
				ldy #CSH.hStack
				sta (pData),y
				
.1				lda #0
				ldy #CSH.StackPtr
				sta (pData),y
*				clc
.9				rts
*--------------------------------------
CSH.Exec		jsr CSH.GetBuffer

				ldy #CSH.hStack
				lda (pData),y
				>SYSCALL GetMemPtrA
				>STYA ZPCSHStack
				
				ldy #0
				
				jsr CSH.GetCharNB
				bcs .9
				
				cmp #'}'				End of block ?
				bne .10

				jsr CSH.CheckStack		must be on stack....
				bcs .9
				
				jsr CSH.Pop				was expected, get stacked Cmd...
				tax
				jmp (J.CSHCMDS.END,x) 
				
.10				jsr CSH.SavePtr			Save Ptr, in case of while,for....
				
				cmp #$0D
				beq .6					empty line...skip...
				
.1				iny
				sta (pData),y				
				
				cpy #CmdLine.MAX
				beq .8					Buffer full, try execute...
				
				jsr CSH.GetNextChar
				bcs .8					EOF, try execute...
				
				cmp #$0D				EOL, skip CR and exec...
				beq .6

				jsr CSH.CheckCharNB
				bcc .1					still in keyword....loop
				
				tya
				sta (pData)
				
				jsr CSH.CheckKeyword
				bcs .5					not an internal SCRipt keyword....
				
				lda #0
				sta (pData)				Reset Cmdline
				
				stx CSH.CmdSave
				jmp (J.CSHCMDS,x)			
				
.5				lda (ZPBufPtr)			restore char....				
				bra .1
				
.6				jsr CSH.GetNextChar		Skip last char...
				
.8				tya
				beq .80					empty line....nothing to do..
				sta (pData)
				
				ldy #bEcho
				lda (pData),y
				beq .80

				>PUSHW pData
				>LDYA L.MSG.ECHO
				>SYSCALL PPrintFYA
.80				clc
.9				rts
*--------------------------------------
CSH.CheckKeyword
				phy
				>LDYA L.CSHCMDS
				>STYA ZPPtr2
				
				ldx #0
				
.1				lda (ZPPtr2)
				beq .9					Ending 0, not found....
				
				cmp (pData)				Same Len ?
				bne .4
				
				tay
				
.2				lda (pData),y

				cmp #'a'				To Uppercase
				bcc .3
				cmp #'z'+1
				bcs .3
				eor #$20

.3				cmp (ZPPtr2),y
				bne .4
				dey
				bne .2
				
				ply
				clc					Found an internal Cmd...
				rts

.4				inx
				inx
				
				lda ZPPtr2
				sec
				adc (ZPPtr2)
				sta ZPPtr2
				bcc .1
				inc ZPPtr2+1
				bra .1
				
.9				ply
				sec
				rts
*--------------------------------------
CSH.GetBuffer	ldy #CSH.hBuf
				lda (pData),y
				>SYSCALL GetMemPtrA
				>STYA ZPBufBase
				
				ldy #CSH.BufLen
				lda (pData),y
				clc
				adc ZPBufBase
				sta ZPBufEnd
				
				iny
				lda (pData),y
				adc ZPBufBase+1
				sta ZPBufEnd+1
				
CSH.SetBufPtr	ldy #CSH.BufPtr
				lda (pData),y
				clc
				adc ZPBufBase
				sta ZPBufPtr
				
				iny
				lda (pData),y
				adc ZPBufBase+1
				sta ZPBufPtr+1
				rts
*--------------------------------------
CSH.SavePtr		ldx ZPBufPtr
				stx CSH.BufPtrSave
				ldx ZPBufPtr+1
				stx CSH.BufPtrSave+1
				rts
*--------------------------------------
CSH.WHILE
CSH.IF			jsr CSH.GetCharNB
				bcs .9
				cmp #'('
				bne .9
				
				jsr CSH.GetNextCharNB
				bcs .9
				
				jsr CSH.ExpEval
				bcs .99
				
				jsr CSH.GetCharNB
				bcs .99
				cmp #')'
				bne .9
				
				jsr CSH.GetNextCharNB
				bcs .99
				cmp #'{'
				bne .9
				
				lda CSH.ACC
				ora CSH.ACC+1
				ora CSH.ACC+2
				ora CSH.ACC+3
				beq .6					eval returned false, skip {{....}}
				
				jsr CSH.GetNextCharNB	Skip '{'

				lda CSH.CmdSave			Push "IF" or "WHILE"
				beq .1					if "IF", no need to push Saved Ptr
				
				pha
				lda CSH.BufPtrSave+1	WHILE : push loop address...
				jsr CSH.Push
				lda CSH.BufPtrSave
				jsr CSH.Push		
				pla
				
.1				jsr CSH.Push
				bcs .99
				
				lda #'}'				Tell '}' is expected at the end of block
				jsr CSH.Push
				bcs .99
	
				rts
				
.6				ldx #1					expecting 1 '}' for now....

.7				jsr CSH.GetNextChar
				bcs .9
				cmp #'{'
				bne .71
				inx
				bra .7
				
.71				cmp #'}'
				bne .7
				txa
				beq .9
				dex
				bne .7
				
				jsr CSH.GetNextChar
				
				clc
				rts
				
.9				lda #CSHERR.SYNTAX
				sec
.99				rts
*--------------------------------------
CSH.IF.END		jsr CSH.GetNextChar		just skip ending '}'
				clc
				rts
*--------------------------------------
CSH.WHILE.END	jsr CSH.Pop
				ldy #CSH.BufPtr
				sta (pData),y
				jsr CSH.Pop
				ldy #CSH.BufPtr+1
				sta (pData),y
				clc
				rts
*--------------------------------------
CSH.BREAK
*--------------------------------------
CSH.CONTINUE

				lda #CSHERR.SYNTAX
				sec
				rts
*--------------------------------------
CSH.Push		pha
				ldy #CSH.StackPtr
				lda (pData),y
				tay
				
				pla
				sta (ZPCSHStack),y
				iny
				beq .9
				tya
				ldy #CSH.StackPtr
				sta (pData),y
				clc
				rts
	
.9				lda #CSHERR.SOVERFLW
				sec
				rts
*--------------------------------------
CSH.Pop			ldy #CSH.StackPtr
				lda (pData),y
				beq .9
				dec
				tay
				sta (pData),y
				lda (ZPCSHStack),y
				clc
				rts

.9				lda #CSHERR.SYNTAX
				sec
				rts				
*--------------------------------------
CSH.CheckStack	pha
				ldy #CSH.StackPtr
				lda (pData),y
				beq .9
				dec
				tay
				pla
				cmp (ZPCSHStack),y
				bne .9
				
				tya
				ldy #CSH.StackPtr
				sta (pData),y
				
				clc
				rts
				
.9				lda #CSHERR.SYNTAX
				sec
				rts						
*--------------------------------------
CSH.ExpEval		stz CSH.ACC
				stz CSH.ACC+1
				stz CSH.ACC+2
				stz CSH.ACC+3
				
				jsr CSH.GetCharNB
				bcs .9
				cmp #')'
				beq .8
				
				jsr CSH.IsLetter		Fnc or Var ?
				bne .1
				
				
.1								
				
.8				clc
				rts
				
.9				lda #CSHERR.SYNTAX
				sec
				rts	
*---------------------------------------
CSH.IsLetterOrDigit
				jsr CSH.IsDigit
				bcc CSH.IsLetterRTS
*--------------------------------------
CSH.GetCharNB	jsr CSH.GetChar
				bcs CSH.GetNextCharNB.RTS
				jsr CSH.CheckCharNB
				bcc CSH.GetNextCharNB.RTS		
*--------------------------------------
CSH.GetNextCharNB
				jsr CSH.GetNextChar
				bcs CSH.GetNextCharNB.RTS
				jsr CSH.CheckCharNB
				bcs CSH.GetNextCharNB
CSH.GetNextCharNB.RTS
				rts
*--------------------------------------
CSH.CheckCharNB	cmp #32					SPACE
				beq .9
				cmp #13					CR
				beq .9
				cmp #10					LF
				beq .9
				cmp #8					TAB
				beq .9
				clc
.9				rts				
*--------------------------------------
CSH.GetNextChar	phy
				ldy #CSH.BufPtr
				lda (pData),y
				inc
				sta (pData),y
				bne .1
				
				iny
				lda (pData),y
				inc
				sta (pData),y
				
.1				ply

				inc ZPBufPtr
				bne CSH.GetChar
				inc ZPBufPtr+1
*--------------------------------------
CSH.GetChar		lda ZPBufPtr
				eor ZPBufEnd
				bne .1
				
				lda ZPBufPtr+1
				eor ZPBufEnd+1
				bne .1
				
				lda #MLI.ERR.EOF
				sec
				rts
				
.1				lda (ZPBufPtr)
				clc
				rts
*---------------------------------------
CSH.IsLetter	cmp #'A'
				bcc .9
				
				cmp #'Z'+1
				bcc CSH.IsLetterRTS

				cmp #'a'
				bcc .9
				cmp #'z'+1
				rts						CC if lowercase

.9				sec
				
CSH.IsLetterRTS	rts					
*---------------------------------------
CSH.IsDigit		cmp #'0'
				bcc .9
				cmp #'9'+1
				rts						cc if ok, cs if not
					
.9				sec
				rts
*--------------------------------------
MAN
SAVE /A2OSX.SRC/SBIN/SHELL.S.CSH
LOAD /A2OSX.SRC/SBIN/SHELL.S
ASM
