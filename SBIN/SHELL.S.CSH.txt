PR#3
PREFIX /A2OSX.BUILD
NEW
INC 1
AUTO 6
				.LIST OFF	
*--------------------------------------
CSH.TYPE.CHAR	.EQ 1
CSH.TYPE.INT	.EQ 2
CSH.TYPE.LONG	.EQ 3
CSH.TYPE.FLOAT	.EQ 4
*--------------------------------------
CSH.Init		lda #$FF
				>STA.G bExitOnEOF

				inc
				>STA.G CSH.SymbolsPtr
				>STA.G CSH.DataPtr
				>STA.G CSH.StackPtr
				
				lda #1
				>SYSCALL GetArg.A
				>SYSCALL LoadTxtFile.YA
				bcs .9
				
				txa
				>STA.G CSH.hBuf
				>SYSCALL GetMemPtr.A
				>STYA ZPCSHBufPtr
				
				>LDYAI 256
				>SYSCALL GetMem0.YA
				bcs .9
				txa
				>STA.G CSH.hSymbols
				>SYSCALL GetMemPtr.A
				>STYA ZPCSHSymbols
				
				>LDYAI 256
				>SYSCALL GetMem.YA
				bcs .9
				txa
				>STA.G CSH.hData
				>SYSCALL GetMemPtr.A
				>STYA ZPCSHData
				
				>LDYAI 256
				>SYSCALL GetMem.YA
				bcs .9
				txa
				>STA.G CSH.hStack
				>SYSCALL GetMemPtr.A
				>STYA ZPCSHStack
				
*				clc
.9				rts
*--------------------------------------
CSH.Run			lda #0
				>STA.G CmdBuflen		Reset Cmdline
				
				jsr CSH.GetCharNB
				bcs .9
				
				cmp #'}'				End of block ?
				bne .1

				jsr CSH.CheckStack		must be on stack....
				bcs .9
				
				jsr CSH.Pop				was expected, get stacked Cmd...
				tax
				jmp (J.CSHCMDS.END,x) 
				
.1				cmp #$0D
				bne .2
				
				jmp CSH.GetNextCharNB	Skip CR
				
.2				pha
				jsr CSH.SavePtr			Save Ptr, in case of while,for....
				pla
				jsr CSH.IsLetter
				bcc .3
				
				cmp #'#'
				beq .5					comments : pass line to shell
				
				bra .9					error, todo : PREOPS ++ --.....
				
.3				>LDYA L.CSHCMDS
				jsr CSH.IsKeyword
				bcs .4					not an internal CSH keyword....
				
				txa	
				>STA.G CSH.CmdSave
				
				jmp (J.CSHCMDS,x)		

.4				jsr CSH.GetVar			Y=Ptr To Value
				bcs .5
				
				
				jsr CSH.GetCharNB
				bcs .9
				cmp #'='
				bne .99
				
				jsr CSH.GetNextCharNB	Skip =
				bcs .99
				
				phy
				jsr CSH.ExpEval
				ply
				bcs .9
				
				jsr CSH.SetVarValueAtY
				bcs .9
				cmp #';'
				bne .99
				
				jmp CSH.GetNextCharNB	Skip ;
				
.99				lda #CSH.E.SYNTAX
				sec
.9				rts

.5				


				jsr CSH.RestorePtr		Restore ptr to get full cmd line to execute
				
				jsr CSH.GetCharNB
				
				ldy #0
				
.6				cmp #13
				beq .7
				sta (ZPCMDBuf),y
				iny
				cpy #CmdLine.MAX
				beq .8
				
				jsr CSH.GetNextChar
				bcc .6
				bra .8
				
.7				jsr CSH.GetNextCharNB	Skip CR
				
.8				lda #0
				sta (ZPCMDBuf),y
				tya
				>STA.G CmdBuflen
				lda #$ff
				>STA.G bCmdBufexec
				
				>LDA.G bEcho
				beq .80

				>PUSHW ZPCMDBuf
				>LDYA L.MSG.ECHO
				>SYSCALL PrintF.YA
				
.80				clc
				rts
*--------------------------------------
CSH.Quit		>LDA.G CSH.hBuf
				beq .1
				>SYSCALL FreeMem.A

.1				>LDA.G CSH.hStack
				beq .2
				>SYSCALL FreeMem.A
				
.2				>LDA.G CSH.hData
				beq .3
				>SYSCALL FreeMem.A
				
.3				>LDA.G CSH.hSymbols
				beq .8
				>SYSCALL FreeMem.A
				
.8				rts
*--------------------------------------
CSH.SavePtr		phy
				>LDYA ZPCSHBufPtr
				>STYA.G CSH.BufPtrSave
				ply
				rts
*--------------------------------------
CSH.RestorePtr	phy
				>LDYA.G CSH.BufPtrSave
				>STYA ZPCSHBufPtr
				ply
				rts
*--------------------------------------
CSH.IsKeyword	>STYA ZPPtr1
				
				jsr CSH.GetIdentLen
				
				phy						Y = kw len
				
				ldx #0
				
.1				lda (ZPPtr1)
				beq .9					Ending 0, not found....
				
				pla
				pha						Get Back Len
				
				cmp (ZPPtr1)			Same Len ?
				bne .4
				
				tay
				
.2				lda (ZPPtr1),y

.3				dey
				cmp (ZPCSHBufPtr),y
				bne .4
				tya

				bne .2
				
				pla						Found keyword...
				clc
				adc ZPCSHBufPtr			..advance Ptr to char after it..
				sta ZPCSHBufPtr
				bcc .8
				inc ZPCSHBufPtr+1	
				clc						
.8				rts

.4				inx
				inx
				
				lda ZPPtr1
				sec
				adc (ZPPtr1)
				sta ZPPtr1
				bcc .1
				inc ZPPtr1+1
				bra .1
				
.9				pla
				sec
				rts
*--------------------------------------
CSH.WHILE
CSH.IF			jsr CSH.GetCharNB
				bcs .9
				cmp #'('
				bne .9
				
				jsr CSH.GetNextCharNB
				bcs .9
				
				jsr CSH.ExpEval
				bcs .99
				
				jsr CSH.GetCharNB
				bcs .99
				cmp #')'
				bne .9
				
				jsr CSH.GetNextCharNB
				bcs .99
				cmp #'{'
				bne .9
				
				>LDA.G CSH.ACC
				iny
				ora (pData),y
				iny
				ora (pData),y
				iny
				ora (pData),y
				beq .6					eval returned false, skip {{....}}
				
				jsr CSH.GetNextCharNB	Skip '{'

				>LDA.G CSH.CmdSave		Push "IF" or "WHILE"
				beq .1					if "IF", no need to push Saved Ptr
				
				pha
				>LDA.G CSH.BufPtrSave+1	WHILE : push loop address...
				jsr CSH.Push
				>LDA.G CSH.BufPtrSave
				jsr CSH.Push		
				pla
				
.1				jsr CSH.Push
				bcs .99
				
				lda #'}'				Tell '}' is expected at the end of block
				jsr CSH.Push
				bcs .99
	
				rts
				
.6				ldx #1					expecting 1 '}' for now....

.7				jsr CSH.GetNextChar
				bcs .9
				cmp #'{'
				bne .71
				inx
				bra .7
				
.71				cmp #'}'
				bne .7
				txa
				beq .9
				dex
				bne .7
				
				jsr CSH.GetNextChar
				
				clc
				rts
				
.9				lda #CSH.E.SYNTAX
				sec
.99				rts
*--------------------------------------
CSH.IF.END		jsr CSH.GetNextChar		just skip ending '}'
				clc
				rts
*--------------------------------------
CSH.WHILE.END	jsr CSH.Pop
				sta ZPCSHBufPtr
				jsr CSH.Pop
				sta ZPCSHBufPtr+1
				clc
				rts
*--------------------------------------
CSH.BREAK
*--------------------------------------
CSH.CONTINUE

				lda #CSH.E.SYNTAX
				sec
				rts
*--------------------------------------
CSH.CHAR		lda #CSH.TYPE.CHAR
				bra CSH.TYPE
CSH.INT			lda #CSH.TYPE.INT
				bra CSH.TYPE
CSH.LONG		lda #CSH.TYPE.LONG
				bra CSH.TYPE
CSH.FLOAT		lda #CSH.TYPE.FLOAT

CSH.TYPE		>STA.G CSH.ACCT
				
				jsr CSH.GetChar
				bcs .9
				cmp #' '
				bne .9
				
				jsr CSH.GetNextCharNB
				bcs .9

				jsr CSH.IsLetter
				bcs .9

				jsr CSH.GetVar			Already exists ?
				bcc .90
				
				jsr CSH.AddVar			No, add with undefined value...
				bcs .99
*										Y=Ptr in DATA to Value
				
				jsr CSH.GetCharNB
				bcs .9
				cmp #';'
				beq .8					end of declaration, no value...
				
				cmp #'='
				bne .9
				
				jsr CSH.GetNextCharNB
				bcs .9
				
				phy						Save Ptr To Value
				jsr CSH.ExpEval
				ply

				bcs .9
				
				jsr CSH.SetVarValueAtY	Update value to this var
				
				jsr CSH.GetChar
				bcs .9
				cmp #';'
				bne .9
				
.8				jsr CSH.GetNextCharNB	Skip ;
				clc
				rts

.90				lda #CSH.E.DUP
				sec
				rts
							
.9				lda #CSH.E.SYNTAX
				sec
.99				rts
*--------------------------------------
CSH.ExpEval		jsr CSH.ZeroACC
				
				jsr CSH.GetCharNB
				bcs .9
				cmp #')'
				beq .8
				cmp #';'
				beq .8
				
				jsr CSH.IsLetter		Fnc or Var ?
				bcs .1

				bra .9
				
.1				jsr CSH.IsDigit10		number ?
				bcs .9
				
				jsr CSH.GetNumInACC

				bcs .9
		
				
.8				clc
				rts
				
.9				lda #CSH.E.SYNTAX
				sec
.99				rts	
*--------------------------------------
CSH.GetNumInACC	>LDA.G CSH.ACCT
				cmp #CSH.TYPE.FLOAT
				bcc .1
				>PUSHWI ZPCSHBufPtr
				>PUSHW ZPCSHBufPtr
				>PUSHEA.G CSH.ACC
				
				>SYSCALL StrToF
				rts
				
.1				>PUSHBI 10

				>PUSHWI ZPCSHBufPtr
				>PUSHW ZPCSHBufPtr
				>PUSHEA.G CSH.ACC
				>DEBUG
				>SYSCALL StrToL
				rts	
*--------------------------------------
CSH.ZeroACC		lda #0
				ldx #5
				ldy #CSH.ACC
				
.1				sta (pData),y
				iny
				dex
				bne .1
				
				rts
*--------------------------------------
* Vars...
*--------------------------------------
CSH.AddVar		jsr CSH.GetIdentLen
				sec
				>ADC.G CSH.SymbolsPtr
				
				bcs .99
				
				adc #1					OFS
				bcs .99
				
				>LDA.G CSH.DataPtr
				pha
				
				>LDA.G CSH.ACCT
				tax
				sec						+1 for Type
				adc CSH.TSIZE,x
				bcs .98					Out of memory

				>LDA.G CSH.SymbolsPtr
				tay
				
				jsr CSH.GetChar
				
.1				sta (ZPCSHSymbols),y
				iny
				jsr CSH.GetNextChar
				
				jsr CSH.IsLetterOrDigit
				bcc .1
				
				pla						Get Back Data OFS				
				pha
				sta (ZPCSHSymbols),y
				iny
				
				tya
				>STA.G CSH.SymbolsPtr
				
				>LEA.G CSH.ACCT
				>STYA ZPPtr1			ACCT/ACC in ZPPtr1
				
				ply						Get Back Data OFS again
				phy
				
				lda (ZPPtr1)
				sta (ZPCSHSymbols),y	Add Type to Data
				iny

				tax
				lda CSH.TSIZE,x			A = byte count to store
				
				tax
				
.2				inc ZPPtr1
				bne .3
				inc ZPPtr1+1
				
.3				lda (ZPPtr1)
				sta (ZPCSHData),y
				iny
				dex
				bne .2
				
				tya
				>STA.G CSH.DataPtr
				
				ply						Exit with Y=Data Offset
				clc
				rts
							
.98				pla
.99				lda #CSH.E.OOM
				sec
				rts
*--------------------------------------
CSH.SetVarValueAtY

				clc
				rts
*--------------------------------------
CSH.GetVar		>LDYA ZPCSHSymbols
				>STYA ZPPtr1
				
				jsr CSH.GetIdentLen
				phy
				
.1				lda (ZPPtr1)
				beq .9
				
				pla
				pha
				cmp (ZPPtr1)
				bne .3
				
				tay
				
.2				lda (ZPPtr1),y
				dey
				cmp (ZPCSHBufPtr),y
				bne .3
				
				tya
				bne .2
				
				pla
				
				jsr CSH.VarSkipName
				
				clc
.8				rts
							
.3				jsr CSH.VarSkipName
				
.5				inc ZPPtr1				Skip Pointer to TYPE/DATA
				bne .1
				inc ZPPtr1+1
				bra .1
				
.9				pla
				sec
				rts
*--------------------------------------
CSH.VarSkipName	lda (ZPPtr1)
				sec
				adc ZPPtr1
				sta ZPPtr1
				bcc .8
				inc ZPPtr1+1
.8				rts				
*--------------------------------------
* Stack
*--------------------------------------
CSH.Push		pha
				>LDA.G CSH.StackPtr
				tay
				
				pla
				sta (ZPCSHStack),y
				iny
				beq .9
				tya
				>STA.G CSH.StackPtr
				sta (pData),y
				clc
				rts
	
.9				lda #CSH.E.SOVERFLW
				sec
				rts
*--------------------------------------
CSH.Pop			>LDA.G CSH.StackPtr
				beq .9
				dec
				tay
				sta (pData),y
				lda (ZPCSHStack),y
				clc
				rts

.9				lda #CSH.E.SYNTAX
				sec
				rts				
*--------------------------------------
CSH.CheckStack	pha
				>LDA.G CSH.StackPtr
				beq .9
				dec
				tay
				pla
				cmp (ZPCSHStack),y
				bne .9
				
				tya
				>STA.G CSH.StackPtr
				
				clc
				rts
				
.9				lda #CSH.E.SYNTAX
				sec
				rts						
*--------------------------------------
* CHAR related Subs.....
*--------------------------------------
CSH.GetIdentLen	ldy #0
								
.1				iny
				lda (ZPCSHBufPtr),y
				beq .8

				jsr CSH.IsLetterOrDigit
				bcc .1
.8				rts
*--------------------------------------
CSH.GetCharNB	jsr CSH.GetChar
				bcs CSH.GetNextCharNB.RTS
				jsr CSH.CheckCharNB
				bcc CSH.GetNextCharNB.RTS		
*--------------------------------------
CSH.GetNextCharNB
				jsr CSH.GetNextChar
				bcs CSH.GetNextCharNB.RTS
				jsr CSH.CheckCharNB
				bcs CSH.GetNextCharNB
CSH.GetNextCharNB.RTS
				rts
*--------------------------------------
CSH.CheckCharNB	cmp #32					SPACE
				beq .9
				cmp #13					CR
				beq .9
				cmp #10					LF
				beq .9
				cmp #8					TAB
				beq .9
				clc
.9				rts				
*--------------------------------------
CSH.GetNextChar	inc ZPCSHBufPtr
				bne CSH.GetChar
				inc ZPCSHBufPtr+1
*--------------------------------------
CSH.GetChar		lda (ZPCSHBufPtr)
				beq .9
				clc
				rts
				
.9				lda #MLI.ERR.EOF
				sec
				rts
*---------------------------------------
CSH.IsLetterOrDigit
				jsr CSH.IsDigit10
				bcc CSH.IsLetterRTS
*---------------------------------------
CSH.IsLetter	cmp #'_'
				bne .1
				clc
				rts
				
.1				cmp #'A'
				bcc .9
				
				cmp #'Z'+1
				bcc CSH.IsLetterRTS

				cmp #'a'
				bcc .9
				cmp #'z'+1
				rts						CC if lowercase

.9				sec
				
CSH.IsLetterRTS	rts					
*---------------------------------------
CSH.IsDigit10	cmp #'0'
				bcc .9
				cmp #'9'+1
				rts						cc if ok, cs if not
					
.9				sec
				rts
*--------------------------------------
CSH.ErrorMsg	>LDA.G CSH.hBuf
				>SYSCALL GetMemPtr.A
				>STYA ZPPtr1
				
				lda #0
				>STA.G CSH.LineNum
				iny
				>STA.G CSH.LineNum+1
				
.1				>LDYA ZPPtr1
				>STYA ZPPtr2			Save actual line start
				
				>INCW.G CSH.LineNum

.2				lda (ZPPtr1)
				beq .6					EoF
				inc ZPPtr1
				bne .3
				inc ZPPtr1+1
				
.3				cmp #$0D
				bne .2					Scan until EoL
				
				ldx ZPPtr1
				cpx ZPCSHBufPtr
				lda ZPPtr1+1
				sbc ZPCSHBufPtr+1
				bcc .1					not this line....

.4				ldy #0

.5				lda (ZPPtr2),y
				beq .6
				iny
				cmp #$0D
				beq .6
				phy
				>SYSCALL PutChar.A
				ply
				bra .5
				
.6				lda #$0D
				>SYSCALL PutChar.A
				lda #$0A
				>SYSCALL PutChar.A
				
				lda ZPCSHBufPtr
				sec
				sbc ZPPtr2
				beq .8
				tay
				
.7				phy
				lda #'-'
				>SYSCALL PutChar.A
				ply
				dey
				bne .7
				
.8				>PUSHW.G CSH.LineNum
				
				>LDYA L.MSG.CSHERR
				>SYSCALL PrintF.YA

				rts
*--------------------------------------
MAN
SAVE /A2OSX.SRC/SBIN/SHELL.S.CSH
LOAD /A2OSX.SRC/SBIN/SHELL.S
ASM
