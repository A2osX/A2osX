PR#3
PREFIX /A2OSX.SRC
NEW
INC 1
AUTO 6
				.LIST OFF	
				.OP	65C02
				.OR	$2000
				.TF /A2OSX.BOOT/SBIN/SHELL
*--------------------------------------
				.INB INC/MACROS.I
				.INB INC/PRODOS.I
				.INB INC/A2OSX.I
				.INB INC/A2OSX.API.I
				.INB INC/LIBSTR.I
*--------------------------------------
ZPPTR1			.EQ ZPBIN
ZPPTR2			.EQ ZPBIN+2
ZPPTR3			.EQ ZPBIN+4
*--------------------------------------
CmdBuffer.MAX	.EQ 127
*--------------------------------------
*			File Header (16 Bytes)
*--------------------------------------
CS.START		cld
				jmp (.1,x)
				.DA #$61				6502,Level 1 (65c02)
				.DA #1					BIN Layout Version 1
				.DA 0
				.DA CS.END-CS.START		Code Length To Relocate
				.DA DS.END-DS.START		Data Segment to Allocate
				.DA 0
				.DA 0
*--------------------------------------
* Relocation Table
*--------------------------------------				
.1				.DA CS.INIT
				.DA CS.RUN
				.DA CS.DOEVENT
				.DA	CS.QUIT
*--------------------------------------
L.LIBSTR		.DA LIBSTR
L.MSG.GREETINGS	.DA MSG.GREETINGS
L.MSG.UNKNOWN	.DA MSG.UNKNOWN
L.MSG.SYNERR	.DA MSG.SYNERR
L.CMDS			.DA CMDS
T.INTCMDS		.DA EXEC.CMD.CD
				.DA EXEC.CMD.SET
				.DA EXEC.CMD.DATE
				.DA EXEC.CMD.TIME
				.DA EXEC.CMD.ECHO
				.DA EXEC.CMD.TYPE
				.DA EXEC.CMD.EXIT
				.DA 0
*--------------------------------------
CS.INIT			lda #0
				ldy #bEXIT
				sta (pData),y
				ldy #CmdHistory
				sta (pData),y
				ldy #CmdHistory.IDX
				sta (pData),y
				ldy #CmdHistory.END
				sta (pData),y
				
				>LDYA L.LIBSTR
				>LOADLIBYA
				bcs .99
				sta hLIBSTR
				
				ldy #S.PS.ID
				lda (pPs),y
				>PUSHA
				ldy #S.PS.hOUTDEV
				lda (pPs),y
				>PUSHA
				ldy #S.PS.hINDEV
				lda (pPs),y
				>PUSHA
				>PUSHW L.MSG.GREETINGS
				>LIBCALL hLIBSTR,LIBSTR.PRINTF
				
				lda (pPs)
				ora #S.PS.F.EVENT		Now accept events
				sta (pPs)
				
				clc
.99				rts
*--------------------------------------
CS.RUN			lda #0
				sta (pData)
				
				lda #"$"
				jsr COUT		
				lda #" "
				jsr COUT

.1				lda (pData)
				bmi .2
				jsr A2osX.SLEEP
				
				bra .1

.2				and #$7F
				sta (pData)
				beq CS.RUN				Empty line
				
				>LDYA pData
				>SYSCALL SYS.NewPStrYA
				bcs .99
				
				ldy #hCMDLINE
				sta (pData),y
*				jsr HISTORY.ADD
				jsr EXEC.CMD
				bcc .3

				pha
				lda #"["
				jsr COUT
				pla
				jsr PRBYTE		
				lda #"]"
				jsr COUT
				jsr CROUT

.3				ldy #hCMDLINE
				lda (pData),y
				>SYSCALL SYS.FreeMemA
				ldy #hCMDLINE
				lda #0
				sta (pData),y
				
				ldy	#bEXIT
				lda (pData),y
				bne .99
				
				clc
				rts
				
.99				sec
				rts	
*--------------------------------------
CS.DOEVENT		ldy #S.EVT.hDEV		is Event from active IN device?
				lda (pEvent),y
				ldy #S.PS.hINDEV
				cmp (pPs),y

				bne .9
				lda (pEvent)
				and #S.EVT.F.KEY		is it a KEY event?
				beq .9

				ldy #S.EVT.DATAHI		is it an O or SAPPLE key ?
				lda (pEvent),y
				bne	.9

				ldy #S.EVT.DATALO	
				lda (pEvent),y
				tax
				
				cpx #$20
				bcs .1
				jsr CS.EVENT.CTRL.CHAR
				bra .8

.1				cpx #$7f
				bne .2
				jsr CmdBuffer.DEL
				bra .8

.2				lda (pData)				CmdBuffer
				
				cmp #CmdBuffer.MAX
				beq .8
				
				inc
				sta (pData)
				tay
				txa
				sta (pData),y

				ora #$80
				jsr COUT
				
.8				clc
				rts	
				
.9				sec
				rts
*--------------------------------------
CS.EVENT.CTRL.CHAR
				cmp #13					CR
				bne .10
				jsr CROUT
				lda (pData)				CmdBuffer
				ora #$80
				sta (pData)
				clc
				rts
				
.10				cmp #3
				bne .1
				jsr CmdBuffer.CLR
				clc
				rts
				
.1				cmp #8					BS (left arrow)
				bne .2
				jsr CmdBuffer.DEL
				clc
				rts
				
.2				cmp #10					LF (down arrow)
				bne .3
				
*				jsr HISTORY.GETNEXT
				clc
				rts
				
.3				cmp #11					VT (up arrow)
				bne .4
				
*				jsr HISTORY.GETPREV
				clc
				rts
				
.4				cmp #21					NAK (right arrow)
				bne .8
				
				clc
				rts
				
.8				jsr PRBYTE
				clc
				rts
*--------------------------------------
CS.QUIT			lda hLIBSTR
				>SYSCALL SYS.UnloadLibA
				clc
				rts
*--------------------------------------
*				PRIVATE
*--------------------------------------
EXEC.CMD		ldy #hCMDLINE
				>PUSHB (pData),y
				>PUSHBI $20				Push SEP=' '
				>PUSHBI 0				Push 0 for getting CMD & ARGS
				>SYSCALL SYS.PStrGetTkn
				bcs .99

				ldy #hCMD
				sta (pData),y
				pha
				txa
				ldy #hARGS
				sta (pData),y
				pla
				
				>SYSCALL SYS.GetMemPtrA
				>PUSHYA
				>PUSHYA
				
				>LIBCALL hLIBSTR,LIBSTR.UCASEP
				>PUSHW L.CMDS
				>SYSCALL SYS.GetPStrIndex
				bcs .1					Not An internal command
				jsr EXEC.CMD.INT		
				bcs .98
				jsr .98
				clc
				rts
				
.1				jsr .98					Discard CMD & ARGS			
				ldy #hCMDLINE
				lda (pData),y
				>SYSCALL SYS.ExecProcessA
				rts
				
.98				pha
				ldy #hCMD
				lda (pData),y
				>SYSCALL SYS.FreeMemA
				ldy #hARGS
				lda (pData),y
				>SYSCALL SYS.FreeMemA
				pla
				sec
.99				rts	
*--------------------------------------
EXEC.CMD.INT	asl
				tax
				jmp (T.INTCMDS,x)
*--------------------------------------
EXEC.CMD.CD		ldy #hARGS
				lda (pData),y
				bne EXEC.CMD.CD.C
				ldy #S.PS.hPREFIX
				lda (pPs),y
				>SYSCALL SYS.GetMemPtrA
				>PUSHYA
				>LIBCALL hLIBSTR,LIBSTR.PRINTP
				jsr CROUT
				clc	
				rts
				
EXEC.CMD.CD.C	>SYSCALL SYS.GetMemPtrA
				>STYA ZPPTR2
				ldy #S.PS.hPREFIX
				lda (pPs),y
				>SYSCALL SYS.GetMemPtrA
				>STYA ZPPTR1
				>PUSHWI MLI.MAXPATH+1	Get a buffer for new PATH
				>PUSHBI 0				no particular Option
				>SYSCALL SYS.GetMem
				bcs .99
				>STYA ZPPTR3
				stx hNEWPATH
				
				lda #0
				sta (ZPPTR3)
				ldy #1
				lda (ZPPTR2),y
				cmp #'/'				Full Path?
				beq .3
				cmp #'.'				".." ?
				bne .2
				lda (ZPPTR2)
				cmp #2
				bne .97
				iny
				lda (ZPPTR2),y
				cmp #'.'
				bne .97
				lda (ZPPTR1)
				tay
.1				dey
				beq .97
				lda (ZPPTR1),y
				cmp #'/'
				bne .1
				tya
				sta (ZPPTR3)
.11				lda (ZPPTR1),y
				sta (ZPPTR3),y
				dey
				bne .11
				bra .4
.97				lda #SYSMGR.ERRSYN
.98				pha
				lda hNEWPATH
				>SYSCALL SYS.FreeMemA
				pla
				sec
.99				rts

.2				>PUSHW ZPPTR1
				>PUSHW ZPPTR3
				>LIBCALL hLIBSTR,LIBSTR.STRCPYP
.3				>PUSHW ZPPTR2
				>PUSHW ZPPTR3
				>LIBCALL hLIBSTR,LIBSTR.STRCATP
				lda (ZPPTR3)
				tay
				lda #'/'				Ending with '/'?
				cmp (ZPPTR3),y
				beq .4
				iny
				sta (ZPPTR3),y
				tya
				sta (ZPPTR3)
.4				lda hNEWPATH
				>SYSCALL SYS.CheckPrefixA
				bcs .98
				ldy #S.PS.hPREFIX
				lda (pPs),y
				pha
				lda hNEWPATH
				sta (pPs),y
				pla
				>SYSCALL SYS.FreeMemA
				clc
				rts
*--------------------------------------
EXEC.CMD.SET	ldy #hARGS
				lda (pData),y
				bne .2
				
				ldy #S.PS.hENV
				lda (pPs),y
				>SYSCALL SYS.GetMemPtrA
				>STYA ZPPTR1
				
.1				lda (ZPPTR1)
				beq .8					Ending 0 ?
				>PUSHW ZPPTR1
				>LIBCALL hLIBSTR,LIBSTR.PRINTP
				jsr CROUT

				lda ZPPTR1
				sec
				adc (ZPPTR1)			Add len+1 to PTR
				sta ZPPTR1
				bcc .1
				inc ZPPTR1
				bra .1
				
.2				sec
				rts
				
.8				clc
				rts				
*--------------------------------------
EXEC.CMD.DATE	>SYSCALL SYS.MLIGetTime
				bcs .9
				>PUSHW DATELO
				>LIBCALL hLIBSTR,LIBSTR.PRINTDATE
				jsr CROUT
				clc
.9				rts
*--------------------------------------
EXEC.CMD.TIME	>SYSCALL SYS.MLIGetTime
				bcs .9
				>PUSHW TIMELO
				>LIBCALL hLIBSTR,LIBSTR.PRINTTIME
				jsr CROUT
				clc
.9				rts
*--------------------------------------
EXEC.CMD.ECHO	ldy #hARGS
				lda (pData),y
				beq .98
				>SYSCALL SYS.ExpandPStrA
				bcs .99
				
				pha
				>SYSCALL SYS.GetMemPtrA
				>PUSHYA
				>LIBCALL hLIBSTR,LIBSTR.PRINTP
				jsr CROUT
				pla
				>SYSCALL SYS.FreeMemA
				clc
				rts
				
.98				lda #SYSMGR.ERRSYN
				sec
.99				rts
*--------------------------------------
EXEC.CMD.TYPE	ldy #hARGS
				lda (pData),y
				beq .98
				>SYSCALL SYS.LoadFileA
				bcs .99

				>STYA ZPPTR2			store file len
				phx
				txa
				>SYSCALL SYS.GetMemPtrA
				>STYA ZPPTR1
.1				lda ZPPTR2
				bne .2
				lda ZPPTR2+1
				beq .3
				dec ZPPTR2+1
.2				dec ZPPTR2

				lda (ZPPTR1)
				jsr COUT
				inc ZPPTR1
				bne .1
				inc ZPPTR1+1
				bra .1

.3				pla
				>SYSCALL SYS.FreeMemA
				clc
				rts
				
.98				lda #SYSMGR.ERRSYN
				sec
.99				rts
*--------------------------------------
EXEC.CMD.EXIT	ldy #bEXIT
				lda #$FF
				sta (pData),y
				clc
				rts
*--------------------------------------
HISTORY.ADD		lda CmdHistory.END		ending 0
				inc						keep room for new ending 0
				sec						add len+1
				adc CmdBuffer
				bcc .2					enough room
				
				ldx CmdHistory			get len of oldest string
				ldy #0
.1				inx
				iny
				lda CmdHistory,x		move back until 0 found
				sta CmdHistory-1,y
				bne .1
				sty CmdHistory.END		mark new end of history
				bra HISTORY.ADD			retry....
				
.2				ldx CmdHistory.END
				ldy #$FF
.3				iny 
				lda CmdBuffer,y
				sta CmdHistory,x
				inx
				cpy CmdBuffer
				bne .3
				stz CmdHistory,x		set ending 0
				stx CmdHistory.IDX
				stx CmdHistory.END
.9				rts
*--------------------------------------
HISTORY.GETPREV	lda CmdHistory.END
				beq HISTORY.RTS			empty history,nothing to do
				lda CmdHistory.IDX
				beq HISTORY.RTS			already oldest,nothing to do
				lda #0
.1				tax						save current index
				sec
				adc CmdHistory,x
				cmp CmdHistory.IDX
				bne .1					not yet reached current index
				stx CmdHistory.IDX		set new index
				bra HISTORY.SETBUF
HISTORY.RTS		rts
*--------------------------------------
HISTORY.GETNEXT ldx CmdHistory.END
				beq HISTORY.RTS			empty history,nothing to do
				cpx CmdHistory.IDX
				beq HISTORY.RTS
				ldx CmdHistory.IDX
				lda CmdHistory,x
				sec
				adc CmdHistory.IDX
				cmp CmdHistory.END
				sta CmdHistory.IDX
				beq CmdBuffer.CLR		end of history, just blank buffer
*--------------------------------------
HISTORY.SETBUF	jsr CmdBuffer.CLR
				ldx	CmdHistory.IDX
				ldy #$ff
.1				iny
				lda CmdHistory,x
				inx
				sta CmdBuffer,y
				cpy CmdBuffer
				bne .1
				bra CmdBuffer.PRINT
*--------------------------------------
CmdBuffer.PRINT	ldy #0
.1				iny
				lda (pData),y
				ora #$80
				jsr COUT
				tya
				cmp (pData)
				bne .1
				rts
*--------------------------------------
CmdBuffer.CLR	jsr CmdBuffer.DEL
				bne CmdBuffer.CLR
.9				rts
*--------------------------------------
CmdBuffer.DEL	lda (pData)
				beq .9
				lda #8
				jsr COUT
				lda (pData)
				dec
				sta (pData)
.9				rts
*--------------------------------------
PRBYTE			pha
				lsr
				lsr
				lsr
				lsr
				ora #$B0
				cmp #$BA
				bcc .1
				adc #6
.1				jsr COUT
				pla
				and #$0F
				ora #$B0
				cmp #$BA
				bcc COUT
				adc #6
				bra COUT
*--------------------------------------
CROUT			lda #13	
*--------------------------------------
COUT			phx
				phy
				ldx #DEVMGR.COUT
				jsr pDevJmp
				ply
				plx
				rts
pDevJmp			jmp (pDev)
*--------------------------------------
CS.END
*--------------------------------------
CMDS			>PSTRING "CD"
CMDS1			>PSTRING "SET"
CMDS2			>PSTRING "DATE"
CMDS3			>PSTRING "TIME"
CMDS4			>PSTRING "ECHO"
CMDS5			>PSTRING "TYPE"
CMDS6			>PSTRING "EXIT"
				.DA #0
*--------------------------------------
LIBSTR			>PSTRING "libstr.o"
MSG.GREETINGS	>CSTRING "\nA2osX-Shell on Dev=(%h:%h),PS=%h\n\n"
MSG.UNKNOWN		>CSTRING "Command Not Found\n"
MSG.SYNERR		>CSTRING "Syntax Error Or Invalid Pathname\n"
hLIBSTR			.BS 1
hNEWPATH		.BS 1
*--------------------------------------
				.DUMMY
				.OR 0
DS.START
CmdBuffer		.BS CmdBuffer.MAX+1
bEXIT			.BS 1
hCMDLINE		.BS 1
hCMD			.BS 1
hARGS			.BS 1
CmdHistory		.BS 256
CmdHistory.IDX	.BS 1 
CmdHistory.END	.BS 1 
DS.END
				.ED
*--------------------------------------
MAN
SAVE SBIN/SHELL.S
ASM
