PR#3
PREFIX /A2OSX.BUILD
NEW
INC 1
AUTO 6
				.LIST OFF
				.OP	65C02
				.OR	$2000
				.TF /A2OSX.BUILD/SBIN/SHELL
*--------------------------------------
				.INB /A2OSX.BUILD/INC/MACROS.I
				.INB /A2OSX.BUILD/INC/A2OSX.I
				.INB /A2OSX.BUILD/INC/MLI.ERR.I
*--------------------------------------
UsrBuf256		.EQ $200
*--------------------------------------
Stack			.EQ $80
Stack.B			.EQ $fe
Stack.P			.EQ $ff					Initial value=$fd
*--------------------------------------
				.MA STACK.BACKUP
				
				ldy #0
				
				ldx Stack.P				At least eq $fd
				inx
				
:1				lda Stack,x
				sta (pStack),y
				iny
				inx
				bne :1
				
				tsx
				inx
				inx						Skip 2 bytes Return address to Kernel
				
				txa
				eor #$ff				compute byte count on stack....
				inx
				beq :9

				sta :8+1				save count for later
				
				
:2				pla
				sta (pStack),y
				iny
				inx
				bne :2
				
:8				lda #$ff
:9				sta (pStack),y

				tya
				ldy #S.PS.SP
				sta (pPs),y
				
				.EM
*--------------------------------------
				.MA STACK.RESTORE
				ldy #S.PS.SP			get PS stack top....
				lda (pPs),y
				tay
				
				lda (pStack),y			get 6502 stack bytes to restore
				dey
				tax
				beq :2
				
:1				lda (pStack),y
				dey
				pha
				dex
				bne :1
				
				ldx #$ff
				
:2				tya
				beq :8
				
				lda (pStack),y
				sta Stack,x
				dex
				dey
				
:8				
				.EM
*--------------------------------------
				.MA	ADDLOCAL
				lda Stack.P
				sec
				sbc #]1
				sta Stack.P
				sta Stack.B
				.EM
*--------------------------------------
				.MA GETL.A
				ldx Stack.B
				lda Stack+]1,x
				.EM
*--------------------------------------
				.MA GETL.YA
				ldx Stack.B
				ldy Stack+]1,x
				lda Stack+1+]1,x
				.EM
*--------------------------------------
				.MA SETL.A
				ldx Stack.B
				sta Stack+]1,x
				.EM
*--------------------------------------
				.MA SETL.YA
				ldx Stack.B
				sty Stack+]1,x
				sta Stack+1+]1,x
				.EM
*--------------------------------------
				.MA PUSHLW
				ldx Stack.P
				.DO ]#=2
				lda ]1+1,]2
				sta Stack,x
				dex
				lda ]1,]2
				sta Stack,x
				dex
				stx Stack.P
				.ELSE
				lda ]1+1
				sta Stack,x
				dex
				lda ]1
				sta Stack,x
				dex
				stx Stack.P
				.FIN				
				.EM
*--------------------------------------
				.MA	GETG.A
				ldy #]1
				lda (pData),y
				.EM
*--------------------------------------
				.MA	SETG.A
				ldy #]1
				sta (pData),y
				.EM
*--------------------------------------
				.MA	GETG.YA
				ldy #]1
				lda (pData),y
				pha
				iny
				lda (pData),y
				ply
				.EM
*--------------------------------------
				.MA	SETG.YA
				phy
				ldy #]1+1
				sta (pData),y
				dey
				pla
				sta (pData),y
				.EM
*--------------------------------------
ZPPTR1			.EQ ZPBIN
ZPPTR2			.EQ ZPBIN+2
ZPPTR3			.EQ ZPBIN+4
ZPBufBase		.EQ ZPBIN+6
ZPBufPtr		.EQ ZPBIN+8
ZPCSHSymbols	.EQ ZPBIN+10
ZPCSHData		.EQ ZPBIN+12
ZPCSHStack		.EQ ZPBIN+14
*--------------------------------------
CmdLine.MAX		.EQ 127
VarLen.MAX		.EQ 15

CSH.Stack.MAX	.EQ 15
CSH.Name.MAX	.EQ 15
CSH.E.SYNTAX	.EQ $7F		
CSH.E.SOVERFLW	.EQ $7E
CSH.E.NOVERFLW	.EQ $7D
CSH.E.OOM		.EQ $7C
CSH.E.DUP		.EQ $7B
CSH.E.UNDEF		.EQ $7A
CSH.E.TOOLONG	.EQ $79
*--------------------------------------
*			File Header (16 Bytes)
*--------------------------------------
CS.START		cld
				jmp (.1,x)
				.DA #$61				6502,Level 1 (65c02)
				.DA #1					BIN Layout Version 1
				.DA 0
				.DA CS.END-CS.START		Code Length To Relocate
				.DA DS.END-DS.START		Data Segment to Allocate
				.DA 0
				.DA 0
*--------------------------------------
* Relocation Table
*--------------------------------------
.1				.DA CS.INIT
				.DA CS.RUN
				.DA CS.DOEVENT
				.DA	CS.QUIT
*--------------------------------------
L.MSG.GREETINGS	.DA MSG.GREETINGS
L.MSG.PROMPT	.DA MSG.PROMPT
L.MSG.ECHO		.DA MSG.ECHO
L.MSG.PSTRCR	.DA MSG.PSTRCR
L.MSG.PSTR		.DA MSG.PSTR
L.MSG.ERROR		.DA MSG.ERROR
L.MSG.PRINTENV	.DA MSG.PRINTENV
L.MSG.CSHERR	.DA MSG.CSHERR
L.ENV.PATH		.DA ENV.PATH
L.ENV.PWD		.DA ENV.PWD
L.ENV.PS1		.DA ENV.PS1
L.CMD			.DA CMD
L.ARGS			.DA ARGS
L.TIME			.DA TIME
L.STAT			.DA STAT
L.FMT.DATE		.DA FMT.DATE
L.FMT.TIME		.DA FMT.TIME
L.INTCMDS		.DA INTCMDS
J.INTCMDS		.DA Cmd.Exec.CD
				.DA Cmd.Exec.DATE
				.DA Cmd.Exec.ECHO
				.DA Cmd.Exec.EXIT
				.DA Cmd.Exec.PAUSE
				.DA Cmd.Exec.PWD
				.DA Cmd.Exec.READ
				.DA Cmd.Exec.SET
				.DA Cmd.Exec.SLEEP
				.DA Cmd.Exec.STARTPROC
				.DA Cmd.Exec.TIME
L.CSHCMDS		.DA CSHCMDS
J.CSHCMDS		.DA CSH.IF
				.DA CSH.WHILE
				.DA CSH.BREAK
				.DA CSH.CONTINUE
				.DA CSH.CHAR
				.DA CSH.INT
				.DA CSH.LONG
				.DA CSH.FLOAT
J.CSHCMDS.END	.DA CSH.IF.END
				.DA CSH.WHILE.END
L.CSH.ACC		.DA CSH.ACC
L.ERR.Codes		.DA ERR.Codes
L.ERR.Messages	.DA ERR.Messages
				.DA 0
*--------------------------------------
CS.INIT			jsr SetPWD

				lda (pPs)
				ora #S.PS.F.EVENT		Now accept events
				sta (pPs)
								
				ldy #S.PS.ARGC
				lda (pPs),y

				beq .1					no arg, continue starting interactive

				>PUSHWI 0				Aux type
				>PUSHBI 4				S.FILEINFO.TYPE.TXT
				>PUSHBI	SYS.FOpen.R
				
				lda #1
				>SYSCALL GetArg.A
				>PUSHYA
				>SYSCALL LoadFile
				bcs .9
				
				phy
				ldy #CSH.BufLen+1
				sta (pData),y
				dey
				pla
				sta (pData),y
				
				txa
				ldy #CSH.hBuf
				sta (pData),y
				
				ldy #bExitOnEOF
				lda #$FF
				sta (pData),y
				
				jmp CSH.Init
				
.1				jsr HIS.Init
				bcs .9
				
				>LDYA L.MSG.GREETINGS
				>SYSCALL PrintF.YA
				
*				clc
.9				rts				
*--------------------------------------
CS.RUN			>GETG.A bReadMode		READ Command ?
				bne CS.RUN.READ
				
				ldy #S.PS.RC
				lda (pPs),y
				beq .11
				
				jsr IO.PrintErrMsg
				bcs CS.RUN.EXIT.RTS
				
.11				ldy #bPause
				lda (pData),y
				bpl .13

				>SYSCALL GetChar
				bcs .8
				
.13				jsr CheckSleep
				bne .8
				
				>GETG.A CSH.hBuf		batch mode ?
				beq .10
				
				jmp CS.RUN.BATCH
				
.10				lda #0
				sta (pData)
				
				ldy #bSecureRead
				sta (pData),y
				
.12				jsr PrintPrompt
				bcs CS.RUN.EXIT.RTS
				
.1				>SYSCALL Sleep
				>SYSCALL GetChar
				bcs .1					no char
				
				jsr CS.CHARIN

				lda (pData)
				bpl .1
				
				and #$7F
				sta (pData)

				jsr Cmd.Normalize
				lda (pData)
				beq .12					Empty line

				jsr HIS.Add

				>LDYA pData
				jsr Cmd.ExecYA
				
				ldy #S.PS.RC
				sta (pPs),y
				
				ldy	#bEXIT
				lda (pData),y
				bne CS.RUN.EXIT
				
.8				clc
				rts

CS.RUN.EXIT		lda #0
CS.RUN.EXIT.ERR	sec
CS.RUN.EXIT.RTS	rts	
*--------------------------------------
CS.RUN.READ		lda #0
				sta (pData)
				
.1				>SYSCALL Sleep
				>SYSCALL GetChar
				bcs .1					no char
				
				jsr CS.CHARIN

				>GETG.A bCmdBuf.exec
				bpl .1
				
				>PUSHW pData
				
				lda #VarBuffer
				clc
				adc pData
				tay
				lda pData+1
				adc #0
				>PUSHYA
				>SYSCALL SetEnv
				php
				pha
				
				ldy #VarBuffer
				lda #0
				sta (pData),y
				
				pla
				plp
				rts
*--------------------------------------
CS.RUN.BATCH	jsr	CSH.Run
				bcs .9
				
				lda (pData)
				beq .8					Empty line....nothing to do....

				jsr Cmd.Normalize
				lda (pData)
				beq .8
				
				>LDYA pData
				jsr Cmd.ExecYA
				
.8				ldy #S.PS.RC
				sta (pPs),y
				clc
				rts

.9				cmp #MLI.ERR.EOF
				bne .7
				lda #0
				sec
				rts
				
.7				pha
				
				ldy #CSH.BufPtr+1
				>PUSHB (pData),y
				dey
				>PUSHB (pData),y
				
				>LDYA L.MSG.CSHERR
				>SYSCALL PrintF.YA
				
				jsr CSH.RestorePtr
				
.90				jsr CSH.GetChar
				bcs .92
				>SYSCALL PutChar.A
				
.91				jsr CSH.GetNextChar
				bcs .92
				cmp #13
				beq .92
				>SYSCALL PutChar.A
				bra .91
				
.92				pla
				bra .99
				
.98				lda #0

.99				ldy #S.PS.RC
				sta (pPs),y
				pha
				
				ldy #bExitOnEOF
				lda (pData),y
				asl						CS if bExitOnEOF
				
				pla
				rts
*--------------------------------------
CS.DOEVENT		lda (pEvent)
				bpl .9

				jsr CheckSleep
				beq .9

*				ldy #Sleep				already set by CheckSleep
				clc
				ldx #4
				
.1				lda (pData),y
				sbc #0
				sta (pData),y
				iny
				dex
				bne .1

.9				sec
				rts
*--------------------------------------
CS.CHARIN		>ADDLOCAL 2				room for bCmdBuf
				>GETG.A hCmdBuf
				>SYSCALL GetMemPtr.A
				>SETL.YA 0
				
				tax						Save Char
				>GETG.A CSH.hBuf			Batch mode ?
				beq .10
* Batch Mode			
				cpx #3					test Ctrl-c
				bne .12
				
				>GETG.A bExitOnEOF
				>SETG.A bExit
				clc
				rts

.12				cpx #19					test Ctrl-s
				bne .8
				
				lda #$80
				>SETG.A bPause
				clc
				rts
				
* interactive mode				
.10				>GETG.A bEscMode
				beq .13
				
				cpx #'['
				beq .8
				
				lda #0
				sta (pData),y
				
				txa

				ldx EscChars
.17				cmp EscChars,x
				beq .18
				dex
				bne .17
				bra .8
				
.18				lda EscAscii,x				
				tax
				
.13				cpx #$20
				bcs .1
				jsr CS.CHARIN.CTRL
				bra .8

.1				cpx #$7f
				bne .2
				jsr CmdLine.DEL
				clc
				rts

.2				lda (pData)				CmdBuffer
				
				cmp #CmdLine.MAX
				beq .8
				
				inc
				sta (pData)
				tay
				txa
				sta (pData),y

				tax
				ldy #bSecureRead
				lda (pData),y
				bne .8
				
				txa
				>SYSCALL PutChar.A
				
.8				clc
				rts	
*--------------------------------------
CS.CHARIN.CTRL	cpx #13					CR
				bne .10
				txa
				>SYSCALL PutChar.A
				lda #10
				>SYSCALL PutChar.A
				
				lda #$ff
				>SETG.A bCmdBuf.exec
				clc
				rts
				
.10				cpx #$1B				esc
				bne .11
				
				lda #$ff
				>SETG.A bEscMode
				clc
				rts

.11				cpx #3					Ctrl-C
				bne .1

				jsr CmdLine.CLR
				clc
				rts
				
.1				cpx #8					BS (left arrow)
				bne .2
				jsr CmdLine.DEL
				clc
				rts
				
.2				cpx #10					LF (down arrow)
				bne .3
				
				jsr HIS.GetNext
				clc
				rts
				
.3				cpx #11					VT (up arrow)
				bne .4
				
				jsr HIS.GetPrev
				clc
				rts
				
.4				cpx #21					NAK (right arrow)
				bne .8
				
				clc
				rts
				
.8				clc
				rts
*--------------------------------------
CS.QUIT			jsr HIS.Quit

				jsr CSH.Quit

				clc
				rts
*--------------------------------------
CheckSleep		ldy #Sleep+3
				lda (pData),y
				dey
				ora (pData),y
				dey
				ora (pData),y
				dey
				ora (pData),y
				rts
*--------------------------------------
SetPWD			ldy #S.PS.hPREFIX
				lda (pPs),y
				>SYSCALL GetMemPtr.A
				>PUSHYA
				>PUSHW L.ENV.PWD
				>SYSCALL SetEnv
				rts
*--------------------------------------
PrintPrompt		>LDYA L.ENV.PS1
				>SYSCALL GetEnv.YA
				>SYSCALL ExpandStr.YA
				phx
				>PUSHYA
				>LDYA L.MSG.PROMPT
				>SYSCALL PrintF.YA
				plx
				php
				pha
				txa
				>SYSCALL FreeMem.A
				pla
				plp
.9				rts
*--------------------------------------
CmdLine.CLR		lda (pData)
				beq .9 		

				tay
				lda #8
				
.1				sta (pData),y
				dey
				bne .1
				jsr CmdLine.SET

				lda #0
				sta (pData)
				
.9				rts
*--------------------------------------
CmdLine.DEL		lda (pData)
				beq .9
				
				lda #8
				>SYSCALL PutChar.A
				lda (pData)
				dec
				sta (pData)
.9				rts
*--------------------------------------
CmdLine.SET		>PUSHW pData
				>LDYA L.MSG.PSTR
				>SYSCALL PrintF.YA
				rts
*--------------------------------------
				.INB /A2OSX.SRC/SBIN/SHELL.S.CMD
				.INB /A2OSX.SRC/SBIN/SHELL.S.CSH
				.INB /A2OSX.SRC/SBIN/SHELL.S.IO
				.INB /A2OSX.SRC/SBIN/SHELL.S.HIS
*--------------------------------------
CS.END
*--------------------------------------
ENV.PATH		>PSTR "PATH"
ENV.PWD			>PSTR "PWD"
ENV.PS1			>PSTR "PS1"
INTCMDS			>PSTR "CD"
				>PSTR "DATE"
				>PSTR "ECHO"
				>PSTR "EXIT"
				>PSTR "PAUSE"
				>PSTR "PWD"
				>PSTR "READ"
				>PSTR "SET"
				>PSTR "SLEEP"
				>PSTR "STARTPROC"
				>PSTR "TIME"
				.HS 00
CSHCMDS			>PSTR "IF"
				>PSTR "WHILE"
				>PSTR "BREAK"
				>PSTR "CONTINUE"
				>PSTR "CHAR"
				>PSTR "INT"
				>PSTR "LONG"
				>PSTR "FLOAT"
				.HS 00
*--------------------------------------
MSG.GREETINGS	>CSTR "\r\nA2osX-Shell\r\n\r\n"
MSG.PROMPT		>CSTR "%S$ "
MSG.ECHO		>CSTR ">%S\r\n"
MSG.PSTRCR		>CSTR "%S\r\n"
MSG.PSTR		>CSTR "%S"
MSG.ERROR		>CSTR "Err:%S [%h]\r\n"
MSG.PRINTENV	>CSTR "%S=%S\r\n"
MSG.CSHERR		>PSTR "Pos %D:"
FMT.DATE		>CSTR "%A, %B %d %Y"
FMT.TIME		>CSTR "%H:%M:%S (%I:%M:%S%p)"
*--------------------------------------
				.INB /A2OSX.SRC/X.ERRORS.S
*--------------------------------------
EscChars		>PSTR "DBAC"
EscAscii		.HS 04080A0B15
CMD				.BS 256
ARGS			.BS 256
TIME			.BS S.TIME
STAT			.BS S.STAT
bStartProc		.BS 1
CSH.TSIZE		.HS 0001020405			00,CHAR,INT,LONG,FLOAT....
CSH.ACCT		.BS 1
CSH.ACC			.BS 5
CSH.ARGT		.BS 1
CSH.ARG			.BS 5
*--------------------------------------
				.DUMMY
				.OR 0
DS.START
hCmdBuf			.BS 1
CmdBuf.len		.BS 1
bCmdBuf.exec	.BS 1

bReadMode		.BS 1

bEscMode		.BS 1
bPause			.BS 1
bExit			.BS 1
bEcho			.BS 1
bSecureRead		.BS 1
bExitOnEOF		.BS 1
Sleep			.BS 4
HIS.hBuf		.BS 1
HIS.BufIndex	.BS 1
HIS.BufEnd		.BS 1
IO.hIn			.BS 1
IO.hOut			.BS 1
IO.hErr			.BS 1
CSH.hBuf		.BS 1
CSH.BufPtr		.BS 2
CSH.BufLen		.BS 2
CSH.BufPtrSave	.BS 2
CSH.hSymbols	.BS 1
CSH.SymbolsPtr	.BS 1
CSH.hData		.BS 1
CSH.DataPtr		.BS 1
CSH.hStack		.BS 1
CSH.StackPtr	.BS 1
CSH.CmdSave		.BS 1
CSH.Name		.BS CSH.Name.MAX+1
DS.END			.ED
*--------------------------------------
MAN
SAVE /A2OSX.SRC/SBIN/SHELL.S
ASM
