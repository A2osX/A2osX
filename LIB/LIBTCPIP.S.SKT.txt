NEW
PREFIX /A2OSX.BUILD
AUTO 4,1
				.LIST OFF	
*/--------------------------------------
* # SKT.Socket
* Create a new socket
* ## C
* `hFD socket(short int type, short int protocol);`
* ## ASM
* **In:**
* `>PUSHB protocol`
* `lda type`
* `>LIBCALL hLIBTCPIP,LIBTCPIP.socket`
* **Out:**
* CC: A = hSOCKET
* CS: A = EC
*\--------------------------------------
SKT.Socket		sta FD.SSOCK+S.SOCKET.T		save type
				tax
				
				>PULLA						get protocol (RAW)
				
				jmp (J.SKT.Socket,x)
				
SKT.Socket.RAW
				ldy #S.SOCKET
				bra SKT.Socket.NEW
SKT.Socket.DGRAM
				lda #S.IP.PROTOCOL.UDP
				sta TmpDWord
				ldy #S.SOCKET
				bra SKT.Socket.NEW
SKT.Socket.STREAM
				lda #S.IP.PROTOCOL.TCP
				sta TmpDWord
				ldy #S.SOCKET.TCP
				bra SKT.Socket.NEW
SKT.Socket.SEQPACKET
				lda #S.IP.PROTOCOL.TCP
				sta TmpDWord
				ldy #S.SOCKET.TCP
				
SKT.Socket.NEW	lda #0
				>SYSCALL GetMem0
				bcs .99
				>STYA ZPPtrSKT
				stx FD.SSOCK+S.FD.SOCK.HSKT
				
				ldy #0
				
.1				lda SKT.TABLE,y
				beq .2
				iny
				cpy #K.SKTTABLE.SIZE
				bne .1
				
				txa
				>SYSCALL freemem
				lda #K.E.OOH
				sec
.99				rts

.2				txa						x = hFD
				sta SKT.TABLE,y

				ldy #FD.SSOCK.SIZE-1
				
.3				lda FD.SSOCK,y
				sta (ZPPtrSKT),y
				dey
				bpl .3
				
				txa
				clc
				rts
*/--------------------------------------
* # SKT.bind
* bind a name to a socket
* ## C
* `int bind(hFD fd, const struct sockaddr *addr);`
* ## ASM
* **In:**
* `>PUSHW addr`
* `lda fd`
* `>LIBCALL hLIBTCPIP,LIBTCPIP.socket`
* **Out:**
* CC: A = hSOCKET
* CS: A = EC
*\--------------------------------------
SKT.bind		>SYSCALL GetMemPtr
				>STYA ZPPtrSKT
				
				>PULLW ZPTmpPtr1
				
				ldy #S.SOCKADDR-1
				
.1				lda (ZPTmpPtr1),y
				sta SKT.ADDRCache,y
				dey
				bne .1
				
				jsr SKT.FindMatching
				bcc .9
				
				ldy #S.SOCKET.SRC.ADDR+S.SOCKADDR-1
				
.2				lda SKT.ADDRCache-S.SOCKET.SRC.ADDR,y
				sta (ZPTmpPtr1),y
				bne .7
				dey
				bpl .2
								
				clc
				rts
				
.9				lda #ERR.SKT.BUSY
				sec
				rts
*--------------------------------------				
SKT.FindMatching

				ldx #0
				
.1				lda SKT.TABLE,x
				beq .7
				
				>SYSCALL GetMemPtr
				>STYA ZPTmpPtr1
				
				ldy #S.SOCKET.SRC.ADDR+S.SOCKADDR-1
				
.2				lda (ZPTmpPtr1),y
				cmp SKT.ADDRCache-S.SOCKET.SRC.ADDR,y
				bne .7
				dey
				bpl .2
				
				>LDYA ZPTmpPtr1
				clc
				rts
				
.7				inx
				cpx #K.SKTTABLE.SIZE
				bne .1
				
*				sec
			
.9				rts
*/--------------------------------------
* # SKT.connect
* Iinitiate a connection on a socket
* ## C
* `int connect(hFD fd, const struct sockaddr *addr);`
* ## ASM
* **In:**
* `>PUSHW addr`
* `lda fd`
* `>LIBCALL hLIBTCPIP,LIBTCPIP.socket`
* **Out:**
* CC: A = hSOCKET
* CS: A = EC
*\--------------------------------------
SKT.connect		>SYSCALL GetMemPtr
				>STYA ZPPtrSKT
				
				>PULLW ZPTmpPtr1		sockaddr
				
				ldy #S.SOCKET.T
				lda (ZPTmpPtr1),y
				tax
				jmp (J.SKT.connect,x)
				
SKT.connect.RAW
SKT.connect.DGRAM


SKT.connect.STREAM
SKT.connect.SEQPACKET
				
*/--------------------------------------
* # SKT.listen
* Create a new socket
* ## C
* `int listen(hFD fd);`
* ## ASM
* **In:**
* `>PUSHW addr`
* `lda fd`
* `>LIBCALL hLIBTCPIP,LIBTCPIP.socket`
* **Out:**
* CC: A = hSOCKET
* CS: A = EC
*\--------------------------------------
SKT.listen
*/--------------------------------------
* # SKT.New
* Create a new socket
* ## C
* `hSOCKET skt.new(void *template);`
* ## ASM
* **In:**
* `>PUSHW template`
* `>LIBCALL hLIBTCPIP,LIBTCPIP.SKT.New`
* **Out:**
* CC: A = hSOCKET
* CS: A = EC
*\--------------------------------------
SKT.New			>PULLW ZPTmpPtr1
				ldy #S.SOCKET.SRC.PORT+1
				lda (ZPTmpPtr1),y
				dey
				ora (ZPTmpPtr1),y
				bne .1
				
				jsr GetDynPort
				
				sta (ZPTmpPtr1),y
				txa
				iny
				sta (ZPTmpPtr1),y
				
.1				lda hSocketTable
				>SYSCALL GetMemPtr
				>STYA ZPTmpPtr2

				lda #$ff
				sta TmpByte				to keep track of any free slot
				
				ldx #0
				
.2				lda (ZPTmpPtr2)
				beq .4					empty!!!
				
				cmp (ZPTmpPtr1)
				bne .5					not same SKT type...try next
				
				ldy #S.SOCKET.SRC.ADDR
				
.3				lda (ZPTmpPtr1),y
				cmp (ZPTmpPtr2),y
				bne .5
				iny
				cpy #S.SOCKET.DST.PORT+2
				bne .3

				lda #ERR.SKT.BUSY		same one!!!!! busy...
				sec
				rts
				
.4				lda TmpByte
				bpl .5					already found an empty slot....

				>LDYA ZPTmpPtr2			found one...
				>STYA ZPPtrSKT			save it!
				stx TmpByte
				
.5				lda ZPTmpPtr2
				clc
				adc #S.SOCKET
				sta ZPTmpPtr2
				bcc .6
				inc ZPTmpPtr2+1
.6				inx
				cpx #K.SKTTABLE.SIZE
				bne .2
				
				lda TmpByte				Did we found an empty slot ?
				bmi .9
				
				ldy #S.SOCKET-1
				lda #0
				
.70				sta (ZPPtrSKT),y			
				dey
				cpy #S.SOCKET.HDR-1
				bne .70
				
.7				lda (ZPTmpPtr1),y
				sta (ZPPtrSKT),y
				dey
				bpl .7

				lda (ZPPtrSKT)
				cmp #S.SOCKET.T.STREAM
				bne .8
				
				ldy #S.SOCKET.O
				lda (ZPPtrSKT),y

				and #S.SOCKET.O.ACCEPTCONN
				bne .8					From Listen, do not send SYN packet
				
				jsr SKT.NewTCB
				bcs .99

				ldy #S.SOCKET.TCP.O
				lda (ZPPtrSKT),y
				ora #S.TCP.OPTIONS.SYN
				jsr TCP.OUT.SendOptA	Send SYN,Only for CLIENT conn,or SYN/ACK if coming from LISTEN
				bcs .99
				
				ldy #S.SOCKET.TCP.S
				lda #S.SOCKET.TCP.S.SYNSENT
				sta (ZPPtrSKT),y
				
.8				lda TmpByte
				ora #$80
				
				clc
				rts
				
.9				lda #ERR.SKT.OOS
				sec
.99				rts
*/--------------------------------------
* # SKT.Close
*  Close socket
* **In:** 
*  A = hSocket
* **Out:** 
*\--------------------------------------
SKT.Close		jsr SKT.Get.I			get SKT in ZPPtrSKT, S.SOCKET.T in A
				bcs .99
				
				cmp #S.SOCKET.T.STREAM
				beq .10					TCP
				cmp #S.SOCKET.T.RAW+1
				bcs .9					no #S.SOCKET.T.DGRAM, nor #S.SOCKET.T.RAW
				
.1				ldy #S.SOCKET.HQ.TAIL
				lda (ZPPtrSKT),y
				ldy #S.SOCKET.HQ.HEAD
				cmp (ZPPtrSKT),y
				beq .8					No frame in Queue, close..
				
				pha						save tail...
				clc
				adc #S.SOCKET.HQ
				tax
				pla
				inc
				cmp #S.SOCKET.HQ.MAX
				beq .2
				
				lda #0
				
.2				ldy #S.SOCKET.HQ.TAIL
				sta (ZPPtrSKT),y
				
				txa
				tay
				lda (ZPPtrSKT),y
				>SYSCALL FreeMem
				bra .1
				
.8				lda #0
				sta (ZPPtrSKT)
				clc
				rts
				
.9				lda #ERR.SKT.BAD
				sec
.99				rts
											
.10				ldy #S.SOCKET.O
				lda (ZPPtrSKT),y
				bit #S.SOCKET.O.ACCEPTCONN
				
				bne *					TO DO: Listening socket
				
				ldy #S.SOCKET.TCP.S
				lda (ZPPtrSKT),y
				cmp #S.SOCKET.TCP.S.CLWAIT
				bne .11
				
				lda #S.SOCKET.TCP.S.LASTACK
				bra .12
				
.11				lda #S.SOCKET.TCP.S.FINWT1
.12				sta (ZPPtrSKT),y

				ldy #S.SOCKET.TCP.O
				lda (ZPPtrSKT),y
				ora #S.TCP.OPTIONS.FIN+S.TCP.OPTIONS.ACK
				sta (ZPPtrSKT),y
				
				jmp TCP.OUT				Try to push FIN/ACK			
*/--------------------------------------
* # SKT.Get
*  Get Ptr to socket
* **In:** 
*  A = hSocket
* **Out:** 
*  Y,A = pS.SOCKET
*\--------------------------------------
SKT.Get			jsr SKT.Get.I
				
				bcs .9
				
				>LDYA ZPPtrSKT
				
.9				rts
				
SKT.Get.I		and #$7f
				
				cmp #K.SKTTABLE.SIZE 
				bcs .9
				
				pha
				lda hSocketTable
				>SYSCALL GetMemPtr
				>STYA ZPPtrSKT
				
				pla
				beq .8
				
				stz .1+1
				lsr
				ror .1+1
				lsr
				ror .1+1
				lsr
				ror .1+1
				
				pha
				
				lda ZPPtrSKT
				clc
.1				adc #$ff
				sta ZPPtrSKT
				
				pla				
				adc ZPPtrSKT+1
				sta ZPPtrSKT+1
			
.8				lda (ZPPtrSKT)
				beq .9

				clc
				rts
				
.9				lda #ERR.SKT.BAD
				sec
				rts
*/--------------------------------------
* # SKT.GetTable
*  Get socket table
* **In:** 
* **Out:** 
*  Y,A = pS.SOCKET
*\--------------------------------------
SKT.GetTable	lda hSocketTable
				>SYSCALL GetMemPtr
				clc
				rts
*/--------------------------------------
* # SKT.Accept
*  Check for an incoming connection
* **In:** 
*  A = hListeningSocket
* **Out:** 
*  A = hSocket
*\--------------------------------------
SKT.Accept		jsr SKT.Get.I
				bcs .9
				ldy #S.SOCKET.O
				lda (ZPPtrSKT),y
				and #S.SOCKET.O.ACCEPTCONN
				beq .99
				
				ldy #S.SOCKET.HQ.TAIL
				lda (ZPPtrSKT),y
				ldy #S.SOCKET.HQ.HEAD
				cmp (ZPPtrSKT),y		Queue Empty
				beq .9					CS
				
				pha						save tail...
				inc
				cmp #S.SOCKET.HQ.MAX
				bne .1
				
				lda #0
				
.1				ldy #S.SOCKET.HQ.TAIL
				sta (ZPPtrSKT),y
				pla
				clc
				adc #S.SOCKET.HQ
				tay
				lda (ZPPtrSKT),y
				clc
				rts
				
.99				lda #ERR.SKT.BAD
				sec
.9				rts
*/--------------------------------------
* # SKT.MkNod
* ## C
* `hFD skt.mknod(hSOCKET s);`
* ## ASM
* **In:**
* `lda s`
* `>LIBCALL hLIBTCPIP,LIBTCPIP.SKT.MkNod`
* **Out:**
* CC: A = hFD
* CS: A = EC
*\--------------------------------------
SKT.MkNod		sta FD.SSOCK+S.FD.SOCK.HSKT

				>LDYAI S.FD.SOCK
				>SYSCALL getmem0
				bcs .9
				
				>STYA ZPTmpPtr1

				ldy #S.FD.SOCK-1
				
.2				lda FD.SSOCK,y
				sta (ZPTmpPtr1),y
				dey
				bpl .2
				
				txa
*				clc
				
.9				rts
*/--------------------------------------
* # SKT.Read (STREAM)
* ## C
* `int skt.read(hFD fd, void *buf, int count);`
* ## ASM
* **In:**
* `>PUSHWI count`
* `>PUSHW buf`
* `lda fd`
* `>LIBCALL hLIBTCPIP,LIBTCPIP.skt.read`
* **Out:**
* CC: Y,A = bytes read
* CS: A = EC
*\--------------------------------------
SKT.Read 		pha
				>PULLW ZPDataInPtr		!!!DataOut trashed when sending ACK in TCP.OUT	
				>PULLW ZPDataInLen		!!!use DataInPtr/Len
				pla

SKT.Read.I		jsr SKT.Get.I
				bcs .99
				cmp #S.SOCKET.T.STREAM
				bne .90					bad skt
				
				ldy #S.SOCKET.O
				lda (ZPPtrSKT),y
				and #S.SOCKET.O.ACCEPTCONN
				bne .90					Bad Skt
				
				ldy #S.SOCKET.TCP.S
				lda (ZPPtrSKT),y
				cmp #S.SOCKET.TCP.S.ESTBLSH
				bcc .92					Not yet established...no data
				cmp #S.SOCKET.TCP.S.FINWT2
				bcs .91					closing...IO err

				jsr SKT.GetDataFromSktIn
				rts						if CS, No data...
				
.90				lda #ERR.SKT.BAD
				sec
				rts
				
.91				lda #MLI.E.IO
				sec
				rts

.92				lda #0
				sec
.99				rts
*/--------------------------------------
* # SKT.Write (STREAM)
* ## C
* `int skt.write(hFD fd, const void *buf, int count);`
* ## ASM
* **In:**
* `>PUSHWI count`
* `>PUSHW buf`
* `lda fd`
* `>LIBCALL hLIBTCPIP,LIBTCPIP.skt.write`
* **Out:**
* CC: Y,A = bytes written
* CS: A = EC
*\--------------------------------------
SKT.Write		pha
				>PULLW ZPDataInPtr
				>PULLW ZPDataInLen
				pla

				jsr SKT.Get.I
				bcs .9

				cmp #S.SOCKET.T.STREAM
				bne .99
				
				ldy #S.SOCKET.O
				lda (ZPPtrSKT),y
				and #S.SOCKET.O.ACCEPTCONN
				bne .99
				
				ldy #S.SOCKET.TCP.S	
				lda (ZPPtrSKT),y
				cmp #S.SOCKET.TCP.S.ESTBLSH
				bne .91

				jsr SKT.AddDataToSktOut   will call SKT.GetTCB 
				bcs .90

				jsr TCP.OUT.I			SKT.GetTCB called, try to push, ignore error....
				clc
				rts
				
.90				lda #0					no data transfered
				sec
				rts
				
.91				lda #MLI.E.IO
				sec
				rts
				
.99				lda #ERR.SKT.BAD
				sec
.9				rts
*/--------------------------------------
* # SKT.Rcvd (DGRAM,RAW)
* **In:** 
*  A = hSocket
* **Out:** 
*  A = hFrame
*\--------------------------------------
SKT.Rcvd		jsr SKT.Get.I
				bcs .9
				
				ldy #S.SOCKET.HQ.TAIL
				lda (ZPPtrSKT),y
				tax
				
				ldy #S.SOCKET.HQ.HEAD
				cmp (ZPPtrSKT),y
				beq .99
				
				inc
				cmp #S.SOCKET.HQ.MAX
				bne .1
				lda #0
				
.1				ldy #S.SOCKET.HQ.TAIL
				sta	(ZPPtrSKT),y
				
				txa
				clc
				adc #S.SOCKET.HQ
				tay
				lda (ZPPtrSKT),y
				clc
				rts
				
.99				sec
.9				rts
*/--------------------------------------
* # SKT.Send (DGRAM,RAW)
* ## C
* `int skt.send(hFD fd, const void *buf, int count);`
* ## ASM
* **In:**
* `>PUSHWI count`
* `>PUSHW buf`
* `lda fd`
* `>LIBCALL hLIBTCPIP,LIBTCPIP.skt.send`
* **Out:**
* CC: Y,A = bytes written
* CS: A = EC
*\--------------------------------------
SKT.Send		pha
				>PULLW ZPDataInPtr
				>PULLW ZPDataInLen
				pla

				jsr SKT.Get.I
				bcs SKT.Send.9

				cmp #S.SOCKET.T.DGRAM
				beq SKT.Send.UDP
			
				cmp #S.SOCKET.T.RAW
				beq SKT.Send.RAW
				
				lda #ERR.SKT.BAD
				sec
SKT.Send.9		rts
*--------------------------------------
SKT.Send.RAW	ldy #S.SOCKET.RAW.PROTO
				lda (ZPPtrSKT),y

				tax
				>LDYA ZPDataInLen
				jsr FRM.NewIP
				bcs SKT.Send.9
				
				bra SKT.Send.UDP.8
*--------------------------------------
SKT.Send.UDP	ldx #S.IP.PROTOCOL.UDP
				>LDYA ZPDataInLen
				jsr FRM.NewIP
				bcs SKT.Send.9
				
				jsr SKT.SetFrameOutTCPUDPPorts
				
SKT.Send.UDP.8	jsr SKT.SetFrameOutDstIP
				
				jsr SKT.CopyDataInToOut				

				jmp FRM.SendIP
*--------------------------------------
*  PRIVATE
*--------------------------------------
* ZPPtrSKT -> actual socket
* A = hSocket or hFrame
*--------------------------------------
SKT.AddToQueueA sta .2+1
				ldy #S.SOCKET.HQ.HEAD
				lda (ZPPtrSKT),y
				tax
				inc 
				cmp #S.SOCKET.HQ.MAX
				bne .1
				lda #0
				
.1				ldy #S.SOCKET.HQ.TAIL
				cmp (ZPPtrSKT),y
				beq .9					Queue full!!
				
				ldy #S.SOCKET.HQ.HEAD
				sta (ZPPtrSKT),y
				txa
				clc
				adc #S.SOCKET.HQ
				tay
				
.2				lda #$ff
				sta (ZPPtrSKT),y
				clc
				rts
				
.9				sec
				rts
*--------------------------------------
* From TCP.IN
* Src : ZPDataInPtr/ZPDataInLen
* Dst : hInMem/INHEAD
*--------------------------------------
SKT.AddDataToSktIn
				ldx SKT.TCBCache+S.SOCKET.TCP.INFREE
				cpx ZPDataInLen
				lda SKT.TCBCache+S.SOCKET.TCP.INFREE+1
				sbc ZPDataInLen+1
				bcc .9					Not enough room in Q
				
				ldy #S.TCP.SEQNUM+3
				ldx #3

.10				lda (ZPFrameInPtr),y
				eor SKT.TCBCache+S.SOCKET.TCP.INLASTSEQNUM,x
				bne .9
				dey
				dex
				bpl .10
				
				ldy #S.SOCKET.SQ.hInMem
				lda (ZPPtrSKT),y
				>SYSCALL GetMemPtr
				>STYA ZPTmpPtr1			Make ZPTmpPtr1=buffer base

				lda ZPTmpPtr1
				clc
				adc SKT.TCBCache+S.SOCKET.TCP.INHEAD
				sta ZPTmpPtr2

				lda ZPTmpPtr1+1
				adc SKT.TCBCache+S.SOCKET.TCP.INHEAD+1
				sta ZPTmpPtr2+1			Make ZPTmpPtr2=base+Tail
				
				lda ZPDataInLen
				eor #$FF
				tax
				
				lda ZPDataInLen+1
				eor #$FF
				pha
				
				ldy #0

.1				inx
				bne .2
				pla
				inc
				beq .8
				
				pha
				
.2				lda (ZPDataInPtr),y
				sta (ZPTmpPtr2)
				iny
				bne .3
				inc ZPDataInPtr+1

.3				inc ZPTmpPtr2
				bne .4
				inc ZPTmpPtr2+1
				
.4				inc SKT.TCBCache+S.SOCKET.TCP.INHEAD
				bne .1
				inc SKT.TCBCache+S.SOCKET.TCP.INHEAD+1
				lda SKT.TCBCache+S.SOCKET.TCP.INHEAD+1
				cmp /K.TCP.WSIZE
				bne .1
				stz SKT.TCBCache+S.SOCKET.TCP.INHEAD+1
				
				lda ZPTmpPtr1			Dst Ptr=Buffer Base
				sta ZPTmpPtr2
				lda ZPTmpPtr1+1
				sta ZPTmpPtr2+1
				bra .1

.9				sec
				rts
				
.8				lda SKT.TCBCache+S.SOCKET.TCP.INFREE
				sec 
				sbc ZPDataInLen
				sta SKT.TCBCache+S.SOCKET.TCP.INFREE
				
				lda SKT.TCBCache+S.SOCKET.TCP.INFREE+1
				sbc ZPDataInLen+1
				sta SKT.TCBCache+S.SOCKET.TCP.INFREE+1
				
				lda SKT.TCBCache+S.SOCKET.TCP.INUSED
				clc 
				adc ZPDataInLen
				sta SKT.TCBCache+S.SOCKET.TCP.INUSED
				
				lda SKT.TCBCache+S.SOCKET.TCP.INUSED+1
				adc ZPDataInLen+1
				sta SKT.TCBCache+S.SOCKET.TCP.INUSED+1
			
				clc
				
				lda SKT.TCBCache+S.SOCKET.TCP.INLASTSEQNUM+3
				adc ZPDataInLen
				sta SKT.TCBCache+S.SOCKET.TCP.INLASTSEQNUM+3
				
				lda SKT.TCBCache+S.SOCKET.TCP.INLASTSEQNUM+2
				adc ZPDataInLen+1
				sta SKT.TCBCache+S.SOCKET.TCP.INLASTSEQNUM+2
				bcc .80
				inc SKT.TCBCache+S.SOCKET.TCP.INLASTSEQNUM+1
				bne .80
				inc SKT.TCBCache+S.SOCKET.TCP.INLASTSEQNUM

.80				clc
				rts
*--------------------------------------
* From SKT.Read
* In:
*  Src : hInMem/INTAIL
*  Dst : ZPDataOutPtr/ZPDataOutLen
* Out:
*  Y,A = bytes read
*--------------------------------------
SKT.GetDataFromSktIn
				jsr SKT.GetTCB
				lda SKT.TCBCache+S.SOCKET.TCP.INUSED
				ora SKT.TCBCache+S.SOCKET.TCP.INUSED+1
				bne .10
				sec
				rts						A=0,NO DATA

.10				ldy #S.SOCKET.SQ.hInMem
				lda (ZPPtrSKT),y
				>SYSCALL GetMemPtr
				>STYA ZPTmpPtr1			Make ZPTmpPtr1=buffer base

				lda ZPTmpPtr1
				clc
				adc SKT.TCBCache+S.SOCKET.TCP.INTAIL
				sta ZPTmpPtr2

				lda ZPTmpPtr1+1
				adc SKT.TCBCache+S.SOCKET.TCP.INTAIL+1
				sta ZPTmpPtr2+1
				
				lda ZPDataInLen
				eor #$FF
				tax
				
				lda ZPDataInLen+1
				eor #$FF
				pha
				
				stz ZPTmpPtr3			Reset byte counter
				stz ZPTmpPtr3+1
				
				ldy #0
				
.1				inx						Check if room left in dest buffer
				bne .2
				pla
				inc
				beq .8

				pha
				
.2				lda SKT.TCBCache+S.SOCKET.TCP.INTAIL
				eor SKT.TCBCache+S.SOCKET.TCP.INHEAD
				bne .3
				lda SKT.TCBCache+S.SOCKET.TCP.INTAIL+1
				eor SKT.TCBCache+S.SOCKET.TCP.INHEAD+1
				beq .7					no more data....
				
.3				lda (ZPTmpPtr2)
				pha
				
				inc SKT.TCBCache+S.SOCKET.TCP.INTAIL
				bne .4
				
				inc SKT.TCBCache+S.SOCKET.TCP.INTAIL+1
				lda SKT.TCBCache+S.SOCKET.TCP.INTAIL+1
				cmp /K.TCP.WSIZE
				bne .4
				
				stz SKT.TCBCache+S.SOCKET.TCP.INTAIL+1
				lda ZPTmpPtr1
				sta ZPTmpPtr2
				lda ZPTmpPtr1+1
				sta ZPTmpPtr2+1
				bra .5
				
.4				inc ZPTmpPtr2
				bne .5
				inc ZPTmpPtr2+1
				
.5				pla						get back data....
				
.6				sta (ZPDataInPtr),y
				iny
				bne .61
				inc ZPDataInPtr+1
				
.61				inc ZPTmpPtr3
				bne .1
				inc ZPTmpPtr3+1
				
				bra .1
				
.7				pla						discard byte counter HI

.8				lda ZPTmpPtr3			Do we have transfered something?
				ora ZPTmpPtr3+1
				beq .9
				
				lda SKT.TCBCache+S.SOCKET.TCP.INFREE
				clc
				adc ZPTmpPtr3
				sta SKT.TCBCache+S.SOCKET.TCP.INFREE
				
				lda SKT.TCBCache+S.SOCKET.TCP.INFREE+1
				adc ZPTmpPtr3+1
				sta SKT.TCBCache+S.SOCKET.TCP.INFREE+1

				lda SKT.TCBCache+S.SOCKET.TCP.INUSED
				sec
				sbc ZPTmpPtr3
				sta SKT.TCBCache+S.SOCKET.TCP.INUSED
				
				lda SKT.TCBCache+S.SOCKET.TCP.INUSED+1
				sbc ZPTmpPtr3+1
				sta SKT.TCBCache+S.SOCKET.TCP.INUSED+1

				lda SKT.TCBCache+S.SOCKET.TCP.OUTACKNUM+3
				clc 
				adc ZPTmpPtr3
				sta SKT.TCBCache+S.SOCKET.TCP.OUTACKNUM+3
				
				lda SKT.TCBCache+S.SOCKET.TCP.OUTACKNUM+2
				adc ZPTmpPtr3+1
				sta SKT.TCBCache+S.SOCKET.TCP.OUTACKNUM+2
				
				bcc .80
				inc SKT.TCBCache+S.SOCKET.TCP.OUTACKNUM+1
				bne .80
				inc SKT.TCBCache+S.SOCKET.TCP.OUTACKNUM
				
.80				jsr SKT.StoreTCB

				ldy #S.SOCKET.TCP.O
				lda (ZPPtrSKT),y
				ora #S.TCP.OPTIONS.ACK
				sta (ZPPtrSKT),y

				jsr TCP.OUT.I			SKT.GetTCB already called, Try to ACK read DATA
				
				>LDYA ZPTmpPtr3
				clc
				rts
				
.9				
*				lda #0					NO DATA
				sec
				rts
*--------------------------------------
* From SKT.Write.TCP
* Src : ZPDataInPtr/ZPDataInLen
* Dst : hOutMem/OUTHEAD
*--------------------------------------
SKT.AddDataToSktOut
				jsr SKT.GetTCB 
				ldx SKT.TCBCache+S.SOCKET.TCP.OUTFREE
				cpx ZPDataInLen
				lda SKT.TCBCache+S.SOCKET.TCP.OUTFREE+1
				sbc ZPDataInLen+1
				bcc .9					Not enough room in Q
				
				ldy #S.SOCKET.SQ.hOutMem
				lda (ZPPtrSKT),y
				>SYSCALL GetMemPtr
				>STYA ZPTmpPtr1			Make ZPTmpPtr1=buffer base

				lda ZPTmpPtr1
				clc
				adc SKT.TCBCache+S.SOCKET.TCP.OUTHEAD
				sta ZPTmpPtr2

				lda ZPTmpPtr1+1
				adc SKT.TCBCache+S.SOCKET.TCP.OUTHEAD+1
				sta ZPTmpPtr2+1			Make ZPTmpPtr2=base+Tail
				
				lda ZPDataInLen
				eor #$FF
				tax
				
				lda ZPDataInLen+1
				eor #$FF
				pha
				
				ldy #0

.1				inx
				bne .2
				pla
				inc
				beq .8
				
				pha
				
.2				lda (ZPDataInPtr),y
				sta (ZPTmpPtr2)
				iny
				bne .3
				inc ZPDataInPtr+1

.3				inc ZPTmpPtr2
				bne .4
				inc ZPTmpPtr2+1
				
.4				inc SKT.TCBCache+S.SOCKET.TCP.OUTHEAD
				bne .1
				inc SKT.TCBCache+S.SOCKET.TCP.OUTHEAD+1
				lda SKT.TCBCache+S.SOCKET.TCP.OUTHEAD+1
				cmp /K.TCP.WSIZE
				bne .1
				stz SKT.TCBCache+S.SOCKET.TCP.OUTHEAD+1
				
				lda ZPTmpPtr1			Dst Ptr=Buffer Base
				sta ZPTmpPtr2
				lda ZPTmpPtr1+1
				sta ZPTmpPtr2+1
				bra .1

.9				sec
				rts
				
.8				lda SKT.TCBCache+S.SOCKET.TCP.OUTFREE
				sec 
				sbc ZPDataInLen
				sta SKT.TCBCache+S.SOCKET.TCP.OUTFREE
				lda SKT.TCBCache+S.SOCKET.TCP.OUTFREE+1
				sbc ZPDataInLen+1
				sta SKT.TCBCache+S.SOCKET.TCP.OUTFREE+1
				
				lda SKT.TCBCache+S.SOCKET.TCP.OUTUSED
				clc 
				adc ZPDataInLen
				sta SKT.TCBCache+S.SOCKET.TCP.OUTUSED
				lda SKT.TCBCache+S.SOCKET.TCP.OUTUSED+1
				adc ZPDataInLen+1
				sta SKT.TCBCache+S.SOCKET.TCP.OUTUSED+1
			
				lda SKT.TCBCache+S.SOCKET.TCP.OUTTOSEND
				clc 
				adc ZPDataInLen
				sta SKT.TCBCache+S.SOCKET.TCP.OUTTOSEND
				lda SKT.TCBCache+S.SOCKET.TCP.OUTTOSEND+1
				adc ZPDataInLen+1
				sta SKT.TCBCache+S.SOCKET.TCP.OUTTOSEND+1
				jsr SKT.StoreTCB
				rts
*--------------------------------------
* From TCP.OUT
* Src : hOutMem/OUTTAIL
* Dst : ZPDataOutPtr/ZPDataOutLen
*--------------------------------------
SKT.GetDataFromSktOut
				ldy #S.SOCKET.SQ.hOutMem
				lda (ZPPtrSKT),y
				
				>SYSCALL GetMemPtr
				>STYA ZPTmpPtr1			Make ZPTmpPtr1=buffer base

				lda ZPTmpPtr1
				clc
				adc SKT.TCBCache+S.SOCKET.TCP.OUTTAILNEXT
				sta ZPTmpPtr2			Make ZPTmpPtr2=base+nexttail

				lda ZPTmpPtr1+1
				adc SKT.TCBCache+S.SOCKET.TCP.OUTTAILNEXT+1
				sta ZPTmpPtr2+1
				
				lda ZPDataOutLen
				eor #$FF
				tax
				
				lda ZPDataOutLen+1
				eor #$FF
				pha
				
				ldy #0

.1				inx
				bne .2
				pla
				inc
				beq .8
				
				pha
				
.2				lda (ZPTmpPtr2)
				sta (ZPDataOutPtr),y
				iny
				bne .3
				inc ZPDataOutPtr+1

.3				inc ZPTmpPtr2
				bne .4
				inc ZPTmpPtr2+1
				
.4				inc SKT.TCBCache+S.SOCKET.TCP.OUTTAILNEXT
				bne .1
				inc SKT.TCBCache+S.SOCKET.TCP.OUTTAILNEXT+1
				lda SKT.TCBCache+S.SOCKET.TCP.OUTTAILNEXT+1
				cmp /K.TCP.WSIZE
				bne .1
				stz SKT.TCBCache+S.SOCKET.TCP.OUTTAILNEXT+1
				
				lda ZPTmpPtr1			Dst Ptr=Buffer Base
				sta ZPTmpPtr2
				lda ZPTmpPtr1+1
				sta ZPTmpPtr2+1
				bra .1

.8				lda SKT.TCBCache+S.SOCKET.TCP.OUTTOSEND
				sec
				sbc ZPDataOutLen
				sta SKT.TCBCache+S.SOCKET.TCP.OUTTOSEND
				lda SKT.TCBCache+S.SOCKET.TCP.OUTTOSEND+1
				sbc ZPDataOutLen+1
				sta SKT.TCBCache+S.SOCKET.TCP.OUTTOSEND+1
				
				clc
				rts
*--------------------------------------
* From TCP.IN
* Src : A,X
* Dst : hOutMem/OUTTAIL
*--------------------------------------
SKT.AckDataToSktOut
				ldy #S.TCP.ACKNUM+3		Get new ACK number from FrameIn...
				ldx #3					Substract old ACK from socket

				sec

.1				lda (ZPFrameInPtr),y
				pha
				sbc SKT.TCBCache+S.SOCKET.TCP.OUTSEQNUM,x
				sta TmpDWord,x
				pla						....and Set SEQ = new SEQ
				sta SKT.TCBCache+S.SOCKET.TCP.OUTSEQNUM,x
				dey
				dex
				bpl .1
				
				lda TmpDWord+3
				ldx TmpDWord+2
				bne .2
				tay
				beq .8
				
.2				clc
				adc SKT.TCBCache+S.SOCKET.TCP.OUTTAIL
				sta SKT.TCBCache+S.SOCKET.TCP.OUTTAIL
				
				txa
				adc SKT.TCBCache+S.SOCKET.TCP.OUTTAIL+1
				and /K.TCP.WSIZE-1
				sta SKT.TCBCache+S.SOCKET.TCP.OUTTAIL+1

				lda SKT.TCBCache+S.SOCKET.TCP.OUTFREE
				clc
				adc TmpDWord+3
				sta SKT.TCBCache+S.SOCKET.TCP.OUTFREE
				lda SKT.TCBCache+S.SOCKET.TCP.OUTFREE+1
				adc TmpDWord+2
				sta SKT.TCBCache+S.SOCKET.TCP.OUTFREE+1
				
				lda SKT.TCBCache+S.SOCKET.TCP.OUTUSED
				sec
				sbc TmpDWord+3
				sta SKT.TCBCache+S.SOCKET.TCP.OUTUSED
				lda SKT.TCBCache+S.SOCKET.TCP.OUTUSED+1
				sbc TmpDWord+2
				sta SKT.TCBCache+S.SOCKET.TCP.OUTUSED+1
								
.8				rts
*--------------------------------------
SKT.NewTCB		>LDYAI S.TCB
				>SYSCALL getmem0
				bcs .9
				
				>STYA .4+1
				txa

				ldy #S.SOCKET.SQ.hTCB
				sta (ZPPtrSKT),y

				lda #K.TCP.WSIZE
				sta SKT.TCBCache+S.SOCKET.TCP.INFREE
				sta SKT.TCBCache+S.SOCKET.TCP.OUTFREE
				lda /K.TCP.WSIZE
				sta SKT.TCBCache+S.SOCKET.TCP.INFREE+1
				sta SKT.TCBCache+S.SOCKET.TCP.OUTFREE+1

				ldx #3
				
.2				lda A2osX.TIMER16,x
				sta SKT.TCBCache+S.SOCKET.TCP.OUTNEXTSEQ,x
				dex
				bpl .2
				
				>LDYAI K.TCP.WSIZE
				>SYSCALL getmem
				bcs .9
				txa
				
				ldy #S.SOCKET.SQ.hInMem
				sta (ZPPtrSKT),y
				
				>LDYAI K.TCP.WSIZE
				>SYSCALL getmem
				bcs .9
				txa
				
				ldy #S.SOCKET.SQ.hOutMem
				sta (ZPPtrSKT),y

				ldx #S.TCB-1
				
.3				lda SKT.TCBCache,x
.4				sta $ffff,x
				dex
				bpl .3
				
				clc
.9				rts
*--------------------------------------
SKT.GetTCB	 	ldy #S.SOCKET.SQ.hTCB
				lda (ZPPtrSKT),y
				>SYSCALL GetMemPtr
				bcs *
				>STYA .1+1
				
				ldx #S.TCB-1
				
.1				lda $ffff,x
				sta SKT.TCBCache,x
				dex
				bpl .1
				rts
*--------------------------------------
SKT.StoreTCB 	ldy #S.SOCKET.SQ.hTCB
				lda (ZPPtrSKT),y
				>SYSCALL GetMemPtr
				bcs *
				>STYA .2+1
				
				ldx #S.TCB-1
				
.1				lda SKT.TCBCache,x
.2				sta $ffff,x
				dex
				bpl .1
				rts
*--------------------------------------
SKT.Destroy		ldy #S.SOCKET.SQ.hOutMem
				lda (ZPPtrSKT),y
				beq .1
				>SYSCALL FreeMem
				
.1				ldy #S.SOCKET.SQ.hInMem
				lda (ZPPtrSKT),y
				beq .2
				>SYSCALL FreeMem
				
.2				ldy #S.SOCKET.SQ.hTCB
				lda (ZPPtrSKT),y
				beq .3
				>SYSCALL FreeMem				

.3				lda #0
				sta (ZPPtrSKT)
				clc
				rts
*--------------------------------------
SKT.SetFrameOutDstIP
				ldy #S.SOCKET.DST.ADDR
				ldx #4
				
.1				lda (ZPPtrSKT),y
				pha
				iny
				dex
				bne .1
				
				ldy #S.IP.DST+3
				ldx #4
				
.2				pla
				sta (ZPFrameOutPtr),y
				dey
				dex
				bne .2
				rts
*--------------------------------------
SKT.SetFrameOutTCPUDPPorts
				ldy #S.SOCKET.SRC.PORT
				lda (ZPPtrSKT),y
				tax
				iny
				lda (ZPPtrSKT),y
 				ldy #S.TCPUDP.SRCPORT
				sta (ZPFrameOutPtr),y
				iny
				txa
				sta (ZPFrameOutPtr),y
				
				ldy #S.SOCKET.DST.PORT
				lda (ZPPtrSKT),y
				tax
				iny
				lda (ZPPtrSKT),y
 				ldy #S.TCPUDP.DSTPORT
				sta (ZPFrameOutPtr),y
				iny
				txa
				sta (ZPFrameOutPtr),y

				rts
*--------------------------------------
SKT.CopyDataInToOut
				lda ZPDataInPtr+1
				pha
				lda ZPDataOutPtr+1
				pha
				
				lda ZPDataInLen
				eor #$ff
				tax
				lda ZPDataInLen+1
				eor #$ff
				pha

				ldy #0
				
.1				inx
				bne .2
				pla
				inc
				beq .9
				pha
				
.2				lda (ZPDataInPtr),y
				sta (ZPDataOutPtr),y
				iny
				bne .1
				inc ZPDataInPtr+1
				inc ZPDataOutPtr+1
				bne .1
				
.9				pla
				sta ZPDataOutPtr+1
				pla
				sta ZPDataInPtr+1
				rts
*--------------------------------------
MAN
SAVE /A2OSX.SRC/LIB/LIBTCPIP.S.SKT
LOAD /A2OSX.SRC/LIB/LIBTCPIP.S
ASM
