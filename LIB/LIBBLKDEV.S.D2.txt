NEW
  AUTO 3,1
				.LIST OFF	
*/--------------------------------------
*\--------------------------------------
D2MotorControl	>PULLB MotorOn
				>PULLB DrvSlt
				jsr CheckDiskII
				bcs .9
				
				lda MotorOn
				asl
				
				lda #0
				adc #IO.D2.DrvOff
				adc Slotn0
				tax
				lda $C000,x
				
*				clc
				
.9				
D2MotorControl.RTS
				rts				
*/--------------------------------------
*\--------------------------------------
D2MoveHead		>PULLB MoveTo
				>PULLB MoveFrom
				>PULLB DrvSlt
				jsr CheckDiskII
				bcs D2MotorControl.RTS

				ldy #0

.1			  	lda	MoveFrom
				cmp MoveTo
				beq	.3

				bcs	.2

				inc						MoveFrom<MoveTo, must move in

				.HS B0					BCS
				
.2				dec						MoveFrom>MoveTo, must move out

			    sta MoveFrom

				pha
				
				jsr D2.PhaseOn

				lda #85					8.5 ms
				jsr D2.Wait100msA		Trash X

				pla
				
				jsr D2.PhaseOff

				lda #1					0.1 ms
				jsr D2.Wait100msA		Trash X

				iny

				bra .1

.3				tya

				beq D2.AllPahseOff.8
				
				lda #0					wait 25.5 ms
				jsr D2.Wait100msA		Trash X
				clc
				rts
*--------------------------------------
D2.AllPhaseOff	ldx Slotn0
				bit IO.D2.Ph0Off,x
				bit IO.D2.Ph3Off,x
				bit IO.D2.Ph2Off,x
				bit IO.D2.Ph1Off,x
D2.AllPahseOff.8
				clc
				rts
*--------------------------------------
D2.PhaseOn		bit #1					1,3,5,7 ?
				beq .7					only half track
				
				bcc .1

				pha						CS : move out
				jsr .7
				pla
				inc
				bcs .7
				
.1				pha
				inc
				jsr .7
				pla
				
.7				and #6					mask for 0,2,4,6
				ora Slotn0				Slot $n0
				ora #IO.D2.Ph0On
				tax
				bit $C000,x				turn on one phase

				lda D2.PhaseOff.2+1
				sta D2.PhaseOff.1+1

				dex
				stx D2.PhaseOff.2+1
				rts
*--------------------------------------
D2.PhaseOff		bit #1					1,3,5,7 ?
				beq D2.PhaseOff.2		only half track

D2.PhaseOff.1	bit $c000
D2.PhaseOff.2	bit $c000
				rts
*--------------------------------------
D2.Wait100msA	sec

.1				ldx #19

.2  			dex
				bne .2

				sbc #1
				bne .1
				
				rts
*/--------------------------------------
*\--------------------------------------
D2TrkRead16s
*/--------------------------------------
* # D2TrkWrite16s
* Write a track (16 sectors)
* **In:**
*  PUSHB = DSSS0000
*  PUSHB = TrackNum * 4	: 0->136+	
*  PUSHW = Ptr to 16*256 buffer
* ## RETURN VALUE
*  CC : success
*  CS : A = Error
*       A=0, currently starting/seeking...
*\--------------------------------------
D2TrkWrite16s	>PULLW ZPPtr1
				>PULLB TrkNum
				>PULLB VolNum
				>PULLB DrvSlt

				jsr CheckDiskII
				bcs .9
				
				>LDYAI TRACK16.LEN+1
				>SYSCALL2 getmem
				bcs .9
	
				>STYA ZPPtr2
				stx hTrkBuf

				stz SectNum

				ldy #TRACK16.GAP1
				jsr PutSyncBytePtr2
				
.1				jsr PutAddrHeadPtr2
				
				jsr HeaderCheckSum
				
				ldy #3

.2				lda Checksum,y
				jsr PutByte44Ptr2
				dey
				bpl .2
	
				jsr PutTailPtr2
				
				ldy #TRACK16.GAP2
				jsr PutSyncBytePtr2
	
				jsr PutDataHeadPtr2
				
				jsr PutData
								
				jsr PutTailPtr2
				ldy #TRACK16.GAP3
				jsr PutSyncBytePtr2
				
				inc ZPPtr1+1
				
				inc SectNum
				lda SectNum
				cmp #16
				bne .1
				
				lda #0
				sta (ZPPtr2)
				
				jsr D2WriteTrackPtr2
				php
				pha
				lda hTrkBuf
				>SYSCALL2 FreeMem
				pla
				plp

.9				rts
*/--------------------------------------
*\--------------------------------------
D2TrkReadNIB
*/--------------------------------------
* # D2TrkWriteNIB
* Write a track (NIBBLE)
* **In:**
*  PUSHB = DSSS0000
*  PUSHW = Ptr to NIBBLE buffer (0 ended)
* ## RETURN VALUE
*  CC : success
*  CS : A = Error
*       A=0, currently starting/seeking...
*\--------------------------------------
D2TrkWriteNIB	>PULLW ZPPtr1
				>PULLB DrvSlt
				
				jsr CheckDiskII			was it a DISK II ?
				bcs .9

.9				rts
*--------------------------------------
* A=DSSS0000
*--------------------------------------
CheckDiskII		pha
				and #$70				only 0SSS
				sta Slotn0
				lsr
				lsr
				lsr
				lsr
				ora #$C0				make Cn
				sta ZPPtr3+1
				stz ZPPtr3
				
				ldx #3					4 bytes to check

.1				ldy DiskII.OFS,x

.2				lda (ZPPtr3),y
				cmp DiskII.SIG,x
				bne .9

				dex
				bpl .1
				
				pla						all bytes match, Disk II
				asl
				lda #0
				adc #IO.D2.DrvSel1
				adc Slotn0
				tax
				lda $C000,x
				
*				clc
				rts

.9				pla
				lda #MLI.E.NODEV
				sec
				rts
*--------------------------------------
* A=DSSS0000
*--------------------------------------
DrvSpinCheck	ldy #0

				lda IO.D2.RData,x
.1				cmp IO.D2.RData,x
				bne .8					spinning
				dey
				bne .1

				clc						CC:not spinning
				rts

.8				sec
				rts
*--------------------------------------
PutSyncBytePtr2	lda #$7f

.1				jsr PutBytePtr2
				dey
				bne .1
				rts
*--------------------------------------
PutAddrHeadPtr2	ldy #2

.1				lda ADDR.Head,y
				jsr PutBytePtr2
				dey
				bpl .1
				rts
*--------------------------------------
PutDataHeadPtr2	ldy #2

.1				lda DATA.Head,y
				jsr PutBytePtr2
				dey
				bpl .1
				rts
*--------------------------------------
PutTailPtr2		ldy #2

.1				lda TAIL,y
				jsr PutBytePtr2
				dey
				bpl .1
				rts
*--------------------------------------
HeaderCheckSum	lda VolNum
				eor TrkNum
				eor SectNum

				sta Checksum
				rts
*--------------------------------------
PutData			stz Checksum

				lda ZPPtr1
				ldy ZPPtr1+1

				clc
				adc #86
				bcc .1
				
				iny
				clc
				
.1				sta ZPPtr3
				sty ZPPtr3+1
				
				adc #86
				bcc .2
				
				iny
				
.2				sta ZPPtr4
				sty ZPPtr4+1
				
				ldy #85
				
.3				lda (ZPPtr1),y
				and #3
				tax
				lda D2.XX000000,x
				pha
				
				lda (ZPPtr3),y
				and #3
				tax
				pla
				ora D2.00XX0000,x
				pha
				
				lda (ZPPtr4),y
				and #3
				tax
				pla
				ora D2.0000XX00,x

				eor Checksum
				sta Checksum
				
				tax
				lda FC2Nib,x
				
				jsr PutBytePtr2
				dey
				bpl .3
				
				ldy #0
				
.4				lda (ZPPtr1),y
				and #$FC
				eor Checksum
				sta Checksum
				tax
				lda FC2Nib,x
				jsr PutBytePtr2
				
				iny
				bne .4
				
				ldx Checksum
				lda FC2Nib,x
				jsr PutBytePtr2
				
				rts
*--------------------------------------
PutByte44Ptr2	pha
				ror
				jsr .1

				pla
				
.1				ora #$AA
*--------------------------------------
PutBytePtr2		sta (ZPPtr2)
				inc ZPPtr2
				bne .8
				inc ZPPtr2+1
.8				rts				
*--------------------------------------
D2WriteTrackPtr2
				sei

				ldy #TrkWriter.Size
				
.1				lda TrkWriter-1,y
				sta $1ff,y
				dey
				bne .1
				
				lda hTrkBuf
				>SYSCALL2 GetMemPtr
				>STYA ZPPtr1
				ldx Slotn0

				jsr $200
				
				cli
				rts
*--------------------------------------
MAN
SAVE usr/src/lib/libblkdev.s.d2
LOAD usr/src/lib/libblkdev.s
ASM
