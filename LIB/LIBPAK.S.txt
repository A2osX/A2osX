NEW 
  AUTO 3,1
				.LIST OFF	
				.OP	65C02
				.OR	$2000
				.TF LIB/LIBPAK
*--------------------------------------
				.INB INC/MACROS.I
				.INB INC/A2OSX.I
				.INB INC/LIBPAK.I
*--------------------------------------
ZPSrcPtr		.EQ ZPLIB
ZPCnt			.EQ ZPLIB+2
ZPSrcBLPtr		.EQ ZPLIB+4
ZPBLCnt			.EQ ZPLIB+6
ZPCntTmp		.EQ ZPLIB+8

ZPDstPtr		.EQ ZPLIB+16
ZPStatPtr		.EQ ZPLIB+18
*--------------------------------------
*			File Header (16 Bytes)
*--------------------------------------
CS.START		cld
				jmp (.1,x)
				.DA #$61				6502,Level 1 (65c02)
				.DA #1					BIN Layout Version 1
				.DA 0
				.DA CS.END-CS.START
				.DA 0
				.DA 0
				.DA 0
*--------------------------------------
* Relocation Table
*--------------------------------------
.1				.DA LIB.LOAD
				.DA LIB.UNLOAD
				.DA Pak
L.MSG.Stats		.DA MSG.Stats
L.MSG.Top24		.DA MSG.Top24
				.DA 0
*--------------------------------------
LIB.LOAD
LIB.UNLOAD		clc
				rts
*/--------------------------------------
* # Pak
* ##ASM 
* `>PUSHW StatPtr`
* `>PUSHW DstPtr`
* `>PUSHW SrcLen`
* `>PUSHW SrcPtr`
* `>LIBCALL hLIBPAK,Pak`
* ## RETURN VALUE 
* CC, Y,A = CLEN
* CS, Pak failure
*\--------------------------------------
Pak				>PULLW Pak.SrcPtr
				>PULLW Pak.SrcLen
				>PULLW ZPDstPtr
				>PULLW ZPStatPtr

* Reset Byte counters

				ldx #0

.1				stz	Pak.CntL,x
				stz Pak.CntH,x
				inx
				bne .1

* Select best BL.BitCnt

				ldx #8
				ldy #0
				
				lda Pak.SrcLen+1
				beq .22
					
				ldy #8
					
.2				asl
				bcs .4
				dey
				bra .2
				
.22				lda Pak.SrcLen

.3				asl
				bcs .4
				dex
				bra .3

.4				stx Pak.BL.BitCntL
				sty Pak.BL.BitCntH

* PASS #1 : no store, update byte counters

				stz Pak.bPass2
								
				jsr Pak.InitPass

				jsr Pak.Run
				bcs .9

				jsr Pak.BuildTOPTable

				jsr Pak.PrintStats
				
* PASS #2 : store with TOP bytes

				dec Pak.bPass2
				
				jsr Pak.InitPass

				jsr Pak.Out.Init		Initialize properly for first "PutBit" Call

				stz Pak.StringLen
				
				jsr Pak.Run
				bcs .9
				jsr Pak.PrintStats
				
				ldy #S.PAKSHNK-1
				
.6				lda Pak.Shnk,y
				
				dey
				bpl .6
				
				ldy #S.PAKSTAT-1
				
.7				lda Pak.Stat,y
				sta (ZPStatPtr),y
				dey
				bpl .7
				
				clc

.9				rts		
*--------------------------------------
Pak.InitPass	>LDYA Pak.SrcPtr
				>STYA ZPSrcPtr
				
				lda Pak.SrcLen
				eor #$ff
				sta Pak.SrcCnt
				
				lda Pak.SrcLen+1
				eor #$ff
				sta Pak.SrcCnt+1
				
				sec
				ror Pak.RepCnt
				stz Pak.LastByte
				
				ldx #S.PAKSTAT.PASS1
				bit Pak.bPass2
				bpl .1
				
				inx
				inx
				
.1				stz Pak.Stat,x			Reset Stats
				inx
				cpx #S.PAKSTAT
				bne .1
				
				rts
*--------------------------------------
Pak.Run			

Pak.Run.1		inc Pak.SrcCnt
				bne .1
				
				inc Pak.SrcCnt+1
				beq .8					0 byte left...
				
.1				jsr Pak.ScanBL
				bcs .4
				
				bit Pak.bPass2
				bpl .11
				
				ldx #S.PAKSTAT.PASS1
				jsr Pak.UpdateStats
				jsr Pak.UpdateStats
				jsr Pak.UpdateStats
				
				bra .3
				
.11				sec
				lda Pak.Out.PutBitC
				
				ldy Pak.BL.BitCntH
				beq .2
				
				lda Pak.BestBL+1
				jsr Pak.Out.PutYBits
				
.2				ldy Pak.BL.BitCntL
				lda Pak.BestBL
				jsr Pak.Out.PutYBits
				
				ldy #6
				lda Pak.BestBLLen
				jsr Pak.Out.PutYBits
				
				lda Pak.BestBLLen
				clc
				adc ZPSrcPtr
				sta ZPSrcPtr
				bcc .3
				inc ZPSrcPtr+1
				
.3				ldx #S.PAKSTAT.BL
				jsr Pak.UpdateStats
				
				lda Pak.BestBLLen
				clc
				adc Pak.SrcCnt
				sta Pak.SrcCnt
				bcc .1
				inc Pak.SrcCnt+1
				bmi .1
			
.8				clc				
.9				rts
				
.4				lda (ZPSrcPtr)
				jsr Pak.PutA
				
				inc ZPSrcPtr
				bne Pak.Run.1
				inc ZPSrcPtr+1
				bra Pak.Run.1
*--------------------------------------
Pak.ScanBL		>LDYA Pak.SrcPtr
				>LDYA ZPSrcBLPtr
				
				sec
				ror Pak.bBLFound
				
.1				sec
				lda ZPSrcBLPtr
				sbc ZPSrcPtr
				sta ZPBLCnt
				
				lda ZPSrcBLPtr+1
				sbc ZPSrcPtr+1
				sta ZPBLCnt+1			ZPSrcBLPtr < !BlCnt < ZPSrcPtr 
				bcs .8					ZPSrcBLPtr = ZPSrcPtr, exit
				
				>LDYA ZPCnt
				>STYA ZPCntTmp			Stop at end of Src Data
				
				ldy #0					...or Y = BL.MAX

.2				inc ZPBLCnt
				bne .3
				
				inc ZPBLCnt+1
				beq .4					ZPSrcBLPtr = ZPSrcPtr	
				
.3				lda (ZPSrcPtr),y
				cmp (ZPSrcBLPtr),y
				bne .4					End of string matching
				
				iny
				cpy #BL.MAX
				beq .4					Max BL len
				
				inc ZPCntTmp
				bne .2
				inc ZPCntTmp+1
				bne .2					Last Src Data
				
.4				dey						Adjust BL len Range
				dey						(0 = 3 matching chars...etc..)
				
				bmi .5					not long enough
				
				cpy Pak.BestBLLen
				bcs .5					not better ...
				
				sty Pak.BestBLLen
				>LDYA ZPBLCnt
				>STYA Pak.BestBL

				stz Pak.bBLFound
	
.5				inc ZPSrcBLPtr
				bne .1
				inc ZPSrcBLPtr+1
				bra .1
				
.8				rol Pak.bBLFound

				rts
*--------------------------------------
Pak.BuildTOPTable
				ldy #0

.1				stz Pak.Cnt				Init best score to 0
				stz Pak.Cnt+1
				
				sec
				ror Pak.bStop
				
				ldx #0
				
.2				lda Pak.CntL,x
				ora Pak.CntH,x
				beq .3

				stz Pak.bStop

				lda Pak.Cnt
				cmp Pak.CntL,x			is it better at X
				lda Pak.Cnt+1
				sbc Pak.CntH,x
				bcs .3					not better or equal...
				
				stx Pak.In.Byte			save new score index...
				
				lda Pak.CntL,x
				sta Pak.Cnt				...and value
				lda Pak.CntH,x
				sta Pak.Cnt+1
				
.3				inx
				bne .2
				
				bit Pak.bStop
				bmi .8
				
				lda Pak.In.Byte
				sta Pak.Shnk+S.PAKSHNK.TOPBYTES,y
				tax
				stz Pak.CntL,x			Discard this entry
				stz Pak.CntH,x
				iny
				cpy #24
				bne .1
				
.8				sty Pak.Shnk+S.PAKSHNK.TOPCNT
				
				rts
*--------------------------------------
Pak.PutA		bit Pak.bPass2
				bmi Pak.PutA.2
				
				tax
				inc Pak.CntL,x
				bne .1

				inc Pak.CntH,x				

.1				ldx #S.PAKSTAT.PASS1
				jsr Pak.UpdateStats
				ldx #S.PAKSTAT.BYTE8
				jsr Pak.UpdateStats
				
				clc
				rts

Pak.PutA.2		bit Pak.RepCnt
				bpl .1

				stz Pak.RepCnt			LastByte invalid...		
				sta Pak.LastByte
				bra Pak.PutA.1			send first byte.
				
.1				cmp Pak.LastByte
				beq .3
				
				sta Pak.LastByte		save new byte
				lda Pak.RepCnt			do we have a pending REP ?
				beq .2
				
				ora #PAK.B.REPn			yes, send it
				jsr  Pak.PutA.1
				bcs .9

				ldx #S.PAKSTAT.REPN
				jsr Pak.UpdateStats
				stz Pak.RepCnt
				
.2				lda Pak.LastByte
				bra Pak.PutA.1
				
.3				inc Pak.RepCnt
				lda Pak.RepCnt
				cmp #REP.MAX
				bne .8

				dec
				ora #PAK.B.REPn
				jsr Pak.PutA.1
				bcs .9
				
				lda #1
				sta Pak.RepCnt
				
				ldx #S.PAKSTAT.REPN
				jsr Pak.UpdateStats
				
.8				clc
.9				rts
									
Pak.PutA.1		bit Pak.bPass2
				bmi .10
				
				tax
				inc Pak.CntL,x
				bne .11
				inc Pak.CntH,x
				
.11				inc Pak.Stat+S.PAKSTAT.PASS1
				bne .12
				inc Pak.Stat+S.PAKSTAT.PASS1+1
.12				clc
				rts
				
* Pak.PutA.1  PASS #2
				
.10				ldy #S.PAKSHNK.TOPCNT

.1				cmp Pak.Shnk+S.PAKSHNK.TOPBYTES-1,y
				beq .3
				dey
				bpl .1

				ldx #S.PAKSTAT.BYTE8
				jsr Pak.UpdateStats

				clc
				jmp Pak.Out.PutCA
				
.3				tya						Range 0-23
				lsr
				lsr
				lsr
				tax
				tya
				and #7
				ora TOP.Bits,x
				ldy TOP.BitCnt,x
				pha
				lda TOP.Stat,x
				tax
				pla

				jsr Pak.UpdateStats
				jmp Pak.Out.PutYBits
*--------------------------------------
Pak.Flush		ldx Pak.StringLen 
				beq .8
				
				lda #PAK.B.STRING
				ldy #4
				jsr Pak.Out.PutYBits
				bcs .9
				
				ldx #0
				
.1				lda Pak.StringBuf,x
				sta Pak.LastByte		update last byte for REP
				ldy #8
				jsr Pak.Out.PutYBits
				bcs .9
				
				inc Pak.Stat+S.PAKSTAT.BYTE8
				bne .2
				inc Pak.Stat+S.PAKSTAT.BYTE8+1
				
.2				inx
				dec Pak.StringLen
				bne .1

				stz Pak.RepCnt			Don't forget to set last byte valid
				
.8				clc				
.9				rts
*--------------------------------------
Pak.UpdateStats	inc Pak.Stat,x
				bne .8
				inc Pak.Stat+1,x
.8				rts
*--------------------------------------
Pak.PrintStats	ldx #14

.1				>PUSHW Pak.Stat,x
				dex
				dex
				bpl .1
				
				>PUSHBI 16
				>LDYA L.MSG.Stats
				>SYSCALL printf
				
				ldx #24
				
.2				>PUSHB Pak.Shnk+S.PAKSHNK.TOPCNT,x
				dex
				bpl .2
				
				>PUSHBI 25
				>LDYA L.MSG.Top24
				>SYSCALL printf
			>DEBUG
				rts
*--------------------------------------
*				.INB USR/SRC/LIB/LIBPAK.S.IN
				.INB USR/SRC/LIB/LIBPAK.S.OUT
*--------------------------------------
CS.END
*--------------------------------------
MSG.Stats		.AS "\r\nPass 1 : %5D\r\n"
				.AS "Pass 2 : %5D\r\n"
				.AS "Byte 8 : %5D\r\n"
				.AS "Top  8 : %5D\r\n"
				.AS "Top 16 : %5D\r\n"
				.AS "Top 24 : %5D\r\n"
				.AS "Rep  N : %5D\r\n"
				.AZ "BLNK   : %5D\r\n"
MSG.Top24		.AZ "Top24 : %d\r\n%h%h%h%h%h%h%h%h%h%h%h%h%h%h%h%h%h%h%h%h%h%h%h%h\r\n"
TOP.Bits		.DA #%10000,#%110000,#%1110000
TOP.BitCnt		.DA #5,#6,#7
TOP.Stat		.DA #S.PAKSTAT.TOP8,S.PAKSTAT.TOP16,S.PAKSTAT.TOP24
*--------------------------------------
Pak.SrcPtr		.BS 2
Pak.SrcLen		.BS 2

Pak.SrcCnt		.BS 2
Pak.DstCnt		.BS 2

Pak.RepCnt		.BS 1
Pak.LastByte	.BS 1

Pak.BL.BitCntL	.BS 1
Pak.BL.BitCntH	.BS 1

Pak.bBLFound	.BS 1
Pak.BestBLLen	.BS 1
Pak.BestBL		.BS 2

Pak.StringLen	.BS 1
Pak.StringBuf	.BS STRING.MAX

Pak.Cnt			.BS 2
Pak.bStop		.BS 1

Pak.bPass2		.BS 1
Pak.MaxReadAhead	.BS 1

Pak.WPtr		.BS 2
Pak.WLimit		.BS 2
Pak.WStrLen		.BS 1

Pak.In.Byte		.BS 1
Pak.In.Mask		.BS 1

Pak.Out.Byte	.BS 1
Pak.Out.Mask	.BS 1
*--------------------------------------
Pak.CntL		.BS 256
Pak.CntH		.BS 256
Pak.Shnk		.BS S.PAKSHNK
Pak.Stat		.BS S.PAKSTAT
*--------------------------------------
Pak.In.BitMask	.HS 8040201008040201
MAN
SAVE USR/SRC/LIB/LIBPAK.S
ASM
