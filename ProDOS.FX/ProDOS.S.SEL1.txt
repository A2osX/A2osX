NEW
  AUTO 3,1
*--------------------------------------
VolListPtr		.EQ	$65
*
SelectedIndex	.EQ	$67					name counter
filecount 		.EQ	$68					# of displayable files in directory
FilenameLen		.EQ	$69					length of filename

bInSubDir		.EQ	$6B					directory level
FilenamePtr		.EQ	$6C					filename storage pointer (16 bit)
*
DirEntLen		.EQ	$6E					directory entry length
DirEntPerBlk	.EQ	$6F					directory entries/block
FileCntInDir	.EQ	$70					directory file count (16 bit)
*
blkfl			.EQ	$72					block flag / file counter
ScrollIndex		.EQ	$73					index # of top name in display
*--------------------------------------
SEL1.FileBuf	.EQ	$1800				1k
SEL1.DirEntry	.EQ	$1C00				512b
SEL1.filetypes	.EQ	$1F00
SEL1.Filenames	.EQ $2000
*--------------------------------------
SEL1.START		cld
				bit RROMBNK2			read ROM

* Already done before jmp $1000
*				stz softev
*				lda #$10				set reset vector to 'dispadr'
*				sta softev+1
*				jsr setpwrc				create power-up byte

				lda #$A0
				jsr $C300			 	initialize 80 column text card

* set up memory bitmap in global page

				ldx #0
				jsr GP.TOOLBOX			reset MEMTABL

				lda #$02
				sta SEL1.SetMarkP		init set mark parms pcount.
*--------------------------------------
				ldx DEVCNT
				
.1				lda DEVLST,x
				and #$F0
				cmp DEVNUM
				beq SEL1.GetVol
				
				dex
				bra .1
*--------------------------------------
SEL1.NextVol	ldx VolListPtr			get device list pointer.
				bne .1

				ldx DEVCNT				get device count.
				inx
				
.1				dex
				lda DEVLST,x			get unit number from list.
*--------------------------------------
SEL1.GetVol		stx VolListPtr
				sta SEL1.OnLineP+1		store unit number for online.
				jsr MLI
				.DA #MLIONLINE
				.DA SEL1.OnLineP
				bcs SEL1.NextVol	  	error check.

				stz bInSubDir		 	haven't read root directory yet.
				lda pbuf+1				load description byte.
				and #$0F			 	mask for name length.
				beq SEL1.NextVol	  	if 0, then try next unit.

*				clc

				adc #$02			 	add 2 to length.
				tax		 				name length in x.

SEL1.OpenDir	stx pbuf				save the name length
				lda #'/'
				sta pbuf+1			 	slash before and
				sta pbuf,x			 	after name.
				stz pbuf+1,x			now "/VOLNAME/0

				jsr MLI
			   .DA #MLIOPEN
			   .DA SEL1.OpenP
				bcc SEL1.EnumDir		good open.

				lda bInSubDir		 	trying to open root directory ?
				beq SEL1.NextVol	  	yes, just move to next volume.

				jsr bell1			  	no, generate bell tone
				jsr SEL1.FullPath..		and stay at same level.
				stx pbuf
				jmp keyloop
*--------------------------------------
SEL1.EnumDir	stz filecount			zero file count.

				lda #1					File Ref Num=1
				sta SEL1.ReadP+1		store in read
				sta SEL1.SetMarkP+1		and setmark parm lists.
				
				stz SEL1.ReadP+2
				lda /SEL1.DirEntry
				sta SEL1.ReadP+3
				
				lda #$2B			 	set read parm list for
				sta SEL1.ReadP+4		directory header length.
				stz SEL1.ReadP+5

				jsr SEL1.ReadEntry		read directory
				bcs SEL1.CloseDir1

				ldx #$03

.1  			lda SEL1.DirEntry+$23,x	copy directory info
				sta DirEntLen,x			to zero page.
				dex
				bpl .1

				sta SEL1.ReadP+4		put entry length in read parm list.
				lda #$01			 	set block file counter to 1.
				sta blkfl
				stz SEL1.SetMarkP+3		zero out msb's of file position
				stz SEL1.SetMarkP+4		in setmark parm list.

SEL1.EnumDirNext
				lda FileCntInDir
				ora FileCntInDir+1
				beq SEL1.CloseDir

SEL1.EnumDirNext1

.1  			lda #$01			 	reset lsb
				trb SEL1.SetMarkP+3
				ldy blkfl			  	block file counter
				lda #$00
				cpy DirEntPerBlk	 	have we read all entries in this block ?
				bcc .3					if not, continue.

				tay		 				if so, zero y-reg and
				sty blkfl			  	reset block counter / flag
				inc SEL1.SetMarkP+3

.2  			inc SEL1.SetMarkP+3

.3  			dey						decrement file block counter
				clc
				bmi .4

				adc DirEntLen		 	add entry length to acc.
				bcc .3				  	determine if we flopped into 2nd half of
				bcs .2					block, if so inc mid byte position.

.4  			adc #$04				add 4 and put in
				sta SEL1.SetMarkP+2		low byte of setmark.
				jsr MLI					call mli
				.DA #MLISETMARK
				.DA SEL1.SetMarkP
				bcs SEL1.CloseDir

				jsr SEL1.ReadEntry
SEL1.CloseDir1	bcs SEL1.CloseDir

				inc blkfl			  	increase count of files read.
				lda SEL1.DirEntry		file type/length.
				and #$F0			 	mask off high nibble.
				beq SEL1.EnumDirNext1

				lda FileCntInDir
				bne .5

				dec FileCntInDir+1

.5				dec FileCntInDir

				ror SEL1.DirEntry+$1E	check access bit.
				bcc SEL1.EnumDirNext  	if no read, try next file.

				lda SEL1.DirEntry+$10	get file type.
				ldx filecount			get valid files read.
				inx
				beq SEL1.CloseDir

				stx filecount

				dex

				sta SEL1.filetypes,x	else store filetype in zero page
				jsr SEL1.SetFNPtrX		and go set up storage area.

				ldy #15

.6  			lda SEL1.DirEntry,y		get byte of filename
				sta (FilenamePtr),y		store in directed area
				dey
				bpl .6

				and #$0F			 	mask off low nibble (name length)
				sta (FilenamePtr)		restore in name buffer
				bra SEL1.EnumDirNext

L5E26  			jmp SEL1.NextVol  		error. try next unit.
*--------------------------------------
SEL1.CloseDir	jsr MLI					close directory file
			   .DA #MLICLOSE
			   .DA SEL1.CloseP
				bcs L5E26				error.

				jsr settxt			 	use full screen for windows
				jsr home

				lda #$17			 	cursor at bottom of screen.
				jsr TABV				set vertical position.
				
				lda #$14			 	horizontal position.
				sta ch

				ldy #0					Footer
				jsr SET1.MsgOutY
				lda #$99
				jsr cout				cursor to upper/left.

				ldx #$00

.1  			lda pbuf+1,x
				beq .2

				jsr SEL1.COut
				inx
				bne .1

.2		 		stz	SelectedIndex
				stz ScrollIndex			init top filename index.
				ldx filecount			# of valid files.
				beq keyloop			  	if no files.

				cpx #21				 	more than what will fit on screen ?
				bcc .3				  	no.

				ldx #20				 	limit to 20 files on the screen.

.3  			lda #2					set window dimensions
				sta wndtop
				sta wndlft

				lda #22
				sta wndwdth
				sta wndbot

.4  			phx
				
				jsr SEL1.PrintFN
				inc SelectedIndex
				
				plx
				dex
				bne .4

				stz SelectedIndex
				beq L5EAA			  	if last file, it needs to be inverse.
*--------------------------------------
uparrow			jsr	SEL1.PrintFN		print old name in normal.
				ldx SelectedIndex
				beq L5EAA			 	if already at the top name

				dec SelectedIndex
				lda cv			   		current cursor line.
				cmp #$02			 	at top line of window ?
				bne L5EAA			  	no, move up normally.

				dec ScrollIndex			fix offset index
				lda #$16			 	else sroll windows down a line.
				bne L5EA7			  	branch always.
*--------------------------------------
dnarrow			jsr	SEL1.PrintFN		print old name in normal.
				ldx SelectedIndex
				inx		 				add one.
				cpx filecount
				bcs L5EAA			  	if already at last filename

				stx SelectedIndex
				lda cv			   		current cursor line.
				cmp #$15			 	at bottom line of window ?
				bne L5EAA			  	no, move cursor normally.

				inc ScrollIndex			update offset index
				lda #$17			 	else scroll up a line.

L5EA7  			jsr cout

L5EAA  			jsr setinv			 	set inverse text mode.
				jsr SEL1.PrintFN		output last filename.
*--------------------------------------
keyloop			lda kbd			  		get keyboard input.
				bpl keyloop			  	loop until key pressed.

				sta KBDSTROBE			clear strobe.
				jsr setnorm				set normal text mode.
				ldx filecount			are any files displayed ?
				beq L5ECB			  	no, don't accept arrow keys or return.

				cmp #$8D			 	return ?
				beq L5EF4			  	then run selected file.

				cmp #$8A			 	down ?
				beq dnarrow				move down a name.

				cmp #$8B			 	up ?
				beq uparrow				move up a name.

L5ECB  			cmp #$89			 	tab ?
				beq L5EED			  	new volume.

				cmp #$9B			 	esc ?
				bne keyloop			  	no, try again else pop up a directory.

				jsr SEL1.FullPath..		CD ..
				jmp SEL1.OpenDir
*--------------------------------------
L5EED  			jmp SEL1.NextVol		set up new unit number.
*--------------------------------------
L5EF4  			ldy SelectedIndex
				lda	SEL1.filetypes,y	get file type.
				cmp #S.FI.T.DIR
				bne .1				  	branch if directory.

				jsr SEL1.SetFullPath
				bcs L5EED
				
				inx

				jmp SEL1.OpenDir	  	get new directory info.

.1				cmp #S.FI.T.SYS
				bne keyloop

				jsr SEL1.SetFullPath
				bcs L5EED

				jsr MLI					open file
			   .DA #MLIOPEN
			   .DA SEL1.OpenP
				bcs L5EED

				lda SEL1.OpenP+5		move reference number
				sta SEL1.ReadP+1		for read.

				lda #$20
				sta SEL1.ReadP+3		read at $2000

				dec SEL1.ReadP+5		was $002B, now $FF2B

				jsr SEL1.Read		 	read selected file.
				php		 				save possible error.
				jsr MLI					close file. ignore any error from close
			   .DA #MLICLOSE
			   .DA SEL1.CloseP
				plp		 				restore status from read.
				bcs L5EED			  	if any errors.

				jsr settxt			 	reset to full window.
				jsr home			 	makes for no flash.
				lda #$95			 	ctrl-u
				jsr cout			 	turn off 80 columns.

				jmp $2000				execute selected system file.
*--------------------------------------
SET1.MsgOutY	lda SEL1.Footer,y
				beq .8

				jsr cout
				iny
				bne SET1.MsgOutY

.8  			rts
*--------------------------------------
SEL1.PrintFN	ldx SelectedIndex
				txa
				sec
				sbc ScrollIndex			calculate line # to display name
				inc
				inc
				jsr TABV				set vertical position.

				lda SEL1.filetypes,x	get filetype (x is unchanged by tabv).
				cmp #S.FI.T.DIR
				bne .1				  	branch if not a DIR

				stz ch80col				adjust cursor position.
				lda invflg				Save current inverse setting
				pha
				ldy #SEL1.DirIcon-SEL1.Footer
				jsr SET1.MsgOutY	 	display the folder.
				pla		 				restore inverse setting.
				sta invflg

.1  			lda #$03
				sta ch80col
				
				jsr SEL1.SPOut			output a space.
				jsr SEL1.SetFNPtrX		calc name location.

				ldy #0

.2  			iny
				lda (FilenamePtr),y		get name character.
				jsr SEL1.COut		 	put on screen.
				cpy FilenameLen			end of name ?
				bcc .2				  	no.

SEL1.SPOut		lda #' '				SPACE

SEL1.COut		ora #$80			 	set high bit.
				jmp cout			 	output to screen.

SEL1.ReadEntry	jsr SEL1.Read
				bcs SEL1.Read.RTS

				ldy #SEL1.DirEntry
				lda /SEL1.DirEntry
				ldx #2
				jmp GP.TOOLBOX
*--------------------------------------
SEL1.Read		jsr MLI					mli read call
			   .DA #MLIREAD
			   .DA SEL1.ReadP
SEL1.Read.RTS	rts
*--------------------------------------
SEL1.SetFullPath
				jsr MLI
			   .DA #MLISETPREFIX
			   .DA SEL1.SetPrefixP
				bcs .9

				ldx SelectedIndex
				jsr SEL1.SetFNPtrX		set up name storage area (on return y=0)

				ldx pbuf			 	get prefix length.
				ldy #0

.1  			iny		 				start at y = 1.
				lda (FilenamePtr),y		get character of name.
				inx
				sta pbuf,x			 	store in prefix buffer.
				cpy FilenameLen			check length of name.
				bcc .1				  	loop until all transferred.

				stx pbuf			 	put prefix length into buffer.

				inc bInSubDir
				
				clc

.9				rts
*--------------------------------------
SEL1.FullPath..	ldx pbuf

.1  			dex
				lda pbuf,x
				cmp #'/'
				bne .1

				cpx #$01
				bne .9

				ldx pbuf

.9  			dec bInSubDir

				rts
*--------------------------------------
SEL1.SetFNPtrX	lda /SEL1.Filenames/16
				sta FilenamePtr+1
				txa
				
				ldx #4

.1				asl
				rol FilenamePtr+1
				dex
				bne .1
				
				sta FilenamePtr
				
				lda (FilenamePtr)
				sta FilenameLen
				rts
*--------------------------------------
* data area
*--------------------------------------
SEL1.Footer		.AS -"RETURN:Select,TAB:Chg Vol,ESC:Back"
				.HS 00

SEL1.DirIcon	.HS 0F					inverse control code
				.HS 1B			 		enable mousetext
				.AS -"XY"				folder characters
				.HS 18			  		disable mousetext
				.HS 0E			  		normal control code
				.HS 00
*--------------------------------------
SEL1.OpenP		.DA #3				  	Param Count
				.DA pbuf				pathname
				.DA SEL1.FileBuf		file buffer
				.HS 01					reference number
*--------------------------------------
SEL1.CloseP		.DA #1			  		Param Count
				.HS 01					reference number.
*--------------------------------------
SEL1.OnLineP	.DA #2					Param Count
				.HS 60					unit number, default = s6, d1
				.DA pbuf+1				data buffer
*--------------------------------------
SEL1.SetPrefixP	.DA #1		  			Param Count
				.DA pbuf				pathname
*--------------------------------------
SEL1.ReadP 		.DA #4			  		Param Count
*--------------------------------------
				.LIST ON
SEL1.LEN		.EQ *-SEL1.START
				.LIST OFF
*--------------------------------------
				.DUMMY
				.BS 1					RefNum
				.BS 2					MemPtr
				.BS 2					requested length
				.BS 2					actual length

SEL1.SetMarkP 	.BS 1					Param Count
				.BS 1					RefNum
				.BS 3					FPos
				.ED
*--------------------------------------
MAN
SAVE usr/src/prodos.fx/prodos.s.sel1
LOAD usr/src/prodos.fx/prodos.s
ASM
