NEW
  AUTO 3,1
H2000			jmp prostart
				jmp atalkset
				jmp p16start
				
LDR.MSG.0		.AS	-"PRODOS FX:                              "
LDR.MSG.0.LEN	.EQ *-LDR.MSG.0

p16start 		inc setuprts			set = 2 for GQuit rts
atalkset 		inc setuprts			set = 1 for appletalk rts
prostart 		lda unitnum
				sta LDR.MLIOL.P+1

				cld
				bit RROMBNK2

				sta CLR80DISP
				sta	CLR80STORE
				jsr setnorm
				jsr init
				jsr setvid
				jsr setkbd
				jsr home

				ldx #LDR.MSG.0.LEN-1
.1		 		lda LDR.MSG.0,x
				sta $400,x
				dex
				bpl .1

				sec
				jsr idroutine   		returns system info
				bcs .2					taken if not a //gs

				lda #$80
				trb newvideo			video mode select

* test for at least a 65c02

.2				sed
				lda #$99
				clc
				adc #$01
				cld
				bmi LDR.UNSUPP.HW

LDR.CheckROM	lda #MACHID.T.IIe
				
				ldx $FBB3	  			check hardware id
				cpx #$06	   			apple //e?
				beq .1					if yes

				cpx #$EA	   			apple //+ or ///?
				beq LDR.UNSUPP.HW

				bra m64k				machine is unknown, Assume //e Enh 64k

.1  			ldx $FBC0				//c ?
				bne .2
				
				inc cflag				//c or later
				lda #MACHID.T.IIc+MACHID.M.128+MACHID.COL80
				sta idapple				save machine id
				bra m128k
				
.2				cpx #$EA
				beq LDR.UNSUPP.HW		//e UNenh....
				
				cpx #$E0
				bne m64k				not a //e Enh....

				sec
				jsr $FE1F				//gs ????
				bcs m64k
				
				inc cortland
				lda #MACHID.T.IIe+MACHID.M.128+MACHID.COL80+MACHID.CLK
				sta idapple
				bra m128k

m64k			sta idapple				save machine id
				
				ldx #LDR.Test128.len-1
	
.5				lda LDR.Test128,x
				sta $80,x
				dex
				bpl .5

				jsr $80					Test For 128k
				bcs LDR.UNSUPP.HW
				
				lda #MACHID.M.128+MACHID.COL80
				tsb idapple
				
				bra m128k

LDR.UNSUPP.HW  	jmp H22EB				need enhanced IIe

* we have 128k

m128k  			lda #$30				set id = 128k present
				tsb idapple

				ldx #$FF
				php						save interrupt status
				pla		  				in acc.
				sei		  				no interrupts.
				sta SETALTZP
				stx auxsp				init aux sp to $FF
				sta CLRALTZP
				pha		  				restore interrupt status
				plp
				sta CLRC3ROM

				ldx #$F
				
.2				lda LDR.3F0,x
				sta $3F0,x
				dex
				bpl .2
				
				lda #$01				patch for the gs rom
				trb statereg			to force off intcxrom

				lda PAKME.ILDR
				sta ZPInBufPtr
				lda PAKME.ILDR+1
				sta ZPInBufPtr+1
				lda #ILDR.START
				sta ZPOutBufPtr
				lda /ILDR.START
				sta ZPOutBufPtr+1
				jsr X.Unpak
	
				lda PAKME.GP
				sta ZPInBufPtr
				lda PAKME.GP+1
				sta ZPInBufPtr+1
				lda #MLI
				sta ZPOutBufPtr
				lda /MLI
				sta ZPOutBufPtr+1
				jsr X.Unpak

				lda PAKME.XRW
				sta ZPInBufPtr
				lda PAKME.XRW+1
				sta ZPInBufPtr+1
				lda #$D000
				sta ZPOutBufPtr
				lda /$D000
				sta ZPOutBufPtr+1
				jsr X.Unpak

				ldx #0
				
.1				stz $D700,x
				stz $D800,x
				stz $D900,x
				stz $DA00,x
				stz $DB00,x
				stz $DC00,x
				stz $DD00,x
				inx
				bne .1
				
				lda PAKME.XDOS
				sta ZPInBufPtr
				lda PAKME.XDOS+1
				sta ZPInBufPtr+1
				lda #$DE00
				sta ZPOutBufPtr
				lda /$DE00
				sta ZPOutBufPtr+1
				jsr X.Unpak

				lda PAKME.IRQ
				sta ZPInBufPtr
				lda PAKME.IRQ+1
				sta ZPInBufPtr+1
				lda #$FF9B
				sta ZPOutBufPtr
				lda /$FF9B
				sta ZPOutBufPtr+1
				jsr X.Unpak

				lda kversion
				sta xdosver				save current version for dir use

				lda cortland
				beq LDR.II				branch if // family
				
LDR.IIGS		inc cortland	   		it's a Cortland, set loader flag
				stz vmode				force setvid to reset cursor
				jsr setvid	   			reset output to screen

				ldx PAKME.SEL2
				ldy PAKME.SEL2+1

				stx ZPInBufPtr
				sty ZPInBufPtr+1
				lda #$1000
				sta ZPOutBufPtr
				lda /$1000
				sta ZPOutBufPtr+1
				jsr X.Unpak

				ldx PAKME.SEL2
				ldy PAKME.SEL2+1

				stx ZPInBufPtr
				sty ZPInBufPtr+1
				lda #$D100
				sta ZPOutBufPtr
				lda /$D100
				sta ZPOutBufPtr+1
				jsr X.Unpak

				lda PAKME.CCLK
				sta ZPInBufPtr
				lda PAKME.CCLK+1
				sta ZPInBufPtr+1
				lda #$D742
				sta ZPOutBufPtr
				lda /$D742
				sta ZPOutBufPtr+1
				jsr X.Unpak

				lda setuprts
				bne .1					branch if prodos 8 alone

* running from gs/os shell so zero out os_boot for appletalk

				sta OS_BOOT	   			indicates O/S initially booted.
				jsr patch101	   		patch for gs/os - rev note #101

.1				jmp RAMDRV.Install
* put dispatcher in bank 2 of language card

LDR.II			lda LDR.MLIOL.P+1		place boot devnum in globals
				sta LDR.MLIRB.P+1
				sta devnum	   			last device used

				jsr devsrch				finish setting up globals

				lda LDR.MLIRB.P+1
				sta devnum

				jsr lc1in				switch in language card bank 1.

				lda PAKME.TCLK
				sta ZPInBufPtr
				lda PAKME.TCLK+1
				sta ZPInBufPtr+1
				lda #$D742
				sta ZPOutBufPtr
				lda /$D742
				sta ZPOutBufPtr+1
				jsr X.Unpak

				lda #calldisp
				sta jspare+1			P8 system death vector
				lda /calldisp
				sta jspare+2

				lda RRAMWRAMBNK2		read/write RAM bank 2
				lda RRAMWRAMBNK2

				ldx PAKME.SEL1			else, use Bird's Better Bye
				ldy PAKME.SEL1+1	  		if correct machine.

	 			stx ZPInBufPtr
				sty ZPInBufPtr+1
				lda #$D100
				sta ZPOutBufPtr
				lda /$D100
				sta ZPOutBufPtr+1
				jsr X.Unpak

				lda #$EE				byte to distinguish LC bank 2
				sta $D000
				jsr lc1in				switch in LC bank 1

RAMDRV.Install	ldy #$99				move $9A bytesfrom lcsrc to lcdest.

.1	  			lda	RAM,y				transfer main bank portion of driver
				sta RAMDRV,y
				dey
				cpy #$FF
				bne	.1

				ldx	#RAMX				set up to move aux portion of driver
				stx	A1L
				dex
				stx	A2L
				ldx	/RAMX
				stx A1L+1
				inx
				stx A2L+1
				lda #RAMXDRV
				sta	A4L
				lda	/RAMXDRV			RAMX to RAMXDRV
				sta	A4L+1
				sec			 			irection = to aux bank.
				jsr auxmove				move aux bank portion of driver.
				lda #RAMDRV				put driver address into
				sta	drivertbl2+6		slot 3, drive 2.
				lda /RAMDRV
				sta	drivertbl2+7
				inc numdevs				count (-1) active devices
				ldx numdevs
				lda #$BF				unit num of /RAM
				sta	devlist,x

* check interrupt vector to determine ROM version

noramdsk 		lda RROMWRAMBNK2
				ldy irqv	   			interrupt vector
				ldx irqv+1	   			x = high byte
				jsr lc1in				set language card bank 1 to r/w
				cpx #$D0	   			is it > $D000 (old roms)

*				lda #$00				was for setting removed IRQFLAG
				bcc .1
				
				jmp H22EB				need enhanced Roms

.1				sta SETALTZP
				lda #$FF	   			set aux sp = $FF
				sta auxsp
				stx irqv+1	   			interrupt vector
				sty irqv	   			save irq vector in aux lc
				sta CLRALTZP
				stx irqv+1	   			save irq vector in main lc
				sty irqv
*				lda #$01				was for setting removed IRQFLAG

				stz cortflag			assume not Cortland system

				lda cortland	   		running on a Cortland ?
				beq .2					branch if not.
				inc cortflag	   		yes it's Cortland
				bra docard

* check for a rom in slot 3. if no rom, use internal $C300 firmware

.2	 			sta CLRC3ROM
				lda rommap	   			slot ROM bit map
				and #$08				mask all but slot 3
				bne isromin3	   		taken if rom in slot 3
				bra H2247				else continue booting

* found a rom in slot 3. is it an external, identifiable 80 col card
* with interrupt routines? if so, enable it else use internal $C300 firmware.

isromin3 		sta SETC3ROM
				lda $C305	   			check card id bytes
				cmp #$38
				bne hitswtch	   		not terminal card
				lda $C307
				cmp #$18
				bne hitswtch	
				lda $C30B
				cmp #$01
				bne hitswtch
				lda $C30C				is it an apple 80 col compatible card?
				and #$F0
				cmp #$80
				bne hitswtch	   		if not.
				lda machid	  			machine ID byte
				and #$C8
				cmp #$C0	   			is it a //+ ?
				beq docard	   			yes
				lda $C3FA
				cmp #$2C	   			does card have an interrupt handler?
				beq docard	   			yes

hitswtch 		sta CLRC3ROM

* verify that the card in aux slot is actually present

				sta SET80STORE
				sta SETPAGE2
				lda #$EE
				sta txtp2
				asl
				asl txtp2
				cmp txtp2
				bne .1
				lsr
				lsr txtp2
				cmp txtp2

.1	 			sta CLRPAGE2
				sta CLR80STORE
				beq docard	   			branch if card is there
				lda machid	   			machine ID byte
				and #$FD	   			clear 80-col bit 2 (no card)
				bne H2244				always
				
docard 			lda machid
				ora #$02				turn bit 2 on (80-col card is present)

H2244  			sta machid
H2247  			lda cortland			are we running on a //gs ?
				beq H225D				if not.
				lda #$4C	   			enable clock routine by putting a jmp
				sta clockv	   			in front of clock vector

				lda PAKME.CCLK
				sta ZPInBufPtr
				lda PAKME.CCLK+1
				sta ZPInBufPtr+1
				lda #$D742
				sta ZPOutBufPtr
				lda /$D742
				sta ZPOutBufPtr+1
				jsr X.Unpak

				lda #$01				set bit 0 = clock present
				tsb machid
H225D 			lda setuprts			get setup entry point flag
				beq H2267				taken if normal boot.
				lda RROMBNK2
				rts		  				return to caller at setup entry point.
setuprts 		.DA #$00				0 = normal boot, <>0 = return

* set prefix to boot device

H2267 			jsr MLI
				.DA #MLIONLINE
				.DA LDR.MLIOL.P
				bcs relocerr
		 
				lda pbuf+1				get volume name length.
				and #$0F	   			strip devnum
				beq relocerr
				inc						add 1 for leading '/'
				sta pbuf	   			save prefix length.
				lda #'/'	   			place leading '/' in prefix buffer
				sta pbuf+1
		 
				jsr MLI
				.DA #MLISETPREFIX
				.DA LDR.MLISETP.P
				bcs relocerr
				tax	=0
				stx dst
				ldy #$02	  			read directory into buffer
				lda /DirBlkBuf
H228E  			sta dst+1
				sta LDR.MLIRB.P+3
				sty LDR.MLIRB.P+4
				stx LDR.MLIRB.P+5
				jsr MLI
				.DA #MLIREADBLOCK
				.DA LDR.MLIRB.P
				bcs relocerr
				ldy #$03				get next block# from link
				lda (dst),y
				tax
				dey
				ora (dst),y				if both bytes are the same
				beq H22B7				then no more blocks of directory.
				lda (dst),y
				tay
				lda dst+1
				clc
				adc #$02				add $200 to buffer pointer
				cmp /dbuf+$800	  		until it points past end of buffer.
				bcc H228E				if ok, read next block.

H22B7  			jmp $800				jmp to "load interpreter" code

* relocation/configuration error

relocerr 		sta RROMBNK2
				jsr home
				ldy #$1D

.1	  			lda LDR.MSG.LdrErr,y
				sta vline12+4,y
				dey
				bpl .1

				bmi *

LDR.MSG.LdrErr	.AS -"Relocation/Configuration Error"

H22EB			ldy #$23
.1			  	lda LDR.MSG.EnhErr,y
				sta vline14+2,y
				dey
				bpl .1
				bmi *

LDR.MSG.EnhErr	.AS -"REQUIRES ENHANCED APPLE IIE OR LATER"

LDR.MLIOL.P		.DA #2
				.DA #$60
				.DA pbuf+1
LDR.MLISETP.P
				.DA #1
				.DA pbuf
LDR.MLIRB.P
				.DA #3
				.DA #0	  				unit number
				.DA 0					2 byte data buffer
				.DA 0		 			2 byte block number

cortland 		.BS 1					cortland loader flag (1 = Cortland)
newquitflag 	.BS 1					1 = old quit code

* move thunderclock

rlclk64   		.DA #$01	  			relocation table. 1=move src to dst
				.DA $D742				destination
				.DA TCLK.END-TCLK.START
				.DA TCLK				source

				.DA #$04	  			4=relocate and move program
				.DA TCLK.START
				.DA TCLK.CEND-TCLK.START
				.DA TCLK.START
				.HS 00
				.HS C1C1
clock64			.DA #$00
				.HS FF					done

* determine which system model and save in machine id (idapple)

* find all disk devices in system slots and set up address
* and device table in prodos global page. if there is a disk
* card in slot 2 then limit the # of devices in slot 5
* smartport to only 2
numdev2			.HS 0000000000000000	8 bytes for smartport call
driveradr		.DA	0
d2idx  			.DA #0
diskins2 		.DA #0					msb clear if drive in slot 2

devsrch 		stz dst
				stz dst+1
				stz idxl
				ldx #$FF				init to no active devices.
				stx numdevs	 			count (-1) active devices.
				lda #$0E				start disk // area at end of devlist.
				sta d2idx

* check slot 2. if there is a disk card then clear the msb of diskins2. this
* will limit the # of devices in any slot 5 spartport card to 2.

				lda #$C2
				sta idxl+1				check slot 2
				jsr cmpid				is there a disk in slot 2 ?
				ror diskins2			if so, clear msb else set it.
				lda #$C7	  			search slots from high to low
				sta idxl+1
H26AB  			jsr cmpid
				bcs H270C				if no ProDOS device in this slot.
				lda (idxl),y	  		check last byte of $Cn rom (y = $ff)
				beq diskii	   			branch if 16 sector disk II.
				cmp #$FF	   			if = $FF then 13 sector disk II.
				bcs H270C				ignore if 13 sector boot ROM
				sta driveradr	  		else assume it's an intelligent disk.
				ldy #$07	   			check for a smartport device.
				lda (idxl),y
				bne H26C4				no smartport
				jmp smartprt

H26C4  			ldy #$FE
				lda (idxl),y			get attributes.
				and #$03	   			verify it provides read and status calls.
				cmp #$03
				sec						assume it's an off-brand disk
				bne H270C
				jsr setdevid	   		set up the devid byte from attributes
				clc
				php		  				remember that it's not a disk //.
				lsr						move # of units (0=1, 1=2) to carry.
				lda idxl+1	   			store hi entry addr (low already done)
				bne H26E6				branch always.

diskii			sta	devid				=0 since disk ii's have null attributes
				sec
				php		  				remember it's a disk //
				lda #RWTS
				sta driveradr
				lda /RWTS

H26E6			sta driveradr+1
				jsr installdev			install 1 or 2 devices from this slot.
				plp		  				get back if it's a disk // (carry).
				bcc nxtdsk2	  			if not disk //.
				dex		  				move the list pointer back by 2 devices
				dex
				stx numdevs	  			count (-1) active devices
				dec d2idx				increase the disk two index
				dec d2idx
				ldy d2idx
				inx		  				adj since device count starts with $FF.
				lda devlist+1,x			get entries for disk //
				sta devlist,y	 		move then toward the end of the list
				lda devlist,x	  
				sta devlist+1,y	  
				dex						back to numdevs again
nxtdsk2			clc
H270C  			jsr sltrom				test for ROM in given slot and set flags
				dec idxl+1				next lower slot.
				lda idxl+1
				and #$07	   			have all slots been checked ?
				bne H26AB				no.

* perform the new device search, mapping unmounted smartport devices
* to empty slots in the device table.

				jsr newmount

* now copy the disk // list to the end of the regular list.
* start by making the device count include disk //'s

				ldx numdevs				current device count - 1
				lda #$0E
				sec
				sbc d2idx
				beq H2747				if there were no disk //'s then done.
				clc
				adc numdevs	  			sum of disk //'s and others.
				sta numdevs
				inx						move to open space in regular list.
				ldy #$0D	   			first disk // entry.
H272F  			lda devlist,y
				pha
				lda devlist,x	  
				sta devlist,y	  
				pla
				sta devlist,x	  
				inx
				dey
				sty d2idx				use as a temp
				cpx d2idx
				bcc H272F				continue until indexes cross
H2747  			ldy #$00
				ldx numdevs	  			now change the device order so that

H274C  			lda devlist,x	  		the boot device will have highest
				pha		  				priority.
				and #$7F	   			strip off high bit
				eor devnum	   			for comparison.
				asl
				bne H275A
				pla
				iny
H275A  			dex
				bpl H274C

				ldx numdevs	  			now reverse order of search, hi to lo.
				tya		  				was boot device found ?
				beq H2777
				lda devnum	   			make boot device 1st in search order.
				sta devlist,x
				dex
				bmi H277E				branch if only one device.
				dey		  				is this a 2 drive device ?
				beq H2777				branch if not.
				eor #$80	   			make boot device, drive 2 next.
				sta devlist,x
				dex
				bmi H277E				branch if only 1 device, 2 drives.
H2777			pla
				sta devlist,x
				dex
				bpl H2777
				
H277E  			jsr fndtrd	   			save accumulated machine id.
				beq .1
				sta machid	  			machine ID byte
.1				rts

stadrv 			ora devid				combine with attributes.
				ldx numdevs	  
				inx		  				put device # into device list.
				sta devlist,x
				asl						now form drive 2 device number, if any.
				rts
sltrom 			bcc H27F3				branch if disk drive
* test for clock card
				ldy #$06

.1  			lda (idxl),y
				cmp dskid,y
				bne .2					no clock
				dey
				dey
				bpl .1

				lda idxl+1	   			transfer hi slot address
				sbc #$C1	   			minus $C1 (default) to relocate
				sta clock64	  			references to clock rom.
				lda #$4C				enable jump vector in globals.
				sta clockv	   			P8 clock vector.
				lda idapple	 			mark clock as present.
				beq H277E

				ora #$01
				sta idapple				xxxxxxx1 = clock present.
				bne H27F3				always taken.

* test for 80 col card

.2  			ldy #$05
				lda (idxl),y
				cmp #$38
				bne H27E4
				ldy #$07
				lda (idxl),y
				cmp #$18
				bne H27E4
				ldy #$0B
				lda (idxl),y
				dec 					must = 1
				bne H27E4
				iny
				lda (idxl),y
				and #$F0	   			mask off low nibble.
				cmp #$80	   			generic for 80-col card.
				bne H27E4
				lda idapple
				beq H277E
				ora #$02
				sta idapple				xxxxxx1x = 80 col card.
				bne H27F3				always taken.

* test for any other rom

H27E4  			ldx #$00
				lda (idxl)
				cmp #$FF	   			apple /// non-slot?
				beq H2801				invalid rom
H27EC  			cmp (idxl)				look for floating bus
				bne H2801				no rom
				inx
				bne H27EC
H27F3  			lda idxl+1				mark a bit in slot byte
				and #$07	   			to indicate rom present.
				tax
				lda sltbit,x
				ora rommap	   			mark bit to flag rom present
				sta rommap	   			slot ROM bit map
H2801  			rts

* id bytes: evens for clock, odds for disk
dskid	 		.HS 082028005803703C
* slot bits
sltbit			.HS 0002040810204080

fndtrd			clc
				ldy sltbit
.1  			lda (lookptr),y
				and #$DF
				adc sltbit
				sta sltbit
				rol sltbit
				iny
				cpy sltbit+3
				bne .1
				tya
				asl
				asl
				asl
				asl
				tay
				eor sltbit
				adc #$0B
				bne .2
				lda idapple
				rts

.2  			lda #$00
				rts

installdev 		php						how many drives (carry).
				lda idxl+1	   			get index to global device table
				and #$07	  			for this slot...
				asl
				tay		  				into y reg.
				asl
				asl						now form device # = slot #
				asl						in high nibble.
				jsr stadrv				OR in low nibble, store in dev list.
				plp						restore # of devices in carry.
				ror						if 2 drives, then bit 7=1.
				bpl .1					branch if a 1 drive device (e.g. hard drive)
				inx		  				else presume that 2nd drive is present.
				sta devlist,x	  		active device list.

.1  			stx numdevs	  			save updated device count.
				asl						shift # of drives back into carry.
				lda driveradr			get high address of device driver.
				sta drivertbl1,y	 	device driver table 1.
				bcc .2					branch if single drive.
				sta drivertbl2,y	 	device driver table 2.

.2  			lda driveradr+1
				sta drivertbl1+1,y
				bcc .3
				sta drivertbl2+1,y

.3  			rts

* query smartport status to determine # of devices
* and install up to 4 units in table if card is in slot 5
* otherwise only 2 units. this includes a patch #74

smartprt 		jsr setdevid			setup the devid byte from attributes
				lda idxl+1
				sta driveradr+1
				lda driveradr
				sta pscall+1			modify operand
				clc
				adc #$03
				sta spvect+1
				lda driveradr+1
				sta spvect+2
				sta pscall+2			modify operand
				asl						convert $Cn to $n0
				asl
				asl
				asl
				sta unitnum	  			unit number
				stz A4L					force a prodos status call
				stz buf					dummy pointer
				stz bloknml	  			# of bytes to transfer
				stz bloknml+1
				lda #$10
				sta buf+1				dummy pointer should be <> 0

* do a prodos status call patched in from above

pscall			jsr	$0000				self modifying code
				ldy #$FB	
				lda (idxl),y			check device id
				and #$02	   			SCSI?
				beq .1				no, no need to init Cocoon
				sta statunit	   		device = 2 for SCSI

* initialize SCSI Cocoon to build internal device tables
* and report true # of devices attached

				jsr spvect				status of Cocoon
				.HS 00
				.DA spcparms	 		ignore any errors.

.1  			stz statunit	   		set unit# = 0
				jsr spvect	   			call to get the device count.
				.HS 00					this is a status call
				.DA spcparms

				lda numdev2
				beq donesp				no devices, so done.
				cmp #$02				carry set if 2,3,4
				jsr installdev			do the 1st and 2nd device if exists.
				lda idxl+1
				cmp #$C5
				bne donesp				if not slot 5

* for slot 5, if there is a disk card in slot 2
* then only install 2 devices otherwise map
* extra devices as slot 2

				bit diskins2			disk in slot 2 ?
				bpl donesp	   			yes - so done

				lda numdev2
				cmp #$03				carry set if 3,4,...
				bcc donesp

				cmp #$04	   			carry set if 4,5,6,...
				lda #$C2				map extra devices as slot 2
				sta idxl+1
				jsr installdev

				lda #$C5
				sta idxl+1
donesp			jmp nxtdsk2				it's a disk device.

setdevid 		ldy #$FE				check attributes byte.

				lda (idxl),y
				lsr						move hi nibble to lo nibble for
				lsr						device table entries.
				lsr
				lsr
				sta devid
				rts

* check unknown card to see if disk id = $Cn00:nn 20 nn 00 nn 03

cmpid  			lda CLRC8ROM	   		switch out $C8 ROMs
				ldy #$05
.1  			lda (idxl),y	   		compare id bytes
				cmp dskid,y
				sec		  				set if no disk card
				bne .2
				dey
				dey
				bpl .1				loop until all 4 id bytes match.
				clc						clear if disk card
.2  			rts

* smartport call parameters

spcparms		.DA #$03				# of parms
statunit		.DA #$00				unit number (code for smartport stat)
				.DA numdev2
				.DA #00	 				status code (0 = general status)

* indexes into driver table

driveridx   	.DA #$06
				.DA #$1E
				.DA #$0E
				.DA #$1C
				.DA #$0C
				.DA #$1A
				.DA #$0A
				.DA #$14
				.DA #$04
				.DA #$12
				.DA #$02
				.DA #$18
				.DA #$08

* self modifying jmp = smartport entry address

spvect 			jmp	$0000				self modifying

newmount 		stz idxl
				lda #$C7				start with slot 7 ($C700)
				sta idxl+1

H291F  			jsr H29EB				is there a smartport device here?
				bcs H2974				no, next device.

				ldy #$FF	   			get smartport address.
				lda (idxl),y
				clc
				adc #$03				add 3 for smartport call
				sta spvect+1
				lda idxl+1
				sta spvect+2

				jsr setdevid			set up device attributes
				stz statunit

				jsr spvect				do a status call on smartport itself
				.HS 00
				.DA spcparms
				
				lda numdev2				# of devices on smartport
				cmp #$03
				bcc H2974				only 2 devices,skip to next one.
				inc						add 1 for comparisons.
				sta driveradr	  		# of devices + 1.

				lda #$03	   			start at unit #3 (non-slot 5)

				ldx spvect+2
				cpx #$C5	   			is this slot 5?
				bne H295B				no, start at 3.
				bit diskins2	   		disk controller in slot 2?
				bpl H295B				yes, so allow remapping of s5 devices
				lda #$05	   			else start looking at unit #5

* find block devices on this smartport

H295B  			cmp driveradr	  		have we done all units in this slot?
				bcs H2974				yes, skip to next slot.

				sta statunit	   		store the unit#.
				jsr spvect	   			do status call
				.HS 00
				.DA spcparms
				lda numdev2	  			is this a block device?
				bmi mount				yes, so mount it.

H296E  			lda statunit	  		go check the next unit#
				inc
				bra H295B

H2974  			dec idxl+1
				lda idxl+1
				cmp #$C0				searched down to slot 0?
				bne H291F				if not.
				rts

mount  			ldx #$0C

.1  			ldy driveridx,x
				lda drivertbl1,y	 	device driver table 1
				cmp #nodevice
				bne .2
				lda drivertbl1+1,y
				cmp /nodevice
				beq .3
.2  			dex
				bpl .1
				rts						ran out of space for devices, exit.
* empty slot found
.3  			lda idxl+1
				pha
				phx
				phy
				tya						which slot is empty?
				lsr 					shift into slot#
				and #$07	   			now 1-7
				ora #$C0	   			now $C1-$C7
				sta idxl+1
				jsr H29EB				smartport interface in this slot?
				ply
				plx
				pla
				sta idxl+1
				bcc .2					yes, can't use to mirror the device.
				jsr lc1in				write enable LC ram bank 1.
				tya		  				divide index by 2
				lsr
				tax
				lda statunit
				sta spunit-1,x			store the smartport unit #
				lda spvect+1	  		and entry address.
				sta spvectlo-1,x
				lda spvect+2
				sta spvecthi-1,x
				lda RROMBNK2			write protect lc ram.
				inc numdevs
				ldx numdevs
				tya
				lsr
				cmp #$08
				bcc nodev2				drive 2 mount
				sbc #$08
				ora #$08
nodev2 			asl
				asl
				asl
				asl
				ora devid				include device attributes
				sta devlist,x	  		in the active device list.
				lda #remap_sp
				sta drivertbl1,y	 	device driver table 1
				lda /remap_sp
				sta drivertbl1+1,y
				bra H296E

H29EB  			jsr cmpid				is it a disk controller?
				bcs .9					no, so return.
				sec		  				assume no smartport
				ldy #$07
				lda (idxl),y			is it a smartport?
				bne .9					if not.
				clc						smartport found
.9  			rts

* test for 128k. use page 0 for this routine

LDR.Test128		lda #$EE
				sta SETWRITEAUX
				sta SETREADAUX
				sta $C00				write these locs just to test aux mem
				sta $800		   		1k apart from each other.
				lda $C00
				cmp #$EE
				bne noaux
				asl $C00				may be sparse mem mapping so
				asl						change value and see what happens.
				cmp $C00
				bne noaux				branch if not sparse mapping.
				cmp $800
				bne H2606				if not sparse.

noaux  			sec						no aux memory available.
				bcs H2607
H2606  			clc

H2607  			sta CLRWRITEAUX
				sta CLRREADAUX	  
				rts

LDR.Test128.len	.EQ *-LDR.Test128

* 16 bytes moved to $03F0 vectors

LDR.3F0			.DA breakv
				.DA oldrst
				.DA #$5A				powerup byte
				jmp oldrst	  			'&' vector
				jmp oldrst	   			ctrl-y vector
				.HS 004000
				.DA GP.IRQV				global page interrupt vector
lc1in  			lda RRAMWRAMBNK1
				lda RRAMWRAMBNK1
				rts

MAN
SAVE USR/SRC/PRODOS.FX/PRODOS.S.LDR.A
LOAD USR/SRC/PRODOS.FX/PRODOS.S
ASM
