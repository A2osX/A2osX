NEW
  AUTO 3,1
H2000			jmp prostart
				jmp atalkset			appletalk setup for network boot
				jmp p16start			GQuit setup for gs/os
LDR.MSG.16		.AS	-"Apple II"
LDR.MSG.12		.AS	-"ProDOS 8 V2.0.3      06-May-93"
LDR.MSG.14		.AS	-"A2osX Custom"
LDR.MSG.23		.AS	-"Copyright Apple Computer, Inc., 1983-93"
LDR.MSG.10		.AS	-"All Rights Reserved."
p16start 		inc setuprts			set = 2 for GQuit rts
atalkset 		inc setuprts			set = 1 for appletalk rts
prostart 		lda unitnum
				sta LDR.MLIONLINE.P+1
				jsr LDR.Splash
* test for at least a 65c02
				sed
				lda #$99				a negative #
				clc
				adc #$01				+1 in decimal = 0 (positive)
				cld
				bmi m48k				if 6502 because will not clear N flag

				lda #$01				patch for the gs rom
				trb statereg			to force off intcxrom
				ldx #H232B				yx=232B location table
				ldy /H232B
				jsr reloc				move interpreter loader to $800
				bcs m48k				error
* test for at least 64k
				ldy #$00
				lda #$FF
				sta kversion			at least 48k ?
				eor kversion
				sec
				bne m48k	  			if not.

				sta kversion			try again to be sure
				lda kversion
				bne m48k	  			still not.

				lda RROMBNK2			read ROM
				jsr whchrom				get preliminary system config
				bcs m48k				machine too small
				lda idapple
				and #$20
				bne m64k	  			if at least 64k //+.
m48k  			jmp H22EB				need enhanced IIe

* we have 64k, now determine model: //e , iic, or Cortland (//gs)

m64k  			ldx #H2367				yx=2367 relocation table
				ldy /H2367
				jsr reloc
				lda kversion
				sta xdosver				save current version for dir use
H20CE  			bcc H20D3
				jmp relocerr

H20D3  			lda RROMBNK2			read ROM
				ldx version	  			ROM id byte
				cpx #$06
				bne H211D				then it's a //e
				lda #$E0
				bit zidbyte	  			another ROM id byte
				php
				lda idapple
				and #$37
				plp
				bvc set3				if //c or //x
				bmi set7				if //e

set3  			php
				ora #$08
				plp
				bpl mach2				if //c
				ora #$40
				bpl H20FD				always taken.
mach2 			inc cflag				//c or later
				bvs H20FD
set7  			ora #$80

H20FD 			sta idapple
				lda RROMBNK2			read ROM
				sec
				jsr idroutine	  		returns system info
				bcs H211D				branch if // family
				inc cortland	   		it's a Cortland, set loader flag
				stz vmode				force setvid to reset cursor
				jsr setvid	   			reset output to screen
				lda setuprts
				bne H211D				branch if prodos 8 alone

* running from gs/os shell so zero out os_boot for appletalk

				sta OS_BOOT	   			indicates O/S initially booted.
				jsr patch101	   		patch for gs/os - rev note #101

* put dispatcher in bank 2 of language card

H211D 			lda LDR.MLIONLINE.P+1	place boot devnum in globals
				sta LDR.MLIREADBLOCK.P+1
				sta devnum	   			last device used
				jsr devsrch				finish setting up globals
				lda LDR.MLIREADBLOCK.P+1
				sta devnum
				jsr lc1in				switch in language card bank 1.
				ldx #rlclk64	  		set up clock
				ldy /rlclk64
				jsr reloc

H2139 			bcs H20CE
				lda #calldisp
				sta jspare+1			P8 system death vector
				lda /calldisp
				sta jspare+2
				lda RRAMWRAMBNK2		read/write RAM bank 2
				lda RRAMWRAMBNK2
				ldx #altdsptbl			GQuit dispatcher
				ldy /altdsptbl
				lda setuprts
				cmp #$02				is this a GQuit setup?
				beq H216E				taken to use GQuit dispatcher.
				ldx #newquitbl			else, use Bird's Better Bye
				ldy /newquitbl	  		if correct machine.
				lda machid	  			 machine ID byte
				bit #$00	   			//c ?
				bne H216E				if yes, can use.
				and #$C2
				cmp #$82	   			//e with 80 col card ?
				beq H216E				if yes, can use.
				ldx #dsp64				else, use original quit code
				ldy /dsp64
				inc newquitflag			using old quit code so set flag

H216E 			jsr reloc
				lda #$EE				byte to distinguish LC bank 2
				sta $D000
				jsr lc1in				switch in LC bank 1
				bcs H2139

* test for 128k needed to install ram disk

				lda machid	   			machine ID byte
				and #$30
				eor #$30
				bne noramdsk			if < 128k
				ldx #$FF
				php						save interrupt status
				pla		  				in acc.
				sei		  				no interrupts.
				sta SETALTZP	   		use alt zero page/stack
				stx auxsp				init aux sp to $FF
				sta CLRALTZP	  		use main zero page/stack
				pha		  				restore interrupt status
				plp
				sta CLRC3ROM	  		enable internal slot 3 ROM
				jsr RAMDRV.Install

* check interrupt vector to determine ROM version

noramdsk 		lda RROMWRAMBNK2	   	read ROM/write RAM bank 2
				ldy irqv	   			interrupt vector
				ldx irqv+1	   			x = high byte
				jsr lc1in				set language card bank 1 to r/w
				cpx #$D0	   			is it > $D000 (old roms)

*				lda #$00				was for setting removed IRQFLAG
				bcc .1
				
				jmp H22EB				need enhanced Roms

.1				sta SETALTZP	   		use alt zero page/stack
				lda #$FF	   			set aux sp = $FF
				sta auxsp
				stx irqv+1	   			interrupt vector
				sty irqv	   			save irq vector in aux lc
				sta CLRALTZP	  		use main zero page/stack
				stx irqv+1	   			save irq vector in main lc
				sty irqv
*				lda #$01				was for setting removed IRQFLAG

				stz cortflag			assume not Cortland system

				lda cortland	   		running on a Cortland ?
				beq H21D5				branch if not.
				inc cortflag	   		yes it's Cortland
				bra docard

* check for a rom in slot 3. if no rom, use internal $C300 firmware

H21D5 			sta CLRC3ROM			enable internal slot 3 ROM
				lda rommap	   			slot ROM bit map
				and #$08				mask all but slot 3
				bne isromin3	   		taken if rom in slot 3
				bra H2247				else continue booting

* found a rom in slot 3. is it an external, identifiable 80 col card
* with interrupt routines? if so, enable it else use internal $C300 firmware.

isromin3 		sta SETC3ROM	   		enable slot 3 rom
				lda $C305	   			check card id bytes
				cmp #$38
				bne hitswtch	   		not terminal card
				lda $C307
				cmp #$18
				bne hitswtch	
				lda $C30B
				cmp #$01
				bne hitswtch
				lda $C30C				is it an apple 80 col compatible card?
				and #$F0
				cmp #$80
				bne hitswtch	   		if not.
				lda machid	  			machine ID byte
				and #$C8
				cmp #$C0	   			is it a //+ ?
				beq docard	   			yes
				lda $C3FA
				cmp #$2C	   			does card have an interrupt handler?
				beq docard	   			yes

hitswtch 		sta CLRC3ROM			enable internal $C300 firmware

* verify that the card in aux slot is actually present

				sta SET80STORE	  		enable 80-col store
				sta SETPAGE2	   		switch in text page 2
				lda #$EE
				sta txtp2
				asl
				asl txtp2
				cmp txtp2
				bne H2230
				lsr
				lsr txtp2
				cmp txtp2

H2230 			sta CLRPAGE2			main memory
				sta CLR80STORE			disable 80-col store
				beq docard	   			branch if card is there
				lda machid	   			machine ID byte
				and #$FD	   			clear 80-col bit 2 (no card)
				bne H2244				always
docard 			lda machid
				ora #$02				turn bit 2 on (80-col card is present)
H2244  			sta machid
H2247  			lda cortland			are we running on a //gs ?
				beq H225D				if not.
				lda #$4C	   			enable clock routine by putting a jmp
				sta clockv	   			in front of clock vector
				ldx #cortclock	  		yx = relocation table
				ldy /cortclock	 		for cortland clock driver
				jsr reloc
				lda #$01				set bit 0 = clock present
				tsb machid
H225D 			lda setuprts			get setup entry point flag
				beq H2267				taken if normal boot.
				lda RROMBNK2			read ROM
				rts		  				return to caller at setup entry point.
setuprts 		.DA #$00				0 = normal boot, <>0 = return

* set prefix to boot device

H2267 			jsr MLI
				.DA #MLIONLINE
				.DA LDR.MLIONLINE.P
				bcs relocerr
		 
				lda pbuf+1				get volume name length.
				and #$0F	   			strip devnum
				beq relocerr
				inc						add 1 for leading '/'
				sta pbuf	   			save prefix length.
				lda #'/'	   			place leading '/' in prefix buffer
				sta pbuf+1
		 
				jsr MLI
				.DA #MLISETPREFIX
				.DA LDR.MLISETPREFIX.P
				bcs relocerr
				tax	=0
				stx dst
				ldy #$02	  			read directory into buffer
				lda /DirBlkBuf
H228E  			sta dst+1
				sta LDR.MLIREADBLOCK.P+3
				sty LDR.MLIREADBLOCK.P+4
				stx LDR.MLIREADBLOCK.P+5
				jsr MLI
				.DA #MLIREADBLOCK
				.DA LDR.MLIREADBLOCK.P
				bcs relocerr
				ldy #$03				get next block# from link
				lda (dst),y
				tax
				dey
				ora (dst),y				if both bytes are the same
				beq H22B7				then no more blocks of directory.
				lda (dst),y
				tay
				lda dst+1
				clc
				adc #$02				add $200 to buffer pointer
				cmp /dbuf+$800	  		until it points past end of buffer.
				bcc H228E				if ok, read next block.

H22B7  			jmp $800				jmp to "load interpreter" code

* relocation/configuration error

relocerr 		sta RROMBNK2			read ROM
				jsr home
				ldy #$1D

.1	  			lda LDR.MSG.LdrErr,y
				sta vline12+4,y
				dey
				bpl .1

				bmi *

LDR.MSG.LdrErr	.AS -"Relocation/Configuration Error"

H22EB			ldy #$23
.1			  	lda LDR.MSG.EnhErr,y
				sta vline14+2,y
				dey
				bpl .1
				bmi *

LDR.MSG.EnhErr	.AS -"REQUIRES ENHANCED APPLE IIE OR LATER"

LDR.MLIONLINE.P	.DA #2
				.DA #$60
				.DA pbuf+1
LDR.MLISETPREFIX.P
				.DA #1
				.DA pbuf
LDR.MLIREADBLOCK.P
				.DA #3
				.DA #0	  				unit number
				.DA 0					2 byte data buffer
				.DA 0		 			2 byte block number

cortland 		.BS 1					cortland loader flag (1 = Cortland)
newquitflag 	.BS 1					1 = old quit code

H232B  			.DA #1	  				move interpreter loader code
				.DA $800				destination address
				.DA licode.end-licode	length to move
				.DA LOADINT	 			source address
				.DA #$01	  			move $3F0 vectors
				.DA p3vect	 			destination
				.DA $0010	  			16 bytes to move
				.DA H257B				source
				.DA #$01
				.DA lookptr				destination address
				.DA $0002				length to move
				.DA dst					source
				.DA #$01	  			move 128k test to zero page
				.DA tst128				destination
				.DA LDR.Test128.Len		length to move
				.DA LDR.Test128			source
				.HS FF					done
		 
dsp64	 		.DA #$01	  			move p8 dispatcher code
				.DA displc2	  			destination
				.DA $0300				length (must be <= 3 pages)
				.DA SEL0		 		source
				.HS FF					done
		 
newquitbl 		.DA #$01	  			move Bird's Bye code
				.DA displc2	  			dest
				.DA $0300				length (must be <= 3 pages)
				.DA SEL1	  			source
				.HS FF					done
		 
altdsptbl 		.DA #$01	  			move GQuit launcher
				.DA displc2				destination
				.DA $0300	  			length (must be <= 3 pages)
				.DA SEL2	 			source
				.DA #$01	  			move a copy of GQuit launcher
				.DA dispadr	  			to dispadr for gsos
				.DA $0300	  			length (must be <= 3 pages)
				.DA SEL2	 			source
				.HS FF					done

* tables for moving 64k version of mli for execution

H2367			.DA #$01	  			relocation table. 1=move src to dst
				.DA $ff9b	 			destination
				.DA $100-$9B			length to move
				.DA IRQ		  			source
				.DA #$01
				.DA MLI					dst
				.DA $0100				in one page
				.DA GP					src
				.HS 00					0=clear buffers $D700-$DDFF
				.DA $D700				start
				.DA $0700				len
				.DA #$01
				.DA $DE00				dst
				.DA $2100				length of mli
				.DA XDOS				src
				.DA #$01
				.DA $D000
				.DA $0700				length of disk ii driver
				.DA XRW
				.HS FF					done

* move thunderclock

rlclk64   		.DA #$01	  			relocation table. 1=move src to dst
				.DA $D742				destination
				.DA TCLK.END-TCLK.START	length of thunderclock driver
				.DA TCLK				source

				.DA #$04	  			4=relocate and move program
				.DA TCLK.START
				.DA TCLK.CEND-TCLK.START
				.DA TCLK.START
				.HS 00
				.HS C1C1
clock64			.DA #$00
				.HS FF					done

* move cortland clock

cortclock 		.DA #$01	  			relocation table. 1=move src to dst
				.DA $D742				destination
				.DA CCLK.END-CCLK.START	length of cortland clock driver
				.DA CCLK				source
				.HS FF					done

* 16 bytes moved to $03F0 vectors

H257B			.DA breakv
				.DA oldrst
				.DA #$5A				powerup byte
				jmp oldrst	  			'&' vector
				jmp oldrst	   			ctrl-y vector
				.HS 004000
				.DA GP.IRQV				global page interrupt vector
lc1in  			lda RRAMWRAMBNK1		read/write language card RAM bank 1
				lda RRAMWRAMBNK1
				rts

* determine which system model and save in machine id (idapple)

whchrom			stz idapple				assume standard apple //
				ldx version	  			check hardware id
				cpx #$38	   			is it apple // (autostart rom)?
				beq H25BE				if yes
				lda #$80
				cpx #$06	   			apple //e?
				beq H25BC				if yes
				lda #$40	   
				cpx #$EA	   			apple //+?
				bne H25B6				it not, then machine is unknown.
				ldx $FB1E				apple /// in emulation?
				cpx #$AD
				beq H25BC				taken if apple //+.
				lda #$D0	   			test again for apple /// emulation
				cpx #$8A	   			because will only have 48k memory.
				bne H25B6				if taken, then machine is unknown.
H25B4  			sec						apple /// emulation is not allowed
				rts		  				because insufficient memory.
H25B6  			lda #$02				machine unknown
				sta (dst),y
				bne H25D9				always.
H25BC  			sta idapple				save machine id

* check for language card ram

H25BE  			jsr lc1in				switch in language card bank 1
				lda #$AA
				sta $D000
				eor $D000				if LC present, result = 0.
				bne H25B4				othewise, insufficient memory.
				lsr $D000				check lc again
				lda #$55
				eor $D000
				bne H25B4				not sufficent memory.
				lda #$20				LC ram is available
				ora idapple
H25D9  			jmp tst128				jumps to page 0 routine below

* test for 128k. use page 0 for this routine

LDR.Test128		sta idapple				H25DC-2621 was moved to location tst128
				bpl not128	   			if already determined < 128k
				lda #$EE
				sta SETWRITEAUX	  		write to aux mem while on main zp
				sta SETREADAUX	  		and read aux mem.
				sta dbuf				write these locs just to test aux mem
				sta $800		   		1k apart from each other.
				lda dbuf
				cmp #$EE
				bne noaux
				asl dbuf				may be sparse mem mapping so
				asl						change value and see what happens.
				cmp dbuf
				bne noaux				branch if not sparse mapping.
				cmp $800
				bne H2606				if not sparse.
noaux  			sec						no aux memory available.
				bcs H2607
H2606  			clc
H2607  			sta CLRWRITEAUX	  		switch back to main memory
				sta CLRREADAUX	  
				bcs not128	  			if < 128k
				lda idapple
				ora #$30				set id = 128k present
				sta idapple
not128 			lda lookptr+1
				sec
				sbc #$05
				sta lookptr+1
				bcs H2620
				dec lookptr
H2620  			clc
				rts
LDR.Test128.len	.EQ *-LDR.Test128
*--------------------------------------
LDR.Splash		cld
				sta CLR80DISP			disable 80 col hardware
				sta	CLR80STORE			disable 80 col store
				jsr setnorm	 			set normal text mode
				jsr init	  			init text screen
				jsr setvid	  			reset output to screen
				jsr setkbd	  			reset input to keyboard
				jsr home
				ldx #$07
.1		 		lda LDR.MSG.16,x
				sta vline10+16,x
				dex
				bpl .1
		 
				ldx #$1D
.2	  			lda LDR.MSG.12,x
				sta vline12+5,x
				dex
				bpl .2
				ldx #$0B
.3	  			lda LDR.MSG.14,x
				sta vline14+14,x
				dex
				bpl .3
				ldx #$26
.4	  			lda LDR.MSG.23,x
				sta vline23,x
				dex
				bpl .4
				ldx #$13
.5	  			lda LDR.MSG.10,x
				sta vline24+10,x
				dex
				bpl .5
				sec
				jsr idroutine   		returns system info
				bcs .8					taken if not a //gs
				lda #$80
				trb newvideo			video mode select
.8	  			bit $C000
				bpl .8
				sta $C010
				rts
*--------------------------------------
* find all disk devices in system slots and set up address
* and device table in prodos global page. if there is a disk
* card in slot 2 then limit the # of devices in slot 5
* smartport to only 2
*--------------------------------------
numdev2			.HS 0000000000000000	8 bytes for smartport call
driveradr		.DA	0
d2idx  			.DA #0
diskins2 		.DA #0					msb clear if drive in slot 2

devsrch 		stz dst
				stz dst+1
				stz idxl
				ldx #$FF				init to no active devices.
				stx numdevs	 			count (-1) active devices.
				lda #$0E				start disk // area at end of devlist.
				sta d2idx

* check slot 2. if there is a disk card then clear the msb of diskins2. this
* will limit the # of devices in any slot 5 spartport card to 2.

				lda #$C2
				sta idxl+1				check slot 2
				jsr cmpid				is there a disk in slot 2 ?
				ror diskins2			if so, clear msb else set it.
				lda #$C7	  			search slots from high to low
				sta idxl+1
H26AB  			jsr cmpid
				bcs H270C				if no ProDOS device in this slot.
				lda (idxl),y	  		check last byte of $Cn rom (y = $ff)
				beq diskii	   			branch if 16 sector disk II.
				cmp #$FF	   			if = $FF then 13 sector disk II.
				bcs H270C				ignore if 13 sector boot ROM
				sta driveradr	  		else assume it's an intelligent disk.
				ldy #$07	   			check for a smartport device.
				lda (idxl),y
				bne H26C4				no smartport
				jmp smartprt

H26C4  			ldy #$FE
				lda (idxl),y			get attributes.
				and #$03	   			verify it provides read and status calls.
				cmp #$03
				sec						assume it's an off-brand disk
				bne H270C
				jsr setdevid	   		set up the devid byte from attributes
				clc
				php		  				remember that it's not a disk //.
				lsr						move # of units (0=1, 1=2) to carry.
				lda idxl+1	   			store hi entry addr (low already done)
				bne H26E6				branch always.

diskii			sta	devid				=0 since disk ii's have null attributes
				sec
				php		  				remember it's a disk //
				lda #RWTS
				sta driveradr
				lda /RWTS

H26E6			sta driveradr+1
				jsr installdev			install 1 or 2 devices from this slot.
				plp		  				get back if it's a disk // (carry).
				bcc nxtdsk2	  			if not disk //.
				dex		  				move the list pointer back by 2 devices
				dex
				stx numdevs	  			count (-1) active devices
				dec d2idx				increase the disk two index
				dec d2idx
				ldy d2idx
				inx		  				adj since device count starts with $FF.
				lda devlist+1,x			get entries for disk //
				sta devlist,y	 		move then toward the end of the list
				lda devlist,x	  
				sta devlist+1,y	  
				dex						back to numdevs again
nxtdsk2			clc
H270C  			jsr sltrom				test for ROM in given slot and set flags
				dec idxl+1				next lower slot.
				lda idxl+1
				and #$07	   			have all slots been checked ?
				bne H26AB				no.

* perform the new device search, mapping unmounted smartport devices
* to empty slots in the device table.

				jsr newmount

* now copy the disk // list to the end of the regular list.
* start by making the device count include disk //'s

				ldx numdevs				current device count - 1
				lda #$0E
				sec
				sbc d2idx
				beq H2747				if there were no disk //'s then done.
				clc
				adc numdevs	  			sum of disk //'s and others.
				sta numdevs
				inx						move to open space in regular list.
				ldy #$0D	   			first disk // entry.
H272F  			lda devlist,y
				pha
				lda devlist,x	  
				sta devlist,y	  
				pla
				sta devlist,x	  
				inx
				dey
				sty d2idx				use as a temp
				cpx d2idx
				bcc H272F				continue until indexes cross
H2747  			ldy #$00
				ldx numdevs	  			now change the device order so that

H274C  			lda devlist,x	  		the boot device will have highest
				pha		  				priority.
				and #$7F	   			strip off high bit
				eor devnum	   			for comparison.
				asl
				bne H275A
				pla
				iny
H275A  			dex
				bpl H274C

				ldx numdevs	  			now reverse order of search, hi to lo.
				tya		  				was boot device found ?
				beq H2777
				lda devnum	   			make boot device 1st in search order.
				sta devlist,x
				dex
				bmi H277E				branch if only one device.
				dey		  				is this a 2 drive device ?
				beq H2777				branch if not.
				eor #$80	   			make boot device, drive 2 next.
				sta devlist,x
				dex
				bmi H277E				branch if only 1 device, 2 drives.
H2777			pla
				sta devlist,x
				dex
				bpl H2777
H277E  			jsr fndtrd	   			save accumulated machine id.
				beq H2787
				sta machid	  			machine ID byte
				rts
H2787  			jmp H25B6
stadrv 			ora devid				combine with attributes.
				ldx numdevs	  
				inx		  				put device # into device list.
				sta devlist,x
				asl						now form drive 2 device number, if any.
				rts
sltrom 			bcc H27F3				branch if disk drive
* test for clock card
				ldy #$06

H2799  			lda (idxl),y
				cmp dskid,y
				bne H27BA				no clock
				dey
				dey
				bpl H2799

				lda idxl+1	   			transfer hi slot address
				sbc #$C1	   			minus $C1 (default) to relocate
				sta clock64	  			references to clock rom.
				lda #$4C				enable jump vector in globals.
				sta clockv	   			P8 clock vector.
				lda idapple	 			mark clock as present.
				beq H277E

				ora #$01
				sta idapple				xxxxxxx1 = clock present.
				bne H27F3				always taken.

* test for 80 col card

H27BA  			ldy #$05
				lda (idxl),y
				cmp #$38
				bne H27E4
				ldy #$07
				lda (idxl),y
				cmp #$18
				bne H27E4
				ldy #$0B
				lda (idxl),y
				dec 		must = 1
				bne H27E4
				iny
				lda (idxl),y
				and #$F0	   			mask off low nibble.
				cmp #$80	   			generic for 80-col card.
				bne H27E4
				lda idapple
				beq H277E
				ora #$02
				sta idapple				xxxxxx1x = 80 col card.
				bne H27F3				always taken.

* test for any other rom

H27E4  			ldx #$00
				lda (idxl)
				cmp #$FF	   			apple /// non-slot?
				beq H2801				invalid rom
H27EC  			cmp (idxl)				look for floating bus
				bne H2801				no rom
				inx
				bne H27EC
H27F3  			lda idxl+1				mark a bit in slot byte
				and #$07	   			to indicate rom present.
				tax
				lda sltbit,x
				ora rommap	   			mark bit to flag rom present
				sta rommap	   			slot ROM bit map
H2801  			rts

* id bytes: evens for clock, odds for disk
dskid	 		.HS 082028005803703C
* slot bits
sltbit			.HS 0002040810204080

fndtrd			clc
				ldy sltbit
H2818  			lda (lookptr),y
				and #$DF
				adc sltbit
				sta sltbit
				rol sltbit
				iny
				cpy sltbit+3
				bne H2818
				tya
				asl
				asl
				asl
				asl
				tay
				eor sltbit
				adc #$0B
				bne H283B
				lda idapple
				rts

H283B  			lda #$00
				rts

installdev 		php						how many drives (carry).
				lda idxl+1	   			get index to global device table
				and #$07	  			for this slot...
				asl
				tay		  				into y reg.
				asl
				asl						now form device # = slot #
				asl						in high nibble.
				jsr stadrv				OR in low nibble, store in dev list.
				plp						restore # of devices in carry.
				ror						if 2 drives, then bit 7=1.
				bpl H2853				branch if a 1 drive device (e.g. hard drive)
				inx		  				else presume that 2nd drive is present.
				sta devlist,x	  		active device list.

H2853  			stx numdevs	  			save updated device count.
				asl						shift # of drives back into carry.
				lda driveradr			get high address of device driver.
				sta drivertbl1,y	 	device driver table 1.
				bcc H2862				branch if single drive.
				sta drivertbl2,y	 	device driver table 2.

H2862  			lda driveradr+1
				sta drivertbl1+1,y
				bcc H286D
				sta drivertbl2+1,y

H286D  			rts

* query smartport status to determine # of devices
* and install up to 4 units in table if card is in slot 5
* otherwise only 2 units. this includes a patch #74

smartprt 		jsr setdevid			setup the devid byte from attributes
				lda idxl+1
				sta driveradr+1
				lda driveradr
				sta pscall+1			modify operand
				clc
				adc #$03
				sta spvect+1
				lda driveradr+1
				sta spvect+2
				sta pscall+2			modify operand
				asl		convert $Cn to $n0
				asl
				asl
				asl
				sta unitnum	  			unit number
				stz A4L					force a prodos status call
				stz buf					dummy pointer
				stz bloknml	  			# of bytes to transfer
				stz bloknml+1
				lda #$10
				sta buf+1				dummy pointer should be <> 0

* do a prodos status call patched in from above

pscall			jsr	$0000				self modifying code
				ldy #$FB	
				lda (idxl),y			check device id
				and #$02	   			SCSI?
				beq H28B1				no, no need to init Cocoon
				sta statunit	   		device = 2 for SCSI

* initialize SCSI Cocoon to build internal device tables
* and report true # of devices attached

				jsr spvect				status of Cocoon
				.HS 00
				.DA spcparms	 		ignore any errors.

H28B1  			stz statunit	   		set unit# = 0
				jsr spvect	   			call to get the device count.
				.HS 00					this is a status call
				.DA spcparms

				lda numdev2
				beq donesp				no devices, so done.
				cmp #$02				carry set if 2,3,4
				jsr installdev			do the 1st and 2nd device if exists.
				lda idxl+1
				cmp #$C5
				bne donesp				if not slot 5

* for slot 5, if there is a disk card in slot 2
* then only install 2 devices otherwise map
* extra devices as slot 2

				bit diskins2			disk in slot 2 ?
				bpl donesp	   			yes - so done

				lda numdev2
				cmp #$03				carry set if 3,4,...
				bcc donesp

				cmp #$04	   			carry set if 4,5,6,...
				lda #$C2				map extra devices as slot 2
				sta idxl+1
				jsr installdev

				lda #$C5
				sta idxl+1
donesp			jmp nxtdsk2				it's a disk device.

setdevid 		ldy #$FE				check attributes byte.

				lda (idxl),y
				lsr						move hi nibble to lo nibble for
				lsr						device table entries.
				lsr
				lsr
				sta devid
				rts

* check unknown card to see if disk id = $Cn00:nn 20 nn 00 nn 03

cmpid  			lda CLRC8ROM	   		switch out $C8 ROMs
				ldy #$05
H28F6  			lda (idxl),y	   		compare id bytes
				cmp dskid,y
				sec		  				set if no disk card
				bne H2903
				dey
				dey
				bpl H28F6				loop until all 4 id bytes match.
				clc						clear if disk card
H2903  			rts

* smartport call parameters

spcparms		.DA #$03				# of parms
statunit		.DA #$00				unit number (code for smartport stat)
				.DA numdev2
				.DA #00	 				status code (0 = general status)

* indexes into driver table

driveridx   	.DA #$06
				.DA #$1E
				.DA #$0E
				.DA #$1C
				.DA #$0C
				.DA #$1A
				.DA #$0A
				.DA #$14
				.DA #$04
				.DA #$12
				.DA #$02
				.DA #$18
				.DA #$08

* self modifying jmp = smartport entry address

spvect 			jmp	$0000				self modifying

newmount 		stz idxl
				lda #$C7				start with slot 7 ($C700)
				sta idxl+1

H291F  			jsr H29EB				is there a smartport device here?
				bcs H2974				no, next device.

				ldy #$FF	   			get smartport address.
				lda (idxl),y
				clc
				adc #$03				add 3 for smartport call
				sta spvect+1
				lda idxl+1
				sta spvect+2

				jsr setdevid			set up device attributes
				stz statunit

				jsr spvect				do a status call on smartport itself
				.HS 00
				.DA spcparms
				
				lda numdev2				# of devices on smartport
				cmp #$03
				bcc H2974				only 2 devices,skip to next one.
				inc						add 1 for comparisons.
				sta driveradr	  		# of devices + 1.

				lda #$03	   			start at unit #3 (non-slot 5)

				ldx spvect+2
				cpx #$C5	   			is this slot 5?
				bne H295B				no, start at 3.
				bit diskins2	   		disk controller in slot 2?
				bpl H295B				yes, so allow remapping of s5 devices
				lda #$05	   			else start looking at unit #5

* find block devices on this smartport

H295B  			cmp driveradr	  		have we done all units in this slot?
				bcs H2974				yes, skip to next slot.

				sta statunit	   		store the unit#.
				jsr spvect	   			do status call
				.HS 00
				.DA spcparms
				lda numdev2	  			is this a block device?
				bmi mount				yes, so mount it.

H296E  			lda statunit	  		go check the next unit#
				inc
				bra H295B

H2974  			dec idxl+1
				lda idxl+1
				cmp #$C0				searched down to slot 0?
				bne H291F				if not.
				rts

mount  			ldx #$0C

H297F  			ldy driveridx,x
				lda drivertbl1,y	 	device driver table 1
				cmp #nodevice
				bne H2990
				lda drivertbl1+1,y
				cmp /nodevice
				beq H2994
H2990  			dex
				bpl H297F
				rts						ran out of space for devices, exit.

* empty slot found

H2994  			lda idxl+1
				pha
				phx
				phy
				tya						which slot is empty?
				lsr 					shift into slot#
				and #$07	   			now 1-7
				ora #$C0	   			now $C1-$C7
				sta idxl+1
				jsr H29EB				smartport interface in this slot?
				ply
				plx
				pla
				sta idxl+1
				bcc H2990				yes, can't use to mirror the device.
				jsr lc1in				write enable LC ram bank 1.
				tya		  				divide index by 2
				lsr
				tax
				lda statunit
				sta spunit-1,x			store the smartport unit #
				lda spvect+1	  		and entry address.
				sta spvectlo-1,x
				lda spvect+2
				sta spvecthi-1,x
				lda RROMBNK2			write protect lc ram.
				inc numdevs
				ldx numdevs
				tya
				lsr
				cmp #$08
				bcc nodev2				drive 2 mount
				sbc #$08
				ora #$08
nodev2 			asl
				asl
				asl
				asl
				ora devid				include device attributes
				sta devlist,x	  		in the active device list.
				lda #remap_sp
				sta drivertbl1,y	 	device driver table 1
				lda /remap_sp
				sta drivertbl1+1,y
				bra H296E

H29EB  			jsr cmpid				is it a disk controller?
				bcs H29F8				no, so return.
				sec		  				assume no smartport
				ldy #$07
				lda (idxl),y			is it a smartport?
				bne H29F8				if not.
				clc						smartport found
H29F8  			rts
*--------------------------------------
MAN
SAVE USR/SRC/PRODOS.FX/PRODOS.S.LDR.A
LOAD USR/SRC/PRODOS.FX/PRODOS.S
ASM
