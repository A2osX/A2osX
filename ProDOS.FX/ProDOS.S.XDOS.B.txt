NEW
  AUTO 3,1
*--------------------------------------
entcalc			jsr XDOS.ZPT.InitGBuf

				ldx d_entnum			on the entry #.

				clc

.1				dex		 				addr = XDOS.GBuf + ((d_entnum-1) * h_entln)
				beq crerr3			  	branch with carry clear = no errors.

				jsr XDOS.ZPT.Next
				bcc .1

crerr3 			rts		 				carry set if error.
*--------------------------------------
drevise			lda GP.DATE
				beq drevise1		  	if no clock, then don't mod date/time.

				ldx #$03

modtime			lda GP.DATE,x			move last modification date/time
				sta d_moddt,x			to entry being updated.
				dex
				bpl modtime

drevise1 		lda bkbitflg			(bit 5 = backup needed)
				tsb d_attr				mark entry as backupable

				lda d_dev			  	get device # of directory
				sta GP.DEVNUM			 	to be revised

				lda d_entblk			and address of directory block.
				ldx d_entblk+1

				.DO LOWERCASE=1
				jsr XDOS.ReadGBufAXDir
				.ELSE
				jsr XDOS.ReadGBufAX		read block into general purpose buffer
				.FIN
				bcs crerr3

				jsr entcalc				fix up ptr to entry location within XDOS.GBuf.

				ldy h_entln				now move 'd.' info to directory.
				dey

.1  			lda d_stor,y
				sta (zpt),y
				dey
				bpl .1

				lda d_head				is the entry block same as
				cmp ZP.BLKNUM			the entry's header block?
				bne H36E0			  	if no, go save entry block

				lda d_head+1			then maybe, so test high addresses.
				cmp ZP.BLKNUM+1
				beq uphead			 	branch if they are the same block.

H36E0  			.DO LOWERCASE=1
				jsr XDOS.WriteGBufDir
				.ELSE
				jsr XDOS.WriteGBuf		go write updated directory block.
				.FIN
				bcs crerr3

				lda d_head			 	get address of header block and
				ldx d_head+1

				.DO LOWERCASE=1
				jsr XDOS.ReadGBufAXDir
				.ELSE
				jsr XDOS.ReadGBufAX		go read in header block to modify.
				.FIN
				bcs crerr3

uphead			ldy #$01				update current # of files in this dir.

H36F2  			lda h_fcnt,y
				sta XDOS.GBuf+37,y			(current entry count)
				dey
				bpl H36F2

				lda h_attr			 	also update header's attributes.
				sta XDOS.GBuf+34

				.DO LOWERCASE=1
				jsr XDOS.WriteGBufDir
				.ELSE
				jsr XDOS.WriteGBuf		go write updated header
				.FIN
				bcs H375A
*--------------------------------------
ripple			lda XDOS.GBuf+4				test for 'root' directory because
				and #$F0			 	if it is, then directory revision
				eor #$F0			 	is complete (leaves carry clear).
				beq H3770			  	branch if done.

				lda XDOS.GBuf+41				get entry #
				sta d_entnum
				lda XDOS.GBuf+42				and the length of entries in that dir
				sta h_entln

				lda XDOS.GBuf+39				get addr of parent entry's dir block
				ldx XDOS.GBuf+40

				.DO LOWERCASE=1
				jsr XDOS.ReadGBufAX		no need to pak/unpak....will disturb zpt
				.ELSE
				jsr XDOS.ReadGBufAX		read it
				.FIN
				bcs H375A

				jsr entcalc				get indirect ptr to parent entry in XDOS.GBuf

				lda GP.DATE				don't touch mod
				beq H373B			  	if no clock...

				ldx #$03			 	update the modification date & time
				ldy #$24			 	for this entry too

H3732  			lda GP.DATE,x
				sta (zpt),y
				dey
				dex
				bpl H3732

H373B  			.DO LOWERCASE=1
				jsr XDOS.WriteGBuf
				.ELSE
				jsr XDOS.WriteGBuf		write updated entry back to disk.
				.FIN
				bcs H375A			  	if error.

				ldy #$26			 	compare current block # to this
				lda (zpt),y				entry's header block.
				tax
				dey
				lda (zpt),y				block as header.
				cmp ZP.BLKNUM			are low addresses the same?
				bne H3751			 	branch if entry doesn't reside in same

				cpx ZP.BLKNUM+1			are high address the same?
				beq ripple			 	they are the same, continue to root dir.

H3751  			.DO LOWERCASE=1
				jsr XDOS.ReadGBufAX
				.ELSE
				jsr XDOS.ReadGBufAX
				.FIN
				bcc ripple				continue if read was good

H375A  			rts

H3770  			clc		 				no error
				rts
*--------------------------------------
XDOS.FindDirOrVol
				jsr XDOS.FindFileOrVol
				bcs .99
				
				lda d_stor
			
				and #$F0
				cmp #$D0
				beq moventry.CLCRTS

.9				lda #MLI.E.UNSUPST
				sec
.99				rts
*--------------------------------------
XDOS.FindFileOrVol
				jsr XDOS.CheckPath
				bcc moventry

				cmp #MLI.E.INVPATH
				bne fnderr
				clc
				rts
				
moventry 		ldy h_entln				Get FileInfo From Directory Block Buffer

.1  			dey
				lda (zpt),y				move entry into storage
				sta d_stor,y
				tya
				bne .1
moventry.CLCRTS
				clc
				rts
*--------------------------------------
XDOS.FindFile	jsr XDOS.CheckPath		see if file exists
				bcc moventry
				rts
*--------------------------------------
XDOS.CheckPath 	jsr XDOS.FindVol
				bcs fnderr.RTS

				bne lookfil0			branch if more than root

				jsr XDOS.ZPT.InitGBuf

				ldy #$1F				move in id and date info

.1  			lda (zpt),y
				sta d_stor,y
				dey
				cpy #$17
				bne .1

.2		  		lda rootstuf-$10,y
				sta d_stor,y
				dey
				cpy #$0F
				bne .2

				lda #$D0				fake directory file
				sta d_stor
				lda XDOS.GBuf+2			check forward link.
				ora XDOS.GBuf+3			if non-zero, assume full sized directory
				bne .3				 	else assume it's the slot 3 /RAM volume

				lda #$02			 	so reset eof and blocks_used fields
				sta d_eof+1
				lda #$01
				sta d_usage

.3  			lda #MLI.E.INVPATH		bad path (carry set)
				rts
*--------------------------------------
errdir 			lda #MLI.E.BADDIR	 	directory error
fnderr 			sec
fnderr.RTS		rts
*--------------------------------------
lookfil0		stz nofree				reset free entry indicator.

				sec		 				dir to be searched has header in this block.
			
L37C9  			stz totent			 	reset entry counter.

				jsr XDOS.LookupNameInDirBlk		look for name pointed to by pnptr.
				bcc namfound			if name was found.

				lda entcntl				have we looked at all of the
				sbc totent			 	entries in this directory?
				bcc L37E2			  	maybe, check hi count.
				bne L37EB			  	no, read next directory block.

				lda entcnth				has the last entry been looked at?
				beq errfnf			 	yes, give 'file not found' error

L37E2  			dec entcnth				should be at least one
L37EB  			sta entcntl				keep a running count.
				lda /XDOS.GBuf			reset indirect pointer
				sta zpt+1

				lda XDOS.GBuf+2			get link to next dir block
				bne L37FC			  	(if there is one).

				cmp XDOS.GBuf+3			are both zero, i.e. no link? if so,
				beq errdir			 	then not all entries were acct'd for.

L37FC  			ldx XDOS.GBuf+3			acc has value for block# (low).
				.DO LOWERCASE=1
				jsr XDOS.ReadGBufAXDir
				.ELSE
				jsr XDOS.ReadGBufAX		go read the next linked directory.
				.FIN
				bcc L37C9			  	if no error.
				rts		 				return error in acc.
*--------------------------------------
errfnf 			lda nofree				was any free entry found?
				bne .2

				lda XDOS.GBuf+2			test link
				bne .1

				cmp XDOS.GBuf+3			if both are 0 then give up.
				beq .2				 	report 'not found'.

.1  			sta d_entblk
				lda XDOS.GBuf+3
				sta d_entblk+1			assume 1st entry of next block
				lda #$01			 	is free for use.
				sta d_entnum			mark as valid (for create)
				sta nofree

.2   			jsr nxtpnam1			'file not found' or 'path not found'?

errpath1 		beq .1					if non-zero then 'path not found'

				lda #MLI.E.PNOTFND		path not found
				.HS 2C					BIT ABS

.1   			lda #MLI.E.FNOTFND	 	file not found
				sec
lookfil0.RTS	rts
*--------------------------------------
namfound 		jsr nxtpname			adj index to next name in path.
				beq filfound			branch if that was the last name.

				ldy #$00			 	be sure this is a directory entry.
				lda (zpt),y				high nibble will tell.
				and #$F0
				cmp #$D0			 	is it a subdirectory?
				bne errpath1			error if not.

				ldy #$12			 	get address of 1st subdirectory block
				lda (zpt),y
				sta d_head+1		 	save as file's header block too
				tax
				
				dey
				lda (zpt),y
				sta d_head

				.DO LOWERCASE=1
				jsr XDOS.ReadGBufAXDir
				.ELSE
				jsr XDOS.ReadGBufAX		read subdirectory into XDOS.GBuf.
				.FIN
				bcs lookfil0.RTS		if error.

				lda XDOS.GBuf+37		get the # of files contained in this
				sta entcntl				directory.
				lda XDOS.GBuf+38
				sta entcnth
*--------------------------------------
* Check if $75 at VOL/DIR entry + $14
* (8 bytes reserved)
*--------------------------------------
				.DO LOWERCASE=0
				lda XDOS.GBuf+20		make sure password is disabled

				ldx #$00
				sec
				rol
L3869  			bcc L386C

				inx
L386C  			asl
				bne L3869

				cpx #$05				is password disabled?
				beq movhead

				lda #MLI.E.INCFF	 	directory is not compatible
				sec
				rts
				.FIN
*--------------------------------------
movhead  		jsr movhed0				move directory info.
				jmp lookfil0			do next local pathname.

movhed0			ldx #9					move this directory info

.1				lda XDOS.GBuf+$1C,x
				sta h_credt,x
				dex
				bpl .1

				.DO ACL=1
				ldx #7

				lda XDOS.GBuf+$14
				cmp #$57
				bne .20

				lda XDOS.GBuf+$15
				bne .20
				
.2				lda XDOS.GBuf+$14,x
				sta h_acl,x
				dex
				bpl .2
				
				bra .21

.20				stz h_acl,x
				dex
				bpl .20

.21				.FIN

				lda XDOS.GBuf+4			if this is root, then nothing to do
				and #$F0
				eor #$F0			 	test header type.
				beq .8				  	branch if root

				ldx #$03			 	otherwise, save owner info about

.3  			lda XDOS.GBuf+$27,x		this header.
				sta own_blk,x
				dex
				bpl .3

.8  			rts
*--------------------------------------
filfound 		lda h_maxent			figure out which entry # this is
				sec
				sbc cntent			 	max entries - count entries + 1
				adc #$00			 	= entry # (carry was set)
				sta d_entnum

				lda ZP.BLKNUM			and indicate block # of this directory
				sta d_entblk
				lda ZP.BLKNUM+1
				sta d_entblk+1

*				clc						done by ADC #$00

				rts
*--------------------------------------
XDOS.LookupNameInDirBlk
				lda h_maxent			reset count of files per block
				sta cntent

				jsr XDOS.ZPT.InitGBuf	reset indirect pointer to XDOS.GBuf

				bcs .4					branch if this block contains a header

.1				ldy #$00
				lda (zpt),y				get length of name in directory.
				bne .2					branch if there is a name.

				lda nofree				test if a free entry has been declared.
				bne .4				  	yes, inc to next entry.

				jsr filfound			set address for current entry.

				inc nofree				indicate a free spot has been found.
				bra .4

.2	 			and #$0F			 	strip byte (is checked by 'filfound')
				inc totent				inc count of valid files found.
				sta namcnt				save name length as counter.

				ldx namptr			 	get index to current path.
				cmp XDOS.PathBuf,x			are both names the same length?
				bne .4				  	no, inc to next entry.

.3		  		inx		 				(first) next letter index
				iny

				lda (zpt),y				compare names letter by letter	
				cmp XDOS.PathBuf,x
				bne .4

				dec namcnt			 	all letters compared?
				bne .3					no, continue.

				clc		 				a match is found.
.9	 			rts

.4	  			dec cntent				checked all entries in this block?
				sec
				beq .9				 	yes, no name match.

				jsr XDOS.ZPT.Next
				bra .1
*--------------------------------------
XDOS.FindVol	jsr XDOS.FindVolInVCBOrDev
				bcs novolume

				.DO ACL=1
				ldx #$4A
				.ELSE
				ldx #$42				zero out directory temps
				.FIN
				
.1  			stz own_blk,x			and owner info
				dex
				bpl .1

				lda GP.DEVNUM			 	setup device # for this directory
				sta d_dev
				jsr movhed0				setup other header info from directory

				ldy #$01			 	in XDOS.GBuf and clean up misc info.
				ldx XDOS.VCBPtr
				inx

.2  			lda XDOS.VCBs+VCB.TBLK,x		misc info includes
				sta h_tblk,y			total # of blocks,
				lda XDOS.VCBs+VCB.BMAP,x		the address of the 1st bitmap,
				sta h_bmap,y
				lda	ZP.BLKNUM,y			directory's disk address,
				sta d_head,y
				lda h_fcnt,y			and setting up a counter for the # of
				sta entcntl,y			files in this directory.
				dex
				dey
				bpl .2
*--------------------------------------				
nxtpname 		jsr nxtpnam1			get new namptr in y and namlen in acc.
				sty namptr			 	save new pathname pointer.
				rts		 				(status reg according to accumulator)
*--------------------------------------
nxtpnam1 		ldy namptr			 	inc pathname pointer to next name
				lda XDOS.PathBuf,y		in the path.
				sec
				adc namptr			 	if this addition results in zero,
				tay		 				then prefixed directory has been moved
				bne .1				  	to another device. branch if not.

				lda GP.DEVNUM			revise GP.DEVNUM for prefixed directory
				sta p_dev

.1	  			lda XDOS.PathBuf,y		test for end of name.
				clc						no errors
novolume 		rts
*--------------------------------------
XDOS.FindVolInVCBOrDev
				lda #$00
				ldy GP.PFXPTR				use prefix volume name to look up vcb.
				bit prfxflg				is this a prefixed path?
				bpl L396F			 	branch if it is

				tay		 				set ptr to volume name

L396F  			sty L39D4+1			  	and save.
				sta GP.DEVNUM			 	zero out dev# until vcb located.

				lda #XDOS.VCB0

L3975 			pha		 				acc now used as vcb lookup index.
				tax		 				index pointer to x.
				lda XDOS.VCBs,x				get vcb volume name length.
				bne L3987			  	branch if claimed vcb to be tested.

L397C 			ldy L39D4+1			  	restore pointer to requested vol name.
				pla		 				now adj vcb index to next vcb entry.
				clc
				adc #VCB
				bcc L3975			  	branch if more vcb's to check

				bcs L39D4			  	otherwise go look for unlogged volumes.

L3987  			sta namcnt			 	save length of vol name to be compared.

L398A  			cmp XDOS.PathBuf,y			is it the same as requested vol name?
				bne L397C			  	branch if not

				inx
				iny		 				next character
				lda XDOS.VCBs,x
				dec namcnt			 	last character?
				bpl L398A			  	if not.

				plx		 				restore pointer to matching vcb.
				stx XDOS.VCBPtr			 	save it for future reference.
				lda XDOS.VCBs+VCB.DEV,x		get it's device #
				sta GP.DEVNUM			 	and save it.
				
				lda #$02				assume prefix is not used and
				ldx #$00			 	that root directory is to be used.

				pha
				
				lda L39D4+1			  	= 0 if no prefix.

L39AC  			tay		 				if prefix then find ptr to prefixed
				sta namptr			 	dir name. save path ptr.
				beq L39C2			  	branch if no prefix.

				sec
				adc XDOS.PathBuf,y			inc to next dir in prefix path.
				bcc L39AC			  	branch if another dir in prefix.

				pla
				lda p_blok			 	volume verification will occur at
				pha
				ldx p_blok+1			subdirectory level.

* verify volume name

L39C2  			pla

				jsr XDOS.ReadGBufAX		read in directory (or prefix dir)
				bcs L39CC			  	if error then look on other devices.

				.DO LOWERCASE=1
				jsr XDOS.CheckAndUnpackGBuf
				bcs L39CC
				.FIN

				jsr XDOS.CheckVolName	compare dir name with path name.
				bcc L39F0			  	if they match, stop looking.

L39CC  			ldx XDOS.VCBPtr			 	check if current (matched) vcb is active
				lda XDOS.VCBs+VCB.OFCNT,x	i.e. does it have open files?
				bne L39ED			  	report not found if active.

L39D4  			lda #$FF				SELF MODIFIED vnptr : make path ptr same as volume ptr

				sta namptr
				jsr mvdevnums			copy all device #'s to be examined.
				lda GP.DEVNUM			 	log current device 1st before searching
				bne L39F1			  	others.

L39E2  			ldx GP.DEVCNT				scan look list for devices we need

L39E5  			lda loklst,x			to search for the requested volume.
				bne L39F4			  	branch if we've a device to look at.

				dex
				bpl L39E5			  	look at next one.

L39ED  			lda #MLI.E.VNOTFND	 	no mounted volume
				sec						error
L39F0  			rts

L39F1  			ldx GP.DEVCNT				now remove the device from the list

L39F4  			cmp loklst,x			of prospective devices.
				beq L39FE			  	branch if match.

				dex		 				look until found.
				bpl L39F4			  	always taken (usually) unless

				bmi L39ED			  	if dev was removed from GP.DEVLST (/RAM).

L39FE  			sta GP.DEVNUM			 	preserve device to be checked next.
				stz loklst,x			mark this one as tested.

				jsr XDOS.FindVCBForDevNum	find vcb that claims this dev (if any).
				bcs L3A29			  	branch if vcb full.

				lda XDOS.VCBs,x			 	did we find it or return free vcb?
				beq L3A16				if free vcb.

				lda XDOS.VCBs+VCB.OFCNT,x	is this volume active?
				bne L39E2			  	if so, no need to re-log.

L3A16  			lda #$02			 	go read root dir into XDOS.GBuf
				ldx #$00
				.DO LOWERCASE=1
				jsr XDOS.ReadGBufAXDir
				.ELSE
				jsr XDOS.ReadGBufAX
				.FIN
				bcs L39E2			  	ignore if unable to read.

				jsr XDOS.VCBMount
				bcs L39E2			  	look at next if non-xdos disk mounted.

				jsr XDOS.CheckVolName	is this the volume ?
				bcs L39E2			  	if not
L3A29  			rts
*--------------------------------------
mvdevnums 		ldx GP.DEVCNT				copy all dev #'s to be checked.

.1  			lda GP.DEVLST,x		   	active device list.
				and #$F0			 	strip device type info.
				sta loklst,x			copy them to a temp workspace
				dex
				bpl .1

				ldx GP.DEVCNT
				rts
*--------------------------------------
XDOS.FindVCBForDevNum
				lda #XDOS.VCB0			look for vcb for GP.DEVNUM
				ldy #$FF

.1  			tax						new index to next vcb
				lda XDOS.VCBs+VCB.DEV,x		check all devnums
				cmp GP.DEVNUM				is this the vcb?
				beq .7

				lda XDOS.VCBs,x				is this a free vcb?
				bne .3					if not

				iny
				bne .3					already found a free one

				stx XDOS.VCBPtr				save first free VCB
				
.3  			txa
				clc						inc index to next vcb
				adc #VCB
				bcc .1

				ldx XDOS.VCBPtr				get found free if any

				tya		 				any free vcb's available?
				bpl .8				  	yes, exit with X = XDOS.VCBPtr

				lda #XDOS.VCB0		 	look for an entry to kick out

.4  			tax
				lda XDOS.VCBs+VCB.OFCNT,x	any open files?
				beq .5				  	no, kick this one out.

				txa		 				next vcb
				clc
				adc #VCB
				bcc .4
				
				lda #MLI.E.VCBFULL		all vcb entries have open files
*				sec
				rts
				
.5  			stz XDOS.VCBs,x				free this entry
				stz XDOS.VCBs+VCB.DEV,x

.7				stx XDOS.VCBPtr			 	save entry index.
				
.8  			clc		 				no error.
				rts
*--------------------------------------
XDOS.CheckVolName
				ldx #$00			 	index to directory name.
				ldy namptr			 	index to pathname.

				lda XDOS.GBuf+4			 	get dir name length and type.
				cmp #$E0				is it a directory?
				bcc .1				  	if not.

				and #$0F			 	isolate name length and
				sta namcnt			 	save as a counter.
				bne .3				  	branch if valid length.

.1  			sec		 				indicate not found
				rts

.2  			lda XDOS.GBuf+4,x			next char
				
.3  			cmp XDOS.PathBuf,y
				bne .1				  	if not the same.

				inx		 				check next char
				iny
				dec namcnt
				bpl .2			  	if more to compare.

				clc		 				match found
XDOS.CheckVolName.RTS
				rts
*--------------------------------------
XDOS.VCBMount	ldx XDOS.VCBPtr			 	previously logged in volume?
				lda XDOS.VCBs,x				(acc = 0?)
				beq XDOS.VCBMountAtX  	no, go prepare vcb.

				jsr XDOS.VCBCmpGBUF	 	does vcb match vol read?
				bcc XDOS.CheckVolName.RTS			  	yes, do not disturb.

XDOS.VCBMountAtX
				ldy #VCB			 	zero out vcb entry

L3AB2  			stz XDOS.VCBs,x
				inx
				dey
				bne L3AB2
	
				lda XDOS.GBuf			 	pointer to previous dir block
				ora XDOS.GBuf+1			 	must be null
				bne tsterr

				lda XDOS.GBuf+4			 	test for header
				and #$E0
				cmp #$E0
				bne tsterr

				jsr tstdupvol			does a duplicate with open files
				bcs L3B04			 	already exist? branch if yes.

				lda XDOS.GBuf+4			 	move volume name to vcb.
				and #$0F			 	strip root marker
				tay
				pha
*				clc
				adc XDOS.VCBPtr
				tax

L3ACE  			lda XDOS.GBuf+4,y
				sta XDOS.VCBs,x
				dex
				dey
				bne L3ACE

				pla		 				get length again
				sta XDOS.VCBs,x				and save.

				lda GP.DEVNUM			 	last device used.
				sta XDOS.VCBs+VCB.DEV,x		save device # and

				ldy #0
				
.1				lda XDOS.GBuf+39,y
				sta XDOS.VCBs+VCB.BMAP,x		copy BMAP+TBLK
				iny
				inx
				cpy #4
				bne .1

L3B04  			clc		 				indicate logged if possible
				rts
				
tsterr 			lda #MLI.E.NOTPRODOS	not tree or dir, unrecognized type
				sec
				rts				
*--------------------------------------
XDOS.VCBCmpGBUF	lda XDOS.GBuf+4			with name in directory.
				and #$0F
				cmp XDOS.VCBs,x			are they the same length?
				stx .1+1				xvcbptr	: see rev note #23
				bne .9				  	if not the same.

				tay
				clc
.1				adc #$FF				xvcbptr : SELF MODIFIED
				tax

.2  			lda XDOS.GBuf+4,y
				cmp XDOS.VCBs,x
				bne .9				  	if not the same.

				dex
				dey
				bne .2

				clc		 				indicate match.
				.HS B0					BCS
.9				sec

				ldx .1+1				xvcbptr : offset to start of vcb (rev note #23)
				rts
*--------------------------------------
tstdupvol 		lda #XDOS.VCB0		 	check for other logged in volumes with the same name.

L3B2C  			tax
				jsr XDOS.VCBCmpGBUF
				bcs L3B41			  	if no match.

				lda XDOS.VCBs+VCB.OFCNT,x	test for any open files.
				bne L3B4B			  	cannot look at this volume.

				stz XDOS.VCBs,x			 	take duplicate offline if no open files
				stz XDOS.VCBs+VCB.DEV,x
*				clc					  	ok to log in new volume.
				rts

L3B41  			txa		 				index to next vcb
*				sec
				adc #VCB-1
				bcc L3B2C			  	branch if more to check

				clc
				rts

L3B4B  			sta XDOS.VCBDupFlag		duplicate has been found.
				stx XDOS.VCBDupEnt		save pointer to conflicting vcb.
				sec		 				error.
				rts
*--------------------------------------
tstfrblk 		ldx XDOS.VCBPtr			 	test if enough free blocks available for request.
				lda XDOS.VCBs+VCB.FBLK+1,x	check if proper count for this volume.
				ora XDOS.VCBs+VCB.FBLK,x
				bne L3BAD			  	branch if count is non-zero.

tkfrecnt 		jsr cntbms				get # of bitmaps
				sta bmcnt			  	and save.

				stz scrtch			 	start count at 0
				stz scrtch+1
				lda #$FF			 	mark 'first free' temp as unknown
				sta nofree

				jsr XDOS.FlushBM	 	update volume bitmap.
				bcs L3BC1			  	if error.

				ldx XDOS.VCBPtr			get address of 1st bitmap

				lda XDOS.VCBs+VCB.BMAP,x
				sta ZP.BLKNUM
				lda XDOS.VCBs+VCB.BMAP+1,x
				sta ZP.BLKNUM+1

L3B81  			jsr XDOS.ReadGBuf		use general buffer for temp space to
				bcs L3BC1			  	count free blocks (bits).

				jsr count
				dec bmcnt			  	was that the last bitmap?
				bmi L3B96			  	if so, go change fcb so not done again.

				inc ZP.BLKNUM
				bne L3B81

				inc ZP.BLKNUM+1
				bra L3B81

L3B96  			ldx XDOS.VCBPtr			mark which block had 1st free space
				lda nofree
				bmi L3BBE			 	if no free space was found.

				sta XDOS.VCBs+VCB.BMAPIDX,x		update the free count.

				lda scrtch+1
				sta XDOS.VCBs+VCB.FBLK+1,x		update volume control byte.
				lda scrtch
				sta XDOS.VCBs+VCB.FBLK,x
				
L3BAD  			lda XDOS.VCBs+VCB.FBLK,x		compare total available free blocks
				sec		 				on this volume.
				sbc reql
				lda XDOS.VCBs+VCB.FBLK+1,x
				sbc reqh
				bcc L3BBE

				clc
				rts

L3BBE  			lda #MLI.E.VOLFULL
				sec
L3BC1  			rts
*--------------------------------------
count			ldy #$00

L3BC4  			lda XDOS.GBuf,y				bit pattern.
				beq L3BCC			  	don't count

				jsr cntfree

L3BCC  			lda XDOS.GBuf+$100,y			do both pages with same loop
				beq L3BD4

				jsr cntfree
				
L3BD4  			iny
				bne L3BC4			  	loop until all 512 bytes counted.

				bit nofree			 	has 1st block w/free space been found?
				bpl L3BEE			  	if yes.

				lda scrtch			 	test to see if any blocks were counted
				ora scrtch+1
				beq L3BEE			  	branch if none counted.

				jsr cntbms			 	get total # of maps.
				sec		 				subtract countdown from total bitmaps
				sbc bmcnt
				sta nofree

L3BEE  			rts
*--------------------------------------
cntfree			asl			  			count the # of bits in this byte
				bcc L3BFA

				inc scrtch
				bne L3BFA

				inc scrtch+1

L3BFA  			ora #$00
				bne cntfree				loop until all bits counted
				rts
*--------------------------------------
cntbms			ldx XDOS.VCBPtr
				ldy XDOS.VCBs+VCB.TBLK+1,x	return the # of bitmaps
				lda XDOS.VCBs+VCB.TBLK,x		possible with the total count
				bne L3C0B			  	found in the vcb.

				dey						adj for bitmap block boundary

L3C0B  			tya

				lsr			  			divide by 16. the result is
				lsr			  			the # of bitmaps.
				lsr
				lsr
				rts
*--------------------------------------
MAN
SAVE usr/src/prodos.fx/prodos.s.xdos.b
LOAD usr/src/prodos.fx/prodos.s
ASM
