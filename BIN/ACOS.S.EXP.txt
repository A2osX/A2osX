NEW
  AUTO 3,1
				.LIST OFF
*--------------------------------------
* In: A = current CHAR
* Out: CC, longint on stack or pSTR in stack
*--------------------------------------
EXP.Eval		stz EXP.TYPE

EXP.Eval.R		lda EXP.AOPS
				pha

				lda #$FF
				>PUSHA					Previous OP = none
*--------------------------------------
.10				jsr CORE.GetCharNB
				bcs .39
	
.11				cmp #'('
				bne .12
				
				jsr CORE.GetNextCharNB	skip (
				bcs .39
				
				jsr EXP.Eval.R
				bcs .39

				jsr CORE.GetCharNB
				bcs .39

				cmp #')'
				sec
				bne .39

				jsr CORE.GetNextCharNB	skip )
				bra .41
				
.12				cmp #'"'
				bne .20
				
				jsr EXP.CreateStrConst
				bcs .99
				
				bra .40
*--------------------------------------
.20				jsr CORE.IsLetter
				bcs .30					FN or VAR

				>LDYA L.ACOS.FN
				jsr CORE.Lookup

				bcs .21

				jsr EXP.FNjmpX
				bcs .99

				bra .40

.21				jsr EXP.VARLookup
				bcs .99

				ldx EXP.TYPE
				bne .22
				
				jsr CODE.INTGET

				bra .40
				
.22				jsr CODE.STRGET

				bra .40
*--------------------------------------
.30				jsr CORE.IsDigit10
.39				bcs .90

				jsr EXP.Int16
				bcs .99
*--------------------------------------
.40				jsr CORE.GetCharNB
.41				bcs .80

.50				jsr CORE.IsEndExp
				bcs .80
	
				jsr CORE.LookupOPS
				bcs .90
				
				stx EXP.AOPS

.61				lda (pStack)			get op context
				bmi .62					no prev op, go get arg2
				
				cmp EXP.AOPS			we have arg1 A=op1 arg2 X=op2
				bcc .62
				
				inc pStack				prev op has precedence
				
				tay
				ldx ACOS.OPS.MAP-1,y
				jsr CODE.FPUCALL		go compute (arg1 op1 arg2)
				
.62				lda EXP.AOPS			we must compute arg2 op2 arg3 before
				>PUSHA

.63				jsr CORE.GetNextCharNB
				bcs .90
				jmp .11
*--------------------------------------
.80				>PULLA
				tay
				bmi .88					nothing to do

				ldx ACOS.OPS.MAP-1,y
				jsr CODE.FPUCALL
				bra .80

.90				lda #E.ESYN
				
.99				tay						Save Err code

.98				>PULLA
				tax
				bpl .98
				
				sec
				.HS 90					BCC
.88				clc

				pla
				sta EXP.AOPS
				
				tya
				
				rts
*--------------------------------------
EXP.FNjmpX		 jmp (J.ACOS.FN,x)
*--------------------------------------
EXP.CreateStrConst
				lda #'$'
				sta EXP.TYPE
				
				ldy #0
				
.1				jsr CORE.GetNextChar
				bcs .91
				
				cmp #'"'
				beq .2
				
				sta (ZPConstBufPtr),y
				iny
				bne .1
				
.2				lda #0
				sta (ZPConstBufPtr),y

				phy
				>LDYA ZPConstBufPtr
				jsr CODE.PUSHIYA

				pla
				sec						for \0
				adc ZPConstBufPtr
				sta ZPConstBufPtr
				bcc .3
				
				inc ZPConstBufPtr+1

.3				jsr CORE.GetNextCharNB	skip "

				clc
				rts
				
.91				lda #E.ESYN
*				sec
				rts
*--------------------------------------
EXP.Int16		>PUSHW ZPInputBufPtr
				>PUSHWI ZPInputBufPtr
				>PUSHBI 10
				>SYSCALL StrToL
				bcs .9

				jsr CODE.PUSHINT16
				
				>POP 4

				clc
				
.9				rts				
*--------------------------------------
EXP.VARLookup	>LDA.G hVars

				>PUSHA
				>PUSHA					for SListGetData

				>PUSHW ZPInputBufPtr
				>SYSCALL SListLookup
				bcs .9

				>PUSHYA					 ZPSID

				txa
				jsr CORE.SkipA

.1				>PUSHWI EXP.ADDR
				>PUSHWI 3				3 bytes : ADDR + TYPE
				>PUSHWZ					From Start
				>SYSCALL SListGetData
				bcs .99

				ldx #0
				
				jsr CORE.GetChar
				bcs .2

				cmp #'$'
				bne .2
				
				tax

				jsr CORE.GetNextChar	skip $
				
.2				cpx EXP.TYPE
				bne .90
				
				clc
				rts

.9				>PULLA
.99				rts

.90				lda #E.TMISMATCH
				sec
				rts
*--------------------------------------
*--------------------------------------
MAN
SAVE usr/src/bin/acos.s.exp
LOAD usr/src/bin/acos.s
ASM
