NEW
PREFIX
AUTO 4,1
				.LIST OFF	
*--------------------------------------
CMD.NOHUP		>LDA.G CORE.PSFlags
				ora #S.PS.F.NOHUP
				sta (pData),y
				
				>LDYA ZPArgVBuf
				jmp CORE.ExecExtCmd
*--------------------------------------
CMD.SHIFT		lda #1

CMD.SHIFTA		>SYSCALL ArgV
				bcs .8
				
				jsr RemoveStrFromArgV
				
.7				ldy #S.PS.ARGC
				lda (pPS),y
				dec
				sta (pPS),y
				
.8				clc
				rts
*--------------------------------------
CMD.PUSHD		>LDA.G PUSHD.STACK
				cmp #PUSHD.STACK+PUSHD.STACK.MAX
				beq CMD.POPD.CSYN
				
				ldy #S.PS.hPREFIX
				lda (pPs),y
				>SYSCALL GetMemPtr
				>SYSCALL strdup
				bcs CMD.POPD.CSYN
				
				>INC.G PUSHD.STACK
				tay
				txa
				sta (pData),y
				
				lda (ZPArgVBufPtr)
				bne CMD.CD.0
				
.8				clc
.9				rts
*--------------------------------------
CMD.POPD		>LDA.G PUSHD.STACK
				cmp #PUSHD.STACK
				beq CMD.POPD.CSYN
				
				tay
				lda (pData),y
				jsr CMD.SetPrefixA
				
				>DEC.G PUSHD.STACK
				clc
CMD.POPD.RTS				
				rts
				
CMD.POPD.CSYN	jmp CMD.Exec.CSYN
*--------------------------------------
CMD.PWD			ldy #S.PS.hPREFIX
				lda (pPs),y
				>SYSCALL GetMemPtr
				>SYSCALL puts
				rts
*--------------------------------------
CMD.CD			lda (ZPArgVBufPtr)
				beq CMD.CD.HOME

CMD.CD.0		>LDYA ZPArgVBufPtr
				bra CMD.CD.1

CMD.CD.HOME 	>LDYA L.ENV.HOME
				>SYSCALL GetEnv
				bcc CMD.CD.1
				
				>LDYA L.ENV.ROOT
				>SYSCALL GetEnv
				bcs CMD.PWD
				
CMD.CD.1		>SYSCALL realpath
				bcs CMD.POPD.RTS
				
				>STYA ZPPtr1
				stx M32.TMP				Save hMem
				
				ldy #1
				lda (ZPPtr1),y
				bne .12

				txa
				jmp CMD.SetPrefixA		we have '/'

.12				>PUSHEA.G StatBuf
				>LDYA ZPPtr1
				>SYSCALL STAT

				bcs .19

.10				>LDA.G StatBuf+S.STAT.P.TYPE
				cmp #S.FI.T.DIR
				beq .11
				
				lda #MLI.E.INVPATH
				
.19				pha
				lda M32.TMP
				>SYSCALL freemem
				pla
				sec
				rts

.11				ldy #$ff
				
.1				iny
				lda (ZPPtr1),y
				bne .1
				
				dey
				lda (ZPPtr1),y
				cmp #'/'
				bne .14

				lda M32.TMP
				jmp CMD.SetPrefixA	already ends with a /

.14				iny
				iny
				lda #0
				>SYSCALL getmem
				bcs .19
				>STYA ZPPtr2

				ldy #$ff
				
.2				iny
				lda (ZPPtr1),y
				lda (ZPPtr2),y
				bne .2
				
				iny
				sta (ZPPtr2),y
				dey
				lda #'/'
				sta (ZPPtr2),y
				phx
				lda M32.TMP
				>SYSCALL freemem
				pla
*--------------------------------------
CMD.SetPrefixA	pha
				ldy #S.PS.hPREFIX
				lda (pPs),y
				>SYSCALL FreeMem
				
				pla
				
				ldy #S.PS.hPREFIX
				sta (pPs),y
				lda #0
*				clc
				rts
*--------------------------------------
CMD.Exec.CSYN	lda #E.CSYN
				sec
				rts
*--------------------------------------
CMD.SET			lda (ZPArgVBufPtr)
				bne CMD.SET.1

* No arg, print all ENV

				ldy #S.PS.hENV
				lda (pPs),y
				>SYSCALL GetMemPtr
				>STYA ZPPTR1

.1				lda (ZPPTR1)
				beq .8					Ending 0 ?

				ldy #$ff

.2				iny
				lda (ZPPTR1),y
				bne .2

				tya
				sec
				adc ZPPTR1
				sta ZPPTR2
				lda #0
				adc ZPPTR1+1
				sta ZPPTR2+1
				
				>PUSHW ZPPTR2			Push value
				>PUSHW ZPPTR1			Push name
				jsr CMD.SET.PRINT

				bcs .9

				ldy #$ff
				
.3				iny
				lda (ZPPTR2),y
				bne .3
				
				tya
				sec
				adc ZPPTR2
				sta ZPPTR1
				lda #0
				adc ZPPTR2+1
				sta ZPPTR1+1
				bra .1
				
.8				clc
.9				rts
*--------------------------------------
* SET +X VAR = VALUE1 op VALUE2 op VALUE3 ...
*--------------------------------------
CMD.SET.1		
.1				jsr CMD.IsSwitch
				bcs .6
				
				cmp #'C'
				bne .2
				
				ldy #bSET.C
				bra .5
				
.2				cmp #'X'
				bne .3
				
				ldy #bSET.X
				bra .5
				
.3				cmp #'E'
				bne .4
				
				ldy #bSET.E
				bra .5
				
.4				cmp #'F'
				bne .99
				
				jsr CORE.FUNCRESET
				bra .50
				
.5				lda (pData),y
				eor #$ff
				sta (pData),y
.50				jsr CORE.ArgV.Next
				bne .1
				clc
				rts
				
.6				>LDYA ZPArgVBufPtr
				>STYA ZPVarNamePtr

				jsr CORE.ArgV.Next
				beq CMD.SET.GET
				
				cmp #'='
				bne .99
				
				ldy #1
				lda (ZPArgVBufPtr),y
				bne .99
				
				jsr CORE.ArgV.Next
				beq CMD.SET.UNSET
				
				cmp #'`'
				beq CMD.SET.EXEC
				
				jsr EXP.GET
				bcs .9
				
				>PUSHYA
				>LDYA ZPVarNamePtr
				>SYSCALL SetEnv
				rts

.8				clc
.9				rts
				
.99				jmp CMD.Exec.CSYN
				
CMD.SET.UNSET	>LDYA ZPVarNamePtr
				>SYSCALL UnsetEnv
				rts

CMD.SET.GET		>LDYA ZPVarNamePtr
				>SYSCALL GetEnv
				bcc .1
				clc
				rts
				
.1				>PUSHYA					push value
				>LDYA ZPVarNamePtr
				>PUSHYA 				push name
*--------------------------------------
CMD.SET.PRINT	>PUSHBI 4
				>LDYA L.MSG.PRINTENV
				>SYSCALL printf
				rts
*--------------------------------------
CMD.SET.EXEC	jsr CORE.ArgV.NextChar	skip "`"

				jsr IO.Pipe.Out
				bcs .9

				>PUSHBI S.PS.F.DUPENV
				>LDYA ZPArgVBufPtr
				>SYSCALL execl
				bcs .9
				jsr IO.Pipe.In
				bcs .9
				
				lda #$ff
				>STA.G bREAD.S			secret
				>STA.G bReadMode
				
				>SLEEP
				clc
.9				rts
*--------------------------------------
CMD.DATE		sec
				.HS 90					bcc
CMD.TIME		clc
				php
				>LEA.G TimeBuf
				>SYSCALL Time

				>PUSHEA.G TimeBuf
				
				plp
				bcc .1
				>PUSHW L.FMT.DATE
				bra .2
.1				>PUSHW L.FMT.TIME

.2				>LEA.G StatBuf
				>SYSCALL StrFTime
				
				>LEA.G StatBuf
				>SYSCALL puts
				rts
*--------------------------------------
CMD.ECHO		stz ZPPtr1				echo -N
				stz ZPPtr1+1			Token Cnt

				lda (ZPArgVBufPtr)
				beq .7

.1				jsr CMD.IsSwitch
				bcs .2
				
				cmp #'N'
				bne .99

				lda #$ff
				eor ZPPtr1
				sta ZPPtr1
				bra .4		
				
.2				lda ZPPtr1+1
				beq .3
				
				lda #C.SPACE
				>SYSCALL putchar
				
.3				>PUSHBI 0
				>LDYA ZPArgVBufPtr
				>SYSCALL printf
				bcs .9
				
				inc ZPPtr1+1
				
.4				jsr CORE.ArgV.Next
				bne .1
				
.7				bit ZPPtr1
				bmi .8

				>PUSHBI 0
				>LDYA L.MSG.ECHOCRLF
				>SYSCALL printf
				rts

.8				clc
				rts

.99				lda #E.CSYN
				sec
.9				rts
*--------------------------------------
CMD.GETKEY		lda (ZPArgVBufPtr)
				beq .99

				ldy #S.PS.hStdIn
				lda (pPS),y
				>SYSCALL feof
				bcs .9
				tay
				beq .1
				
				>SYSCALL getchar
				bcs .9
	
.1				>PUSHA
				>PUSHBI 1
				>PUSHW L.FMT.GETKEY
				>LEA.G M32.BUF
				>SYSCALL sprintf
				bcs .9
				
				>PUSHEA.G M32.BUF
								
				>LDYA ZPArgVBufPtr
				>SYSCALL SetEnv
.9				rts
				
.99				jmp CMD.Exec.CSYN
*--------------------------------------
CMD.READ		lda (ZPArgVBufPtr)
				beq .9 

.1				jsr CMD.IsSwitch
				bcs .4
				cmp #'S'
				bne .2
				
				lda #$ff
				>STA.G bREAD.S
				
				bra .7
				
.2				cmp #'P'			
				bne .9
				
				jsr CORE.ArgV.Next
				beq .9

				>PUSHBI 0
				>LDYA ZPArgVBufPtr
				>SYSCALL printf
				bcs .99
				bra .7
				
.4				>LDYA ZPArgVBufPtr
				>STYA ZPVarNamePtr

				>LDA.G bReadMode
				bne .9
				lda #$ff
				>STA.G bReadMode
				
.7				jsr CORE.ArgV.Next
				bne .1
				
				>LDA.G bReadMode
				beq .9
				clc
.99				rts
				
.9				jmp CMD.Exec.CSYN
*--------------------------------------
CMD.SLEEP		lda (ZPArgVBufPtr)
				beq .9

				>LDYA ZPArgVBufPtr
				>SYSCALL AToL
				bcs .9

				>PULLL.G Sleep
				clc
				rts
				
.9				jmp CMD.Exec.CSYN
*--------------------------------------
CMD.PAUSE		lda #$FF
				>STA.G bPause
				clc
				rts
*--------------------------------------
CMD.EXIT		lda (ZPArgVBufPtr)
				beq .8					no arg, exit 0

				>LDYA ZPArgVBufPtr
				>SYSCALL AToL
				bcs .9

				>PULLL M32.ACC
				lda M32.ACC
				
.8				pha
				lda #$FF
				>STA.G bExit
				pla
				clc
.9				rts
*--------------------------------------
CMD.MD			lda (ZPArgVBufPtr)
				beq .9

				>LDYA ZPArgVBufPtr
				>SYSCALL MKDir
				rts
				
.9				jmp CMD.Exec.CSYN
*--------------------------------------
CMD.REN			lda (ZPArgVBufPtr)
				beq .9
				>PUSHW ZPArgVBufPtr

				jsr CORE.ArgV.Next
				lda (ZPArgVBufPtr)
				beq .90
				
				>LDYA ZPArgVBufPtr
				>SYSCALL Rename
				rts
				
.90				>PULLYA				
.9				jmp CMD.Exec.CSYN
*--------------------------------------
CMD.RD			lda (ZPArgVBufPtr)
				beq .9
				
				>PUSHEA.G StatBuf
				>LDYA ZPArgVBufPtr
				>SYSCALL STAT
				bcs .99
				
				>LDA.G StatBuf+S.STAT.P.TYPE
				cmp #S.FI.T.DIR
				bne .9
				
				>LDYA ZPArgVBufPtr
				>SYSCALL Remove
.99				rts
				
.9				jmp CMD.Exec.CSYN
*--------------------------------------
CMD.FUNC		lda (ZPArgVBufPtr)
				beq .9
				
				jsr CORE.StkGetCtx
				bcc .9					NO context allowed

				>LDA.G hFuncList
				bne .1
				
				>SYSCALL SListNew
				bcs .99
				>STA.G hFuncList
				
.1				>PUSHW ZPArgVBufPtr
				>LDA.G hFuncList
				>SYSCALL SListNewKey
				bcs .99
				phy
				jsr CORE.StkPush
				ply
				bcs .99
				tya
				jsr CORE.StkPush
				bcs .99

				lda #$C0+C.FUNC
				jsr CORE.StkPush
				bcs .99
				
				lda #$ff
				>STA.G bFuncMode
				clc
.99				rts
				
.9				jmp CMD.Exec.CSYN
*--------------------------------------
CMD.RETURN		jsr CORE.RETURN
				bcs .9
				
				lda (ZPArgVBufPtr)
				beq .8					no arg, exit 0

				>LDYA ZPArgVBufPtr
				>SYSCALL AToL
				bcs .9

				>PULLL M32.ACC
				lda M32.ACC
				
.8				clc
.9				rts
*--------------------------------------
CMD.CALL		>LDA.G hFuncList
				beq .9

				>PUSHW ZPArgVBufPtr
				>LDA.G hFuncList
				>SYSCALL SListLookup
				bcs .9
				
				>STYA M32.TMP			KeyID

				>PUSHWI 0				From Start
				>PUSHWI $ffff			all
				>PUSHWI 0				Allocate..
				>PUSHW M32.TMP			KeyID
				>LDA.G hFuncList
				>SYSCALL SListGetData
				bcs .99

				>LDYA ZPArgVBufPtr		FUNC PARAM1 PARAM2...
				jmp CORE.CALL			X = Func Code
				
.9				lda #E.FUNDEF
				sec
.99				rts
*--------------------------------------
CMD.BREAK		jsr CORE.StkGetCtx		Get context in CORE.Test
				bcs .9
				
				tax
				and #$3F
				cmp #C.CASE
				bne .9
				
				txa
				bpl .8
				
				jsr CORE.StkPull		remove C.CASE
				jsr CORE.StkGet
				and #$7F
				sta (pDATA),y
.8				clc
				rts

.9				jmp CMD.Exec.CSYN
*--------------------------------------
* stack-1		hVALUE
* stack			SWITCH TOKEN
*--------------------------------------
CMD.SWITCH		jsr CORE.StkGetCtx

				jsr EXP.GET
				bcs .9
				>SYSCALL strdup
				bcs .9

				txa
				jsr CORE.StkPush		Push EXP hVALUE
				bcs .9

				>LDA.G CORE.Test
				beq .1
				
				ora #$80
				
.1				ora #C.SWITCH
				jmp CORE.StkPush
				
.9				rts
*--------------------------------------
CMD.CASE		jsr CORE.StkGetCtx		Get context in CORE.Test

				bcs .9
				
				tax 
				
				and #$3F
				cmp #C.SWITCH
				beq .1
				
				cmp #C.CASE
				bne .9
				
				txa						previous case was true ?
				bpl  .10
				
				jsr EXP.GET				skip expression
				bcs .9
				rts						keep existing context
				
.10				jsr CORE.StkPull		remove previous C.CASE
				bra CMD.CASE
				
.1				jsr EXP.GET
				bcs .9
				
				>PUSHYA
				
				lda (pDATA)
				tay
				dey						get hVALUE
				lda (pDATA),y
				>SYSCALL GetMemPtr
				>SYSCALL strcmp
				ror						CS if !=
				and #$80
				eor #$80
				>ORA.G CORE.Test
				ora #C.CASE
				jmp CORE.StkPush
				
.9				jmp CMD.Exec.CSYN
*--------------------------------------
CMD.DEFAULT		jsr CORE.StkGetCtx		Get context in CORE.Test
				bcs .9

				and #$3F
				cmp #C.SWITCH
				beq .1
				
				cmp #C.CASE
				bne .9
				
				jsr CORE.StkPull		remove C.CASE

.1				jsr CORE.StkGet
				and #$C0
				ora #C.DEFAULT
				jmp CORE.StkPush
				
.9				jmp CMD.Exec.CSYN
*--------------------------------------
CMD.END			jsr CORE.StkGetCtx		Get context in CORE.Test
				bcs CMD.END.CSYN
				
				and #$3F
				cmp #C.FUNC
				beq CMD.END.FUNC

				cmp #C.SWITCH
				beq .2
				
				cmp #C.CASE
				beq .1
				
				cmp #C.DEFAULT
				bne CMD.END.CSYN
				
.1				jsr CORE.StkPull		remove C.CASE,C.DEFAULT
				
.2				jsr CORE.StkPull		remove C.SWITCH
				jsr CORE.StkPull		get hVALUE
				>SYSCALL freemem			
				rts
							
CMD.END.FUNC	jsr CORE.StkPull		remove C.FUNC
				jsr CORE.StkPull		remove KeyID
				jmp CORE.StkPull		remove KeyID
				
CMD.END.CSYN	jmp CMD.Exec.CSYN
*--------------------------------------
CMD.FOR			jsr CORE.StkGetCtx

				lda (ZPArgVBufPtr)
				beq CMD.END.CSYN

				>LDYA ZPArgVBufPtr
				>STYA ZPVarNamePtr

				jsr CORE.ArgV.Next
				beq CMD.END.CSYN
				
				jsr ToUpperCase
				cmp #'I'
				bne CMD.END.CSYN
				
				ldy #1
				lda (ZPArgVBufPtr),y
				beq CMD.END.CSYN
				
				jsr ToUpperCase
				cmp #'N'
				bne CMD.END.CSYN
				
				iny 
				lda (ZPArgVBufPtr),y
				bne CMD.END.CSYN

				jsr CORE.ArgV.Next
				beq CMD.END.CSYN

				cmp #'('
				beq FOR.FILE
				
				cmp #'`'
				bne FOR.LIST

				jmp FOR.EXEC
*--------------------------------------
FOR.LIST		sec
				jsr CORE.StkPushPtr		Push CmdPtr AFTER FOR
				bcs .99
				
				>LDYA ZPArgVBufPtr
				>SYSCALL strdup
				bcs .99
				
				phy
				jsr CORE.StkPush		Push listPtr
				ply
				bcs .99		
				tya
				jsr CORE.StkPush		Push listptr
				bcs .99		
				
				txa
				jsr CORE.StkPush		Push hLIST
				bcs .99		

				>LDYA ZPVarNamePtr
				>SYSCALL strdup
				bcs .99

				txa
				jsr  CORE.StkPush		Push hVARNAME
				bcs .99
				
				lda #C.FOR.LIST
				jsr CORE.StkPush
				bcs .99
				
				lda #C.FOR
				jsr CORE.StkPush
				bcs .99

				jsr CMD.NEXT.LIST.1
				bcs .99 
				
				>ORA.G CORE.Test
				ora #C.FOR				Push FOR
				pha
				lda (pData)
				tay
				pla
				sta (pData),y

*				clc
				
.99				rts
*--------------------------------------
FOR.FILE		sec
				jsr CORE.StkPushPtr		Push CmdPtr AFTER FOR
				bcs .99

				jsr CORE.ArgV.NextChar	skip "("

				>PUSHWI 0				Aux type
				>PUSHBI S.FI.T.TXT
				>PUSHBI	O.RDONLY+O.TEXT

				>LDYA ZPArgVBufPtr
				>SYSCALL fopen
				bcs .99
				jsr CORE.StkPush		push hFILE
				bcs .99				
				
				>LDYA ZPVarNamePtr
				>SYSCALL strdup
				bcs .99

				txa
				jsr CORE.StkPush		Push hVARNAME
				bcs .99

				lda #C.FOR.FILE
				jsr CORE.StkPush
				bcs .99
				
				lda #C.FOR
				jsr CORE.StkPush
				bcs .99

				jsr CMD.NEXT.LINE
				bcs .99 
				
				>ORA.G CORE.Test
				ora #C.FOR				Push FOR
				pha
				lda (pData)
				tay
				pla
				sta (pData),y
				
*				clc
				
.99				rts				
*--------------------------------------
FOR.EXEC		sec
				jsr CORE.StkPushPtr		Push CmdPtr AFTER FOR
				bcs .9

				jsr CORE.ArgV.NextChar	skip "`"

				jsr IO.Pipe.Out
				bcs .99

				>PUSHBI S.PS.F.DUPENV
				>LDYA ZPArgVBufPtr
				>SYSCALL execl
				bcs .99	
				
				>LDA.G IO.hOut
				ldy #S.PS.hStdOut
				sta (pPS),y
				
				>STZ.G IO.hOut

				>PUSHWI 0				auxtype
				>PUSHBI 0				type
				>PUSHBI O.RDONLY+O.TEXT
				>LEA.G IO.NodBuf
				>SYSCALL fopen
.9				bcs .99

				jsr CORE.StkPush		push hPIPE
				bcs .99				
				
				>LDYA ZPVarNamePtr
				>SYSCALL strdup
				bcs .99

				txa
				jsr CORE.StkPush		Push hVARNAME
				bcs .99

				lda #C.FOR.EXEC
				jsr CORE.StkPush
				bcs .99
				
				lda #C.FOR
				jsr CORE.StkPush
				bcs .99

				jsr CMD.NEXT.LINE
				bcs .99 
				
				>ORA.G CORE.Test
				ora #C.FOR				Push FOR
				pha
				lda (pData)
				tay
				pla
				sta (pData),y
				
*				clc

.99				rts
*--------------------------------------
CMD.NEXT		jsr CORE.StkGet			Y = StkPtr

				bcs .9
				and #$3F
				cmp #C.FOR
				bne .9
				
				dey
				lda (pData),y
				tax
				iny
				jmp (J.NEXT,x)
				
.9				lda #E.NOFOR
				sec
				rts
*--------------------------------------
* stack-6		CmdPtr
* stack-4		ListPtr
* stack-3		hLIST
* stack-2       hVARNAME
* stack-1		FOR SUB TOKEN
* stack			FOR TOKEN
*--------------------------------------
CMD.NEXT.LIST	lda (pData),y			Y = StkPtr
				
				bpl .1
				
				jsr CMD.NEXT.LIST.1
				bcs .9
				bpl .1
				
				lda (pData)
				sec
				sbc #6
				tay

				lda (pData),y
				sta ZPInputBufPtr+1
				dey
				lda (pData),y
				sta ZPInputBufPtr
				
				clc
				rts
				
.1				lda (pData)
				tay
				sec
				sbc #8
				sta (pData)
				
				dey
				dey						
				lda (pData),y			hVARNAME
				pha
				dey
				lda (pData),y			hLIST
				>SYSCALL freemem
				pla
				>SYSCALL freemem
				
				clc
.9				rts
*--------------------------------------
CMD.NEXT.LIST.1	lda (pData)
				dec						skip FOR
				dec						skip SUB TOKEN

				tay
				lda (pData),y
				phy
				>SYSCALL GetMemPtr		hVARNAME
				>STYA ZPVarNamePtr
				ply

				dey						skip hLIST
				
				dey
				lda (pData),y
				sta ZPPtr1
				
				dey
				lda (pData),y
				sta ZPPtr1+1
				
				ldy #0
				
.10				lda (ZPPtr1)
				beq .3
				
				inc ZPPtr1
				bne .11
				inc ZPPtr1+1
				
.11				cmp #C.SPACE
				beq .10
				
				sta (ZPCLBuf),y
				iny
				
.1				lda (ZPPtr1)
				beq .3

				inc ZPPtr1
				bne .2
				inc ZPPtr1+1

.2				cmp #C.SPACE
				beq .3
				
				sta (ZPCLBuf),y
				iny
				bra .1
				
.3				lda #0				
				sta (ZPCLBuf),y

				tya
				beq .8
				
				>PUSHW ZPCLBuf
				>LDYA ZPVarNamePtr
				>SYSCALL SetEnv
				bcs .9

				lda (pData)
				sec
				sbc #4
				tay
				lda ZPPtr1
				sta (pData),y
				dey
				lda ZPPtr1+1
				sta (pData),y
				lda #$80
				clc
				rts
				
.8				>LDYA ZPVarNamePtr
				>SYSCALL UnSetEnv
				bcs .9
				
				lda #0
*				clc
.9				rts
*--------------------------------------
* stack-4		CmdPtr
* stack-3		hFILE
* stack-2       hVARNAME
* stack-1		FOR SUB TOKEN		
* stack			FOR TOKEN
*--------------------------------------
CMD.NEXT.FILE
*--------------------------------------
* stack-4		CmdPtr
* stack-3		hPIPE
* stack-2       hVARNAME
* stack-1		FOR SUB TOKEN		
* stack			FOR TOKEN
*--------------------------------------
CMD.NEXT.EXEC	lda (pData),y			Y = StkPtr
				
				bpl .1
				
				jsr CMD.NEXT.LINE
				bcs .9
				bpl .1
				
				lda (pData)
				sec
				sbc #4
				tay

				lda (pData),y
				sta ZPInputBufPtr+1
				dey
				lda (pData),y
				sta ZPInputBufPtr
				
				clc
				rts
				
.1				lda (pData)
				tay
				sec
				sbc #6
				sta (pData)
				
				dey
				dey						
				lda (pData),y			hVARNAME
				pha
				dey
				lda (pData),y			hFILE/hPIPE
				>SYSCALL fclose
				pla
				>SYSCALL freemem
*				clc
.9				rts
*--------------------------------------
CMD.NEXT.LINE	lda (pData)
				dec						skip FOR
				dec						skip SUB TOKEN

				tay
				lda (pData),y
				phy
				>SYSCALL GetMemPtr		hVARNAME
				>STYA ZPVarNamePtr
				ply

	
				dey
				lda (pData),y			hPIPE
				pha
				>PUSHWI 256
				>PUSHW ZPCLBuf
				pla

				>SYSCALL fgets
				bcs .8
				
				>PUSHW ZPCLBuf
				>LDYA ZPVarNamePtr
				>SYSCALL SetEnv
				bcs .9

				lda #$80
*				clc
				rts
				
.8				>LDYA ZPVarNamePtr
				>SYSCALL UnSetEnv
				bcs .9
				
				lda #0
*				clc
.9				rts
*--------------------------------------
CMD.WHILE	
CMD.IF			jsr CORE.StkGetCtx

				bit #$40				Parent is true ?
				beq .3

				jsr EXP.TEST
				bcs .9

.3				>LDA.G CORE.IntCmd
				cmp #C.WHILE
				bne .8
				
				clc
				jsr CORE.StkPushPtr		Push BEFORE WHILE/IF
				bcs .9
				
.8				>LDA.G CORE.Test
				>ORA.G CORE.IntCmd
				jmp CORE.StkPush
				
				clc
.9				rts
*--------------------------------------
CMD.LOOP		jsr CORE.StkPull
				bcs .9
				tax
				and #$3F
				cmp #C.WHILE
				bne .9
				
				txa
				bmi .8
								
				lda (pData)
				sec
				sbc #2					Discard loop Ptr
				sta (pData)

				clc				
				rts

.8 				jmp CORE.StkPullPtr
				
.9				lda #E.NOWHILE
				sec
				rts				
*--------------------------------------
CMD.ELSE		jsr CORE.StkGet
				bcs .9

				bit #$40				parent is true ?
				beq .8					no, skip

				tax
				and #$3F
				cmp #C.IF
				bne .9
				txa
				eor #$80				toggle and store at stack ptr
				sta (pData),y
				
.8				clc
				rts
				
.9				lda #E.NOIF
				sec
				rts
*--------------------------------------
CMD.FI			jsr CORE.StkPull
				bcs .9
				
				and #$3F
				cmp #C.IF
				bne .9
				
				clc
				rts
				
.9				lda #E.NOIF
				sec
				rts
*--------------------------------------
CMD.IsSwitch	lda (ZPArgVBufPtr)
				cmp #'-'
				bne .9
				
				ldy #1
				lda (ZPArgVBufPtr),y
				beq .9
				
				cmp #'0'				is -0 ... -9 ?
				bcc .9
				cmp #'9'+1
				bcc .9
				
.1				tax
				iny
				lda (ZPArgVBufPtr),y
				bne .9
				
				txa
				jmp ToUpperCase
				
.9				sec				
				rts
*--------------------------------------
MAN
SAVE USR/SRC/BIN/SH.S.CMD
LOAD USR/SRC/BIN/SH.S
ASM
