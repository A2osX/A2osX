NEW
PREFIX
AUTO 4,1
				.LIST OFF	
*--------------------------------------
CORE.Init		>LDYAI 256
				>SYSCALL GetMem
				bcs .9
				>STYA ZPArgVBuf
				txa
				>STA.G CORE.hArgVBuf
.9				rts				
*--------------------------------------
CORE.Quit		>LDA.G CORE.hArgVBuf
				beq .9
				>SYSCALL FreeMem

.9				rts	
*--------------------------------------
* Input : ZPCLBuf/ZPFileBufPtr
* Get Line from buf until ;, CR, \0 (EOL / EOF) -> ZPArgVBuf
* Tokenize ZPArgVBuf
*--------------------------------------
CORE.GetCmdFromFile
				>LDYA ZPFileBufPtr
				>STYA ZPFileBufPtrBak
				
				lda (ZPFileBufPtr)
				beq .9
				
				ldx #0					not in "
						
				ldy #0
				
.1				lda (ZPFileBufPtr),y
				beq .7

				cmp #C.CR
				beq .6
				
				cmp #'"'
				bne .2
				
				txa
				eor #$80				toggle " switch
				tax
				
				lda #'"'
				bra .5
				
.2				cmp #';'
				bne .5
				
				txa
				beq .6
				
				lda #';'
				
.5				sta (ZPCLBuf),y
				iny
				cpy #CL.MAX
				bne .1
				
				lda #E.SYN				Line Too long !!!
*				sec
				rts
				
.6				sec						skip CR or ;
				.HS 90					BCC
				
.7				clc
				
				tya
				adc ZPFileBufPtr
				sta ZPFileBufPtr
				bcc .8
				inc ZPFileBufPtr+1
				
.8				lda #0
				sta (ZPCLBuf),y
				
				tya
				>STA.G CL.Len
				lda #$ff
				>STA.G CL.bExec

				clc
				rts
				
.9				lda #C.EOF
				sec
				rts
*--------------------------------------
* Input : ZPArgVBuf
* :LOOP
* if CmdSep=| : 
*    set hStdIn = hStdOut
*    set hStdOut = Std
* GetCmd from line until | or EOL
* if CmdSep=| :
*     create PIPE
*     set hStdOut -> PIPE
*	  CORE.Exec &
*      :LOOP
* else CORE.Exec
*--------------------------------------
* SET VAR = `cmd args`, FOR VAR IN `cmd args`
* create PIPE
* set hStdOut -> PIPE
* CORE.Exec `cmd args` &
* set READMODE
* set hStdIn = hStdOut
* set hStdOut = Std
*--------------------------------------
CORE.Exec		>PUSHW ZPCLBuf
				>LDYA ZPCLBuf
				>STYA ZPCLBufPtr

				>SYSCALL Args2ArgV		TOKENIZE CL in ZPCLBuf

				lda (ZPCLBufPtr)		empty line ?
				beq .80
				
				cmp #'#'				comment ?
				beq .80

				>STZ.G CL.CmdSep
				
*************** LOOP Cmd Arg
					
.10				lda #0
				sta (ZPArgVBuf)

				lda #S.PS.F.HOLD+S.PS.F.DUPENV
				>STA.G CORE.PSFlags
				
				>LDA.G CL.CmdSep
				cmp #'|'
				bne .1
				
*				PIPE

*************** LOOP Token
				
.1				cmp #'#'				comment ?
				beq .80					yes, ignore remaining

				ldy #1
				lda (ZPCLBufPtr),y		only one char ?
				bne .2

				lda (ZPCLBufPtr)
				cmp #'.'				leading dot ?
				bne .2
				
				>LDA.G CORE.PSFlags		yes, child process will run in same ENV
				and #$ff^S.PS.F.DUPENV
				sta (pData),y
				jsr CORE.NextCLToken		and skip this token		

.2				jsr CORE.IO.Check
				bcc .7					IO token & related args processed
				tay						an error ?
				bne .90					yes...I/O error...
				
				jsr CORE.AddCLBufPtrToArgV	no...add as cmd or arg
				bcs .90

.6				jsr CORE.NextCLToken

.7				lda (ZPCLBufPtr)

				beq .71					EOL...
				cmp #';'
				bne .70
				
				>STA.G CL.CmdSep
				jsr CORE.NextCLToken		Skip ;
				bra .72					exec

.70				cmp #'|'
				bne .1					another token...

				>STA.G CL.CmdSep
				
*				PIPE				
	
				jsr CORE.NextCLToken		Skip |
				bra .72					and exec
	
				jsr CORE.NextCLToken		Skip ;
				lda #0
				
.71				>STA.G CL.CmdSep

.72				jsr CORE.ExecCmd
				bcs .90
				
				>LDA.G CL.CmdSep
				bne .10					if sep is ; or |...loop

.80				clc
				
.90				rts				
*--------------------------------------
* Input : ZPArgVBuf
*--------------------------------------
CORE.ExecCmd	ldy #$ff

.1				iny
				lda (ZPArgVBuf),y
				beq .11
				cmp #'/'
				bne .1
				
				bra .12
				
.11				>PUSHW ZPArgVBuf
				>LDYA L.CORE.INT
				jsr Lookup				no / found, search internal...
				bcc .13					not internal
				
.12				ldx #$ff				found a / in Arg0 .. external
.13				txa
				>STA.G CORE.IntCmd

.10				jsr CORE.StkGet			IF,WHILE,FOR ?
				bcs .3					no particular context, exec...
				tax
				
				>LDA.G CORE.IntCmd
				bmi .2					external ...
				
				and #$3F
				cmp #C.FOR
				bcs .3					FOR...FI : always execute
		
.2				txa
				bpl .8 					context is FALSE, skip line
				asl
				bpl .8					parent context is FALSE, skip line

.3				>LDA.G CORE.IntCmd
				bpl .80					Internal
				
				>PUSHB.G CORE.PSFlags
				>LDYA ZPArgVBuf
				>SYSCALL execv
				bcs .9
				
				tax						CPID
				
				>LDA.G CORE.PSFlags
				and #S.PS.F.HOLD
				bne .4
				
				txa
				>PUSHA
				>PUSHBI 1
				>LDYA L.MSG.PID
				>SYSCALL printf
				rts
				
.4				>SLEEP					Suspend this PID
				
				sec
				ldy #S.PS.RC			CPID will update S.PS.RC
				lda (pPs),y
				bne .9
				
.8				clc
.9				rts

.80				tax
				jmp (J.CMD,x)
*--------------------------------------
CORE.NextCLToken
				lda (ZPCLBufPtr)
				inc ZPCLBufPtr
				bne .1
				inc ZPCLBufPtr+1
.1				tax
				bne CORE.NextCLToken
				rts
*--------------------------------------
CORE.AddCLBufPtrToArgV
				>LDYA ZPCLBufPtr
				>STYA ZPPtr1

				>LDYA ZPArgVBuf
				>STYA ZPPtr2
				
.1				lda (ZPPtr2)			scan to end of argV
				beq .6

.2				inc ZPPtr2
				bne .3
				inc ZPPtr2+1
.3				lda (ZPPtr2)
				bne .2

				inc ZPPtr2
				bne .4
				inc ZPPtr2+1
.4				lda (ZPPtr2)
				bne .2
				
.6				ldy #$ff

.7				iny
*				beq .9
				lda (ZPPtr1),y
				sta (ZPPtr2),y
				bne .7					including str ending \0

				iny
*				beq .9
				sta (ZPPtr2),y			arg[] ending \0
				
				clc
				rts
				
.9				lda #E.BUF	
				sec				
				rts
*--------------------------------------
CORE.GetArgX	>LDYA ZPArgVBuf
				
				dex
				bmi .8
				
				>STYA ZPPtr1
				
.1				lda (ZPPtr1)
				beq .9

.2				inc ZPPtr1
				bne .3
				inc ZPPtr1+1
.3				lda (ZPPtr1)
				bne .2
				
				inc ZPPtr1
				bne .4
				inc ZPPtr1+1
				
.4				lda (ZPPtr1)
				beq .9

				dex
				bpl .1
				
				>LDYA ZPPtr1

.8				clc
				rts

.9				sec
				rts
*--------------------------------------
CORE.StkPushPtr	lda ZPFileBufPtrBak
				jsr CORE.StkPush
				bcs CORE.StkPullPtr.9
				lda ZPFileBufPtrBak+1
				bra CORE.StkPush
.9				rts				
*--------------------------------------
CORE.StkPullPtr	jsr CORE.StkPull
				bcs CORE.StkPullPtr.9
				sta ZPFileBufPtr+1
				jsr CORE.StkPull
				bcs CORE.StkPullPtr.9
				sta ZPFileBufPtr
CORE.StkPullPtr.9		
				rts				
*--------------------------------------
CORE.StkGetPtr	lda (pData)				StackPtr
				beq .9
				dec
				beq .9
				
				tay

				lda (pData),y
				sta ZPFileBufPtr
				iny
				lda (pData),y
				sta ZPFileBufPtr+1
				
				clc
				rts
				
.9				lda #E.SSYN
				sec
				rts
*--------------------------------------
CORE.StkPush	pha
				lda (pData)				StackPtr
				inc
				cmp #CORE.STACK.MAX
				beq .9
				sta (pData)				StackPtr
				tay
				pla	
				sta (pData),y
*				clc
				rts
				
.9				pla
				lda #E.STKOVERFLOW
*				sec
				rts
*--------------------------------------
CORE.StkPull	jsr CORE.StkGet
				bcs .9
				
				dey
				pha
				tya
				sta (pData)				StackPtr
				pla
				
.9				rts				
*--------------------------------------
CORE.StkGet		lda (pData)				StackPtr
				beq .9
				tay
				lda (pData),y
				clc
				rts
				
.9				lda #E.SSYN
				sec
				rts
*--------------------------------------
CORE.IO.Check	>PUSHW ZPCLBufPtr
				>LDYA L.CORE.IO
				jsr Lookup
				bcs .9					not a IO token...should be an arg....
				phx
				
				jsr CORE.NextCLToken		skip this IO token
				
				plx
				jmp (J.CORE.IO,x)

.9				lda #0
				rts
*--------------------------------------
CORE.IO.AMP		>LDA.G CORE.PSFlags
				and #$ff^S.PS.F.HOLD
				sta (pData),y
				clc
				rts
				
CORE.IO.IN		lda #O.RDONLY+O.TEXT
				jsr CORE.IO.Open
				bcs .9
				jsr IO.Set.In

				jsr CORE.NextCLToken 		skip arg
				clc
.9				rts
				
CORE.IO.OUTA
CORE.IO.1OUTA		lda #O.WRONLY+O.APPEND+O.CREATE+O.TEXT
				bra CORE.IO.OUT.1
CORE.IO.OUT		
CORE.IO.1OUT		lda #O.WRONLY+O.TRUNC+O.CREATE+O.TEXT

CORE.IO.OUT.1		jsr CORE.IO.Open
				bcs .9
				jsr IO.Set.Out

				jsr CORE.NextCLToken 		skip arg
				clc	
.9				rts

CORE.IO.2OUTA		lda #O.WRONLY+O.APPEND+O.CREATE+O.TEXT
				bra CORE.IO.2OUT.1
CORE.IO.2OUT		lda #O.WRONLY+O.TRUNC+O.CREATE+O.TEXT

CORE.IO.2OUT.1	jsr CORE.IO.Open
				bcs .9
				jsr IO.Set.Err

				jsr CORE.NextCLToken	 	skip arg
				clc
.9				rts
*--------------------------------------
CORE.IO.Open	pha
				lda (ZPCLBufPtr)
				beq .9					no arg left....
				
				>PUSHWI 0				Aux type
				>PUSHBI S.FI.T.TXT		ftype
				pla
				>PUSHA					flags
				>LDYA ZPCLBufPtr
				>SYSCALL fopen
				rts
				
.9				pla
				lda #E.CSYN
				sec
				rts				
*--------------------------------------
MAN
SAVE USR/SRC/BIN/SHELL.S.CORE
LOAD USR/SRC/BIN/SHELL.S
ASM
