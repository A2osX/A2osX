NEW
PREFIX
AUTO 4,1
				.LIST OFF	
*--------------------------------------
CORE.Init		>LDYAI 256
				>SYSCALL GetMem
				bcs .9
				>STYA ZPArgVBuf
				txa
				>STA.G CORE.hArgVBuf
.9				rts				
*--------------------------------------
CORE.Quit		>LDA.G CORE.hArgVBuf
				beq .9
				>SYSCALL FreeMem

.9				rts	
*--------------------------------------
* Input : ZPCLBuf/ZPFileBuf
* Get Line from buf until ;, CR, \0 (EOL / EOF) -> ZPArgVBuf
*--------------------------------------
CORE.GetCmd		>LDYA ZPInputBufPtr
				>STYA ZPInputLinePtr
				
				lda (ZPInputBufPtr)
				beq .9

				ldx #0					reset "" flag					
				ldy #0
				
.1				lda (ZPInputBufPtr),y
				beq .7

				cmp #C.CR
				beq .6
				
				cmp #'"'
				bne .2
				
				txa
				eor #$80				toggle "" flag
				tax
				
				lda #'"'
				bra .5
				
.2				cmp #';'
				bne .5
				
				txa
				beq .6					not between ""
				
				lda #';'
				
.5				sta (ZPArgVBuf),y
				iny
				bne .1
				
				lda #E.SYN				Line Too long !!!
.9				sec
				rts
				
.6				sec						skip CR or ;
				.HS 90					BCC
				
.7				clc
				
				tya
				adc ZPInputBufPtr
				sta ZPInputBufPtr
				bcc .8
				inc ZPInputBufPtr+1
				
.8				lda #0
				sta (ZPArgVBuf),y
				
				clc
				rts
*--------------------------------------
* Input : ZPArgVBuf (String)
* Tokenize ZPArgVBuf
* :LOOP
* if CmdSep=| : 
*    set hStdIn = hStdOut
*    set hStdOut = Std
* GetCmd from line until | or EOL
* if CmdSep=| :
*     create PIPE
*     set hStdOut -> PIPE
*	  CORE.Exec &
*      :LOOP
* else CORE.Exec
*--------------------------------------
* SET VAR = `cmd args`, FOR VAR IN `cmd args`
* create PIPE
* set hStdOut -> PIPE
* CORE.Exec `cmd args` &
* set READMODE
* set hStdIn = hStdOut
* set hStdOut = Std
*--------------------------------------
CORE.Exec		>PUSHW ZPArgVBuf
				>LDYA ZPArgVBuf
				>STYA ZPArgVBufPtr

				>SYSCALL Args2ArgV		TOKENIZE CL in ZPArgVBuf

				>STZ.G CL.CmdSep
				
				lda (ZPArgVBufPtr)		empty line ?
				beq .80
				
				cmp #'#'				comment ?
				beq .80

*************** LOOP Cmd Arg
					
.10				lda #S.PS.F.HOLD+S.PS.F.DUPENV
				>STA.G CORE.PSFlags
				
				>LDA.G CL.CmdSep
				cmp #'|'
				bne .1
				
				jsr IO.Pipe.In
				bcs .90
				
*************** LOOP Token
				
.1				cmp #'#'				comment ?
				beq .80					yes, ignore remaining

				ldy #1
				lda (ZPArgVBufPtr),y		only one char ?
				bne .2

				lda (ZPArgVBufPtr)
				cmp #'.'				leading dot ?
				bne .2
				
				>LDA.G CORE.PSFlags		yes, child process will run in same ENV
				and #$ff^S.PS.F.DUPENV
				sta (pData),y
				jsr CORE.ShiftArgVToken		and skip this token		

.2				jsr CORE.IO.Check
				bcc .7					IO token & related args processed
				tay						an error ?
				bne .90					yes...I/O error...
				
				jsr CORE.NextArgVToken	no...keep as cmd or arg

.7				lda (ZPArgVBufPtr)

				beq .71					EOL...
				cmp #';'
				bne .70
				
				>STA.G CL.CmdSep
				jsr CORE.ShiftArgVToken		Skip ;
				bra .72					exec

.70				cmp #'|'
				bne .1					another token...

				>STA.G CL.CmdSep
				
				jsr IO.Pipe.Out
				bcs .90				
	
				jsr CORE.ShiftArgVToken		Skip |
				bra .72					and exec
	
				jsr CORE.ShiftArgVToken		Skip ;
				lda #0
				
.71				>STA.G CL.CmdSep

.72				jsr CORE.ExecCmd
				bcs .90
				
				>LDA.G CL.CmdSep
				bne .10					if sep is ; or |...loop

.80				clc
				
.90				rts				
*--------------------------------------
* Input : ZPArgVBuf
*--------------------------------------
CORE.ExecCmd	ldy #$ff

.1				iny
				lda (ZPArgVBuf),y
				beq .11
				cmp #'/'
				bne .1
				
				bra .12
				
.11				>PUSHW ZPArgVBuf
				>LDYA L.CORE.INT
				jsr Lookup				no / found, search internal...
				bcc .13					not internal
				
.12				ldx #$ff				found a / in Arg0 .. external
.13				txa
				>STA.G CORE.IntCmd

.10				jsr CORE.StkGet			IF,WHILE,FOR ?
				bcs .3					no particular context, exec...
				tax
				
				>LDA.G CORE.IntCmd
				bmi .2					external ...
				
				and #$3F
				cmp #C.FOR
				bcs .3					FOR...FI : always execute
		
.2				txa
				bpl .8 					context is FALSE, skip line
				asl
				bpl .8					parent context is FALSE, skip line

.3				>LDA.G CORE.IntCmd
				bmi CORE.ExecExtCmd

				tax
				jmp (J.CMD,x)

.8				clc
.9				rts				
*--------------------------------------
CORE.ExecExtCmd	>PUSHB.G CORE.PSFlags
				>LDYA ZPArgVBuf
				>SYSCALL execv
				bcs .9
				
				tax						CPID
				
				>LDA.G CORE.PSFlags
				and #S.PS.F.HOLD
				bne .4
				
				txa
				>PUSHA
				>PUSHBI 1
				>LDYA L.MSG.PID
				>SYSCALL printf
				rts
				
.4				>SLEEP					Suspend this PID
				
				sec
				ldy #S.PS.RC			CPID will update S.PS.RC
				lda (pPs),y
				bne .9
				
.8				clc
.9				rts
*--------------------------------------
CORE.NextArgVToken
				lda (ZPArgVBufPtr)
				inc ZPArgVBufPtr
				bne .1
				inc ZPArgVBufPtr+1
.1				tax
				bne CORE.NextArgVToken
				rts
*--------------------------------------
CORE.ShiftArgVToken
				>LDYA ZPArgVBufPtr
				jmp RemoveStrFromArgV
*--------------------------------------
CORE.GetArgX	>LDYA ZPArgVBuf
				
				dex
				bmi .8
				
				>STYA ZPPtr1
				
.1				lda (ZPPtr1)
				beq .9

.2				inc ZPPtr1
				bne .3
				inc ZPPtr1+1
.3				lda (ZPPtr1)
				bne .2
				
				inc ZPPtr1
				bne .4
				inc ZPPtr1+1
				
.4				lda (ZPPtr1)
				beq .9

				dex
				bpl .1
				
				>LDYA ZPPtr1

.8				clc
				rts

.9				sec
				rts
*--------------------------------------
CORE.StkPushPtr	lda ZPInputLinePtr
				jsr CORE.StkPush
				bcs CORE.StkPullPtr.9
				lda ZPInputLinePtr+1
				bra CORE.StkPush
.9				rts				
*--------------------------------------
CORE.StkPullPtr	jsr CORE.StkPull
				bcs CORE.StkPullPtr.9
				sta ZPInputBufPtr+1
				jsr CORE.StkPull
				bcs CORE.StkPullPtr.9
				sta ZPInputBufPtr
CORE.StkPullPtr.9		
				rts				
*--------------------------------------
CORE.StkGetPtr	lda (pData)				StackPtr
				beq .9
				dec
				beq .9
				
				tay

				lda (pData),y
				sta ZPInputBufPtr
				iny
				lda (pData),y
				sta ZPInputBufPtr+1
				
				clc
				rts
				
.9				lda #E.SSYN
				sec
				rts
*--------------------------------------
CORE.StkPush	pha
				lda (pData)				StackPtr
				inc
				cmp #CORE.STACK.MAX
				beq .9
				sta (pData)				StackPtr
				tay
				pla	
				sta (pData),y
*				clc
				rts
				
.9				pla
				lda #E.STKOVERFLOW
*				sec
				rts
*--------------------------------------
CORE.StkPull	jsr CORE.StkGet
				bcs .9
				
				dey
				pha
				tya
				sta (pData)				StackPtr
				pla
				
.9				rts				
*--------------------------------------
CORE.StkGet		lda (pData)				StackPtr
				beq .9
				tay
				lda (pData),y
				clc
				rts
				
.9				lda #E.SSYN
				sec
				rts
*--------------------------------------
CORE.IO.Check	>PUSHW ZPArgVBufPtr
				>LDYA L.CORE.IO
				jsr Lookup
				bcs .9					not a IO token...should be an arg....
				phx
				
				jsr CORE.ShiftArgVToken		skip this IO token
				
				plx
				jmp (J.CORE.IO,x)

.9				lda #0
				rts
*--------------------------------------
CORE.IO.AMP		>LDA.G CORE.PSFlags
				and #$ff^S.PS.F.HOLD
				sta (pData),y
				clc
				rts
				
CORE.IO.IN		lda #O.RDONLY+O.TEXT
				jsr CORE.IO.Open
				bcs .9
				jsr IO.Set.In

				jsr CORE.ShiftArgVToken 		skip arg
				clc
.9				rts
				
CORE.IO.OUTA
CORE.IO.1OUTA		lda #O.WRONLY+O.APPEND+O.CREATE+O.TEXT
				bra CORE.IO.OUT.1
CORE.IO.OUT		
CORE.IO.1OUT		lda #O.WRONLY+O.TRUNC+O.CREATE+O.TEXT

CORE.IO.OUT.1		jsr CORE.IO.Open
				bcs .9
				jsr IO.Set.Out

				jsr CORE.ShiftArgVToken 		skip arg
				clc	
.9				rts

CORE.IO.2OUTA		lda #O.WRONLY+O.APPEND+O.CREATE+O.TEXT
				bra CORE.IO.2OUT.1
CORE.IO.2OUT		lda #O.WRONLY+O.TRUNC+O.CREATE+O.TEXT

CORE.IO.2OUT.1	jsr CORE.IO.Open
				bcs .9
				jsr IO.Set.Err

				jsr CORE.ShiftArgVToken	 	skip arg
				clc
.9				rts
*--------------------------------------
CORE.IO.Open	pha
				lda (ZPArgVBufPtr)
				beq .9					no arg left....
				
				>PUSHWI 0				Aux type
				>PUSHBI S.FI.T.TXT		ftype
				pla
				>PUSHA					flags
				>LDYA ZPArgVBufPtr
				>SYSCALL fopen
				rts
				
.9				pla
				lda #E.CSYN
				sec
				rts				
*--------------------------------------
MAN
SAVE USR/SRC/BIN/SHELL.S.CORE
LOAD USR/SRC/BIN/SHELL.S
ASM
