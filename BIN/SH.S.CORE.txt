NEW
PREFIX
AUTO 4,1
				.LIST OFF	
*--------------------------------------
CORE.Init		>LDYAI 256
				>SYSCALL GetMem
				bcs .9
				>STYA ZPArgVBuf
				txa
				>STA.G CORE.hArgVBuf
.9				rts				
*--------------------------------------
CORE.Quit		>LDA.G CORE.hArgVBuf
				beq .9
				>SYSCALL FreeMem

.9				rts	
*--------------------------------------
* Input : ZPArgVBuf (String)
* Tokenize ZPArgVBuf
* :LOOP
* if CmdSep=| : 
*    set hStdIn = hStdOut
*    set hStdOut = Std
* GetCmd from line until | or EOL
* if CmdSep=| :
*     create PIPE
*     set hStdOut -> PIPE
*	  CORE.Exec &
*      :LOOP
* else CORE.Exec
*--------------------------------------
* SET VAR = `cmd args`, FOR VAR IN `cmd args`
* create PIPE
* set hStdOut -> PIPE
* CORE.Exec `cmd args` &
* set READMODE
* set hStdIn = hStdOut
* set hStdOut = Std
*--------------------------------------
CORE.Run.CSYN	lda #E.CSYN
				sec
				rts
				
CORE.Run		>LDYA ZPInputBufPtr		Save Actual cmd for looping
				>STYA ZPInputCmdPtr

				>LDYA ZPArgVBuf
				>STYA ZPArgVBufPtr

				lda #$ff
				>STA.G CORE.IntCmd		assume external

				jsr CORE.GetCharNB
				bcs CORE.Run.RTS		Ending 0, CS,A=0
				
				cmp #'#'				commented line?
				bne .2

.1				jsr CORE.GetNextCharNB
				bcs CORE.Run.RTS		A=0, CS
				eor #C.CR
				bne .1
.9				rts						EOL, CC,A=0
				
.2				cmp #'|'
				bne .3
				
				jsr IO.Pipe.In
				bcs CORE.Run.RTS
				
				jsr CORE.GetNextCharNB
				bcs CORE.Run.CSYN
				
.3				cmp #'.'
				bne .4
				
				ldy #1
				lda (ZPInputBufPtr),y
				cmp #C.SPACE
				bne .4
				
				>LDA.G CORE.PSFlags		yes, child process will run in same ENV
				and #$ff^S.PS.F.DUPENV
				sta (pData),y
				
				jsr CORE.GetNextCharNB	skip ". "
				bcs CORE.Run.RTS		nothing to execute...

.4				>LDYA L.CMD				internal command ?
				jsr CORE.Lookup
				bcs .6					external, add token
				txa
				>STA.G CORE.IntCmd
				bra .7					internal, do not add token

.5				>LDYA L.CORE.IO
				jsr CORE.Lookup
				bcs .6
				
				jsr CORE.GetNextCharNB
				bcs CORE.Run.CSYN
				jsr CORE.IO.JMP
				bcs CORE.Run.RTS
				bra .7
				
.6				jsr CORE.ArgV.Add
				
.7				jsr CORE.GetCharNB
				bcs CORE.ExecCmd
				
				jsr CORE.IsEndCmd
				bcs .5
				cmp #'|'
				beq CORE.ExecCmd
				
				jsr CORE.GetNextCharNB
				
				jsr IO.Pipe.Out
				bcs CORE.Run.RTS
				
				bra CORE.ExecCmd
				
.8				clc				
CORE.Run.RTS	rts				
*--------------------------------------
* Input : ZPArgVBuf
*--------------------------------------
CORE.ExecCmd	lda #0
				jsr CORE.ArgV.PutChar

				>LDA.G CORE.IntCmd
				bmi CORE.ExecExtCmd
				tax
				>LDYA ZPArgVBuf
				>STYA ZPArgVBufPtr

				jmp (J.CMD,x)

CORE.ExecExtCmd	>PUSHB.G CORE.PSFlags
				>LDYA ZPArgVBuf
				>SYSCALL execv
				bcs .9
				
				tax						CPID
				
				>LDA.G CORE.PSFlags
				and #S.PS.F.HOLD
				bne .4
				
				txa
				>PUSHA
				>PUSHBI 1
				>LDYA L.MSG.PID
				>SYSCALL printf
				rts
				
.4				>SLEEP					Suspend this PID
				
				sec
				ldy #S.PS.RC			CPID will update S.PS.RC
				lda (pPs),y
				bne .9
				
.8				clc
.9				rts
*--------------------------------------
* search ZPInputBufPtr in Y,A table
*--------------------------------------
CORE.Lookup		>STYA ZPPtr1

				ldx #0
				
.1				phx
				
				ldy #$ff
				
.2				iny
				lda (ZPInputBufPtr),y
				beq .3					Src Keyword end
			
				jsr CORE.IsSpaceOrEndCmd
				bcc .3					Src Keyword end
				
				lda (ZPPtr1),y
				beq .4					Table Keyword end
				cmp (ZPInputBufPtr),y
				beq .2

				bra .4
				
.3				lda (ZPPtr1),y
				bne .4
				plx
				
				tya
				clc
				adc ZPInputBufPtr
				sta ZPInputBufPtr
				bcc .8
				
				clc
				inc ZPInputBufPtr+1
				
.8				rts
				
.4				inc ZPPtr1
				bne .5
				inc ZPPtr1+1

.5				lda (ZPPtr1)
				bne .4
				
				inc ZPPtr1
				bne .6
				inc ZPPtr1+1
								
.6				plx
				inx
				inx
				
				lda (ZPPtr1)			Array Ending 0, must be an external Cmd....
				bne .1
				
				lda #E.CSYN
CORE.Lookup.9	sec
				rts
*--------------------------------------
* ArgV
*--------------------------------------
CORE.ArgV.Add	jsr CORE.GetCharNB
				bcs CORE.Lookup.9
				
				ldx #0
				
.1				cmp #'"'
				bne .2

				txa
				eor #$ff
				tax
				bra .4
				
.2				cmp #C.SPACE
				bne .3
				txa
				bpl .8
				
.3				jsr CORE.IsEndCmd
				bcc CORE.Lookup.9

				jsr CORE.ArgV.PutChar
				
.4				jsr CORE.GetNextChar
				bra .1
				
.8				lda #0
*--------------------------------------
CORE.ArgV.PutChar
				sta (ZPArgVBufPtr)
CORE.ArgV.NextChar
				inc ZPArgVBufPtr
				bne .8
				inc ZPArgVBufPtr
.8				rts				
*--------------------------------------
CORE.ArgV.Next	lda (ZPArgVBufPtr)
				beq .8
				
.1				jsr CORE.ArgV.NextChar
				lda (ZPArgVBufPtr)
				bne .1
				
				jsr CORE.ArgV.NextChar
				lda (ZPArgVBufPtr)

.8				rts
*--------------------------------------
* IO
*--------------------------------------
CORE.IO.JMP		jmp (J.CORE.IO,x)

CORE.IO.AMP		>LDA.G CORE.PSFlags
				and #$ff^S.PS.F.HOLD
				sta (pData),y
				clc
CORE.IO.RTS		rts
				
CORE.IO.IN		lda #O.RDONLY+O.TEXT
				jsr CORE.IO.Open
				bcs CORE.IO.RTS
				jmp IO.Set.In
CORE.IO.OUTA
CORE.IO.1OUTA	lda #O.WRONLY+O.APPEND+O.CREATE+O.TEXT
				bra CORE.IO.OUT.1
CORE.IO.OUT		
CORE.IO.1OUT	lda #O.WRONLY+O.TRUNC+O.CREATE+O.TEXT

CORE.IO.OUT.1	jsr CORE.IO.Open
				bcs CORE.IO.RTS
				jmp IO.Set.Out

CORE.IO.2OUTA	lda #O.WRONLY+O.APPEND+O.CREATE+O.TEXT
				bra CORE.IO.2OUT.1
CORE.IO.2OUT	lda #O.WRONLY+O.TRUNC+O.CREATE+O.TEXT

CORE.IO.2OUT.1	jsr CORE.IO.Open
				bcs CORE.IO.RTS
				jmp IO.Set.Err
*--------------------------------------
CORE.IO.Open	pha						Open Mode
				jsr CORE.GetCharNB
				bcs .9					no arg left....
				
				>PUSHWI 0				Aux type
				>PUSHBI S.FI.T.TXT		ftype
				pla
				>PUSHA					flags
				>LDYA ZPInputBufPtr
				>SYSCALL fopen
				rts
				
.9				pla
				lda #E.CSYN
				sec
				rts				
*--------------------------------------
* Input Buffer
*--------------------------------------
CORE.IsSpaceOrEndCmd
				cmp #C.SPACE
				beq CORE.IsEndCmd.8
				
CORE.IsEndCmd	cmp #C.CR
				beq CORE.IsEndCmd.8
				cmp #';'
				beq CORE.IsEndCmd.8
				cmp #'|'
				beq CORE.IsEndCmd.8
				sec
				rts
				
CORE.IsEndCmd.8	clc
				rts
*--------------------------------------
CORE.GetCharNB	jsr CORE.GetChar
				bcs CORE.GetNextCharNB.RTS
				jsr CORE.CheckCharNB
				bcc CORE.GetNextCharNB.RTS		
*--------------------------------------
CORE.GetNextCharNB
				jsr CORE.GetNextChar
				bcs CORE.GetNextCharNB.RTS
				jsr CORE.CheckCharNB
				bcs CORE.GetNextCharNB
CORE.GetNextCharNB.RTS
				rts
*--------------------------------------
CORE.CheckCharNB
				cmp #C.SPACE
				beq .9
				cmp #C.LF
				beq .9
				cmp #C.TAB
				beq .9
				clc
.9				rts				
*--------------------------------------
CORE.GetNextChar
				inc ZPInputBufPtr
				bne CORE.GetChar
				inc ZPInputBufPtr+1
*--------------------------------------
CORE.GetChar	lda (ZPInputBufPtr)
				beq .9
				clc
				rts
				
.9				sec
				rts
*--------------------------------------
* Stack
*--------------------------------------
CORE.StkPushPtr	lda ZPInputCmdPtr
				jsr CORE.StkPush
				bcs CORE.StkPullPtr.9
				lda ZPInputCmdPtr+1
				bra CORE.StkPush
.9				rts				
*--------------------------------------
CORE.StkPullPtr	jsr CORE.StkPull
				bcs CORE.StkPullPtr.9
				sta ZPInputBufPtr+1
				jsr CORE.StkPull
				bcs CORE.StkPullPtr.9
				sta ZPInputBufPtr
CORE.StkPullPtr.9		
				rts				
*--------------------------------------
CORE.StkGetPtr	lda (pData)				StackPtr
				beq .9
				dec
				beq .9
				
				tay

				lda (pData),y
				sta ZPInputBufPtr
				iny
				lda (pData),y
				sta ZPInputBufPtr+1
				
				clc
				rts
				
.9				lda #E.SSYN
				sec
				rts
*--------------------------------------
CORE.StkPush	pha
				lda (pData)				StackPtr
				inc
				cmp #CORE.STACK.MAX
				beq .9
				sta (pData)				StackPtr
				tay
				pla	
				sta (pData),y
*				clc
				rts
				
.9				pla
				lda #E.STKOVERFLOW
*				sec
				rts
*--------------------------------------
CORE.StkPull	jsr CORE.StkGet
				bcs .9
				
				dey
				pha
				tya
				sta (pData)				StackPtr
				pla
				
.9				rts				
*--------------------------------------
CORE.StkGet		lda (pData)				StackPtr
				beq .9
				tay
				lda (pData),y
				clc
				rts
				
.9				lda #E.SSYN
				sec
				rts
*--------------------------------------
MAN
SAVE USR/SRC/BIN/SH.S.CORE
LOAD USR/SRC/BIN/SH.S
ASM
