NEW
  AUTO 3,1
				.LIST OFF	
*--------------------------------------
CORE.Init		>LDYAI 256
				>SYSCALL GetMem
				bcs .9
				>STYA ZPArgVBuf
				txa
				>STA.G CORE.hArgVBuf
				
.9				rts				
*--------------------------------------
CORE.Quit		>LDA.G CORE.hArgVBuf
				beq CORE.FUNCRESET
				>SYSCALL FreeMem

CORE.FUNCRESET	>LDA.G hFuncList
				beq .8
	
				>SYSCALL SListFree
				>STZ.G hFuncList
	
.8
CORE.FUNCRESET.RTS
				rts	
*--------------------------------------
CORE.Load.YAX	stx M32.ACC				X=Code to Execute

				jsr CORE.ArgV.Dup		Y,A = ArgV
				bcs CORE.FUNCRESET.RTS
				sta M32.ACC+2			A=ARGC
				stx M32.ACC+1			X=ARGV

				lda #8
				jsr CORE.StkCheck
				bcs CORE.FUNCRESET.RTS
				
				>LDYA ZPInputBuf
				jsr CORE.StkPushYA
				
				>LDYA ZPInputBufPtr
				jsr CORE.StkPushYA
				
				ldy #S.PS.ARGC
				lda (pPS),y
				jsr CORE.StkPush		old ARGC

				ldy #S.PS.hARGV
				lda (pPS),y
				jsr CORE.StkPush		old ARGV

				ldy #S.PS.ARGC
				lda M32.ACC+2			new ARGC
				sta (pPS),y
				
				iny 					#S.PS.hARGV
				lda M32.ACC+1
				sta (pPS),y				new ARGV
				
				lda M32.ACC				new code
				jsr CORE.StkPush
				
				lda M32.ACC
				>SYSCALL GetMemPtr
				>STYA ZPInputBuf
				>STYA ZPInputBufPtr

				lda #$C0
				jmp CORE.StkPush
*--------------------------------------
* http://heirloom.sourceforge.net/sh/sh.1.html
*--------------------------------------
* Input : ZPArgVBuf (String)
* Tokenize ZPArgVBuf
* :LOOP
* if CmdSep=| : 
*    set hStdIn = hStdOut
*    set hStdOut = Std
* GetCmd from line until | or EOL
* if CmdSep=| :
*     create PIPE
*     set hStdOut -> PIPE
*	  CORE.Exec &
*      :LOOP
* else CORE.Exec
*--------------------------------------
* SET VAR = `cmd args`, FOR VAR IN `cmd args`
* create PIPE
* set hStdOut -> PIPE
* CORE.Exec `cmd args` &
* set READMODE
* set hStdIn = hStdOut
* set hStdOut = Std
*--------------------------------------
CORE.Run.EOF	jsr CORE.StkPull
				bcs .9
				
				cmp #$C0				in CALL / . context ?
				bne .9
				
				jsr CMD.EXIT.CALL
				bcs .9

				jsr IO.Reset
				
				lda #0
				sec
				rts						Ending 0, CS,A=0
				
.9				lda #E.UNEXP
				sec
				rts				
*--------------------------------------
CORE.Run.SYN	lda #E.SYN
				sec
				rts
				
CORE.Run		>LDYA ZPInputBufPtr		Save Actual cmd for looping
				>STYA ZPInputCmdPtr

				>LDYA ZPArgVBuf
				>STYA ZPArgVBufPtr
				
				lda #0					Reset ArgV Buffer
				sta (ZPArgVBuf)
				
				lda #S.PS.F.HOLD
				sta CORE.PSFlags
				
				lda #$ff
				
				sta CORE.IntCmd			assume external
				
				jsr CORE.GetCharNB
				bcs CORE.Run.EOF
				
				cmp #'|'
				bne .21
				
				jsr IO.Pipe.In
				bcs .9
				
				jsr CORE.GetNextCharNB	Skip |
				bcs CORE.Run.SYN

				bra .3
				
.21				pha
				jsr IO.Reset
				pla
				
.3				cmp #C.CR				empty line ?
				bne .33
				
				jsr CORE.GetNextChar	skip CR...
				bra .8
				
.33				cmp #'#'				commented line?
				bne .4

.12				jsr CORE.SkipLine

.8				jsr IO.Reset
				
				lda #0
				clc
.9				rts						EOL, CS,A=0
				
.4				>LDYA L.CMD				internal command ?
				jsr CORE.LookupInputBuf
				bcc .41
				
.40				jsr CORE.ArgV.Add		external cmd, go check context
				bra .42
				
.41				jsr CORE.SkipCharsA
				
				stx CORE.IntCmd
				
.42				jsr CORE.StkGet			
				bcs CORE.Run.7			no particular context, exec...
				tax
				
				lda CORE.IntCmd
				bmi .45
				
				and #$3F
				cmp #C.SWITCH			SWITCH....FI ?
				bcs CORE.Run.7

.45				txa
				bpl .43					context is FALSE, skip line	
				
				asl				
				bmi CORE.Run.7			parent context is true, exec
				
.43				jsr CORE.GetCharNB
				
				bcs .44					EOF

				cmp #C.CR
				beq .44
				
				cmp #';'				TODO ";"
				beq .44

				jsr CORE.GetNextChar
				bra .43
				
.44				jsr CORE.GetNextCharNB	Skip EoL char
				clc
.99				rts
*--------------------------------------
CORE.Run.5		>LDYA L.CORE.IO
				jsr CORE.LookupInputBuf
				bcs CORE.Run.6

				jsr CORE.SkipCharsA

				jsr CORE.IO.JMP
				bcs CORE.Run.RTS
				bra CORE.Run.7
				
CORE.Run.6		jsr CORE.ArgV.Add
				
CORE.Run.7		jsr CORE.GetCharNB
				bcs CORE.ExecCmd.1		Nothing to skip
				
				jsr CORE.IsEndCmd
				bcs CORE.Run.5
				
				cmp #'|'
				bne CORE.ExecCmd		skip CR, ;
				
				jsr IO.Pipe.Out
				bcs CORE.Run.RTS

				lda CORE.PSFlags
				and #$ff^S.PS.F.HOLD	Run in the background...
				ora #S.PS.F.CLOSEONX	...and close PIPE on exit
				sta CORE.PSFlags
				
				bra CORE.ExecCmd.1		Do not skip |
						
CORE.Run.RTS	rts				
*--------------------------------------
* Input : ZPArgVBuf
*--------------------------------------
CORE.ExecCmd	jsr CORE.GetNextCharNB	Skip EoL char

CORE.ExecCmd.1	lda #0
				sta (ZPArgVBufPtr)
				
				>LDYA ZPArgVBuf
				>STYA ZPArgVBufPtr

				lda CORE.IntCmd
				bmi CORE.ExecExtCmd
				
				asl
				tax
				jmp (J.CMD,x)
				
CORE.ExecExtCmd	>PUSHB CORE.PSFlags
				>LDYA ZPArgVBuf
				>SYSCALL execv
				bcs .9
				
				tax						CPID
				
				lda CORE.PSFlags
				and #S.PS.F.HOLD
				bne .4
				
				txa
				>PUSHA
				>PUSHBI 1
				>PUSHW L.MSG.PID
				ldy #S.PS.hStdErr
				lda (pPS),y				
				>SYSCALL fprintf
				rts
				
.4				>SLEEP					Suspend this PID
				
				sec
				ldy #S.PS.RC			CPID will update S.PS.RC
				lda (pPs),y
				bne .9
				
.8				clc
.9				rts
*--------------------------------------
CORE.SkipLine	jsr CORE.GetNextCharNB
				bcs .8					EOF

				cmp #C.CR				EOL
				bne CORE.SkipLine
				
				jsr CORE.GetNextChar	skip CR...

.8				rts
*--------------------------------------
* search ZPInputBufPtr/ZPArgVBufPtr in Y,A table
*--------------------------------------
CORE.LookupInputBuf
				>STYA ZPPtr1
				>LDYA ZPInputBufPtr
				bra CORE.Lookup
CORE.LookupArgVBuf				
				>STYA ZPPtr1
				>LDYA ZPArgVBufPtr
				
CORE.Lookup		>STYA ZPPtr2

				ldx #0
				
.1				ldy #$ff
				
.2				iny
				lda (ZPPtr2),y
				beq .3					Src Keyword end
			
				jsr CORE.IsSpaceOrEndCmd
				bcc .3					Src Keyword end
				
				lda (ZPPtr1),y
				beq .4					Table Keyword end
				lda (ZPPtr2),y

				jsr ToUpperCase
				
				cmp (ZPPtr1),y			
				beq .2

				bra .4
				
.3				lda (ZPPtr1),y
				bne .4
				
				tya						Keyword Len
				dey
				clc			
.8				rts
				
.4				jsr IncPtr1

				lda (ZPPtr1)
				bne .4
				
				jsr IncPtr1
								
.6				inx
				
				lda (ZPPtr1)			Array Ending 0, must be an external Cmd....
				bne .1
				
				lda #E.SYN
				sec
				rts
*--------------------------------------
* ArgV
*--------------------------------------
CORE.ArgV.Dup	>STYA ZPPtr1
				phy
				pha
				
				lda #1
				sta ZPPtr2
				stz ZPPtr2+1
				
.1				jsr GetPtr1LenY
				tya
				beq .2
				
				jsr AddAp1Ptr2
				jsr AddYp1Ptr1
				bra .1
				
.2				pla
				ply
				>STYA ZPPtr1
				
				>LDYA ZPPtr2
				>SYSCALL GetMem
				bcs .9
				
				>STYA ZPPtr2

				lda #$ff			Arg count-1 (skip $0)
				pha
				
.5				pla
				inc
				pha
				
				jsr StrCpyPtr1Ptr2
				tya
				beq .8
				
				jsr AddAp1Ptr2
				jsr AddYp1Ptr1
				bra .5

.8				pla						A = Arg count, X = hARGV
				clc				
.9				rts				
*--------------------------------------
CORE.ArgV.Add	>LDYA ZPArgVBufPtr
				>STYA ZPArgVBufPrev		Save String start of Expand

				lda #C.SPACE
				sta ZPTmpW
				
				jsr CORE.GetCharNB
				bcs .9

				cmp #'"'
				bne .10
				sta ZPTmpW
				bra .1
				
.10				cmp #'('
				bne .11
				ldx #')'
				stx ZPTmpW

				bra .12
	
.11				cmp #'`'
				bne .12
				sta ZPTmpW
				
.12				jsr CORE.ArgV.PutChar

.1				jsr CORE.GetNextChar
				bcs .5
				
.2				cmp ZPTmpW
				bne .3
				jsr CORE.GetNextChar
				bra .5

.3				ldy ZPTmpW
				cpy #C.SPACE
				bne .40
				jsr CORE.IsEndCmd
				bcc .5
				
.40				jsr CORE.ArgV.PutChar
				
.4				jsr CORE.GetNextChar
				bcc .2
				
.5				lda #0
				jsr CORE.ArgV.PutChar

				>LDYA ZPArgVBufPrev
				>SYSCALL ExpandStr
				bcs .9
				phx
				>STYA ZPPtr1
	
				>LDYA ZPArgVBufPrev
				>STYA ZPArgVBufPtr

				ldy #$ff

.7				iny
				lda (ZPPtr1),y
				beq .8
				jsr CORE.ArgV.PutChar
				bra .7
				
.8				tya
				beq .81
				
				lda #0
				jsr CORE.ArgV.PutChar
				
.81				pla
				>SYSCALL freemem
.9				rts
*--------------------------------------
CORE.ArgV.PutChar
				sta (ZPArgVBufPtr)
CORE.ArgV.NextChar
				inc ZPArgVBufPtr
				bne .8
				inc ZPArgVBufPtr+1
.8				rts				
*--------------------------------------
CORE.ArgV.Next	lda (ZPArgVBufPtr)
				beq .8
				
				>LDYA ZPArgVBufPtr
				>STYA ZPArgVBufPrev
				
.1				jsr CORE.ArgV.NextChar
				lda (ZPArgVBufPtr)
				bne .1
				
				jsr CORE.ArgV.NextChar
				lda (ZPArgVBufPtr)

.8				rts
*--------------------------------------
* IO
*--------------------------------------
CORE.IO.JMP		txa
				asl
				tax
				jmp (J.CORE.IO,x)

CORE.IO.AMP		lda #S.PS.F.HOLD
				trb CORE.PSFlags
				clc
CORE.IO.RTS		rts
				
CORE.IO.IN		lda #O.RDONLY+O.TEXT
				jsr CORE.IO.Open
				bcs CORE.IO.RTS
				jmp IO.Set.In
CORE.IO.OUTA
CORE.IO.1OUTA	lda #O.WRONLY+O.APPEND+O.CREATE+O.TEXT
				bra CORE.IO.OUT.1
CORE.IO.OUT		
CORE.IO.1OUT	lda #O.WRONLY+O.TRUNC+O.CREATE+O.TEXT

CORE.IO.OUT.1	jsr CORE.IO.Open
				bcs CORE.IO.RTS
				jmp IO.Set.Out

CORE.IO.2OUTA	lda #O.WRONLY+O.APPEND+O.CREATE+O.TEXT
				bra CORE.IO.2OUT.1
CORE.IO.2OUT	lda #O.WRONLY+O.TRUNC+O.CREATE+O.TEXT

CORE.IO.2OUT.1	jsr CORE.IO.Open
				bcs CORE.IO.RTS
				jmp IO.Set.Err
*--------------------------------------
CORE.IO.Open	pha						Open Mode
				jsr CORE.GetCharNB
				bcs .9					no arg left....

				jsr CORE.ArgV.Add		Get Filename

				>LDYA ZPArgVBufPrev
				>STYA ZPArgVBufPtr		Discard filename
				plx
				jmp IO.FOpenYAX
				
.9				pla
				lda #E.SYN
				sec
				rts				
*--------------------------------------
* Input Buffer
*--------------------------------------
CORE.IsSpaceOrEndCmd
				cmp #C.SPACE
				beq CORE.IsEndCmd.8
				
CORE.IsEndCmd	cmp #';'
				beq CORE.IsEndCmd.8
				cmp #C.CR
				beq CORE.IsEndCmd.8
				cmp #'|'
				beq CORE.IsEndCmd.8
				sec
				rts
				
CORE.IsEndCmd.8	clc
				rts
*--------------------------------------
CORE.GetCharNB	jsr CORE.GetChar
				bcs CORE.GetNextCharNB.RTS
				jsr CORE.CheckCharNB
				bcc CORE.GetNextCharNB.RTS		
*--------------------------------------
CORE.GetNextCharNB
				jsr CORE.GetNextChar
				bcs CORE.GetNextCharNB.RTS
				jsr CORE.CheckCharNB
				bcs CORE.GetNextCharNB
CORE.GetNextCharNB.RTS
				rts
*--------------------------------------
CORE.CheckCharNB
				cmp #C.SPACE
				beq .9
				cmp #C.LF
				beq .9
				cmp #C.TAB
				beq .9
				clc
.9				rts				
*--------------------------------------
CORE.GetNextChar
				inc ZPInputBufPtr
				bne CORE.GetChar
				inc ZPInputBufPtr+1
*--------------------------------------
CORE.GetChar	lda (ZPInputBufPtr)
				beq .9
				clc
				rts
				
.9				sec
				rts
*--------------------------------------
CORE.SkipCharsA	clc
				adc ZPInputBufPtr
				sta ZPInputBufPtr
				bcc .8
				inc ZPInputBufPtr+1
.8				rts				
*--------------------------------------
* Stack
*--------------------------------------
CORE.StkCheck	sec
				adc (pData)				StackPtr
				cmp #CORE.STACK.MAX
				bcc .8
				
				lda #E.STKOVERFLOW
*				clc				
				
.8				rts				
*--------------------------------------
CORE.StkPushYAX	phx
				jsr CORE.StkPushYA
				bcs CORE.StkPushYA.9
				
				bra CORE.StkPush.1
*--------------------------------------
CORE.StkPushYA	phy
				jsr CORE.StkPush
				bcc CORE.StkPush.1
				
CORE.StkPushYA.9
				plx
				rts
*--------------------------------------
CORE.StkPush	pha

CORE.StkPush.1	lda (pData)				StackPtr
				inc
				cmp #CORE.STACK.MAX
				bcs .9
				
				sta (pData)				StackPtr
				tay
				pla	
				sta (pData),y
*				clc
				rts
				
.9				pla
				lda #E.STKOVERFLOW
*				sec
				rts
*--------------------------------------
CORE.StkGetCtx	jsr CORE.StkGet
				tax
				bcs .1					no context...

				cmp #$C0				in a call...
				beq .1					CS

				and #$80				get current..
				lsr						becomes parent
				bra .2
				
.1				lda #$40				...set Parent = true

.2				sta CORE.TestResult

				txa
				rts
*--------------------------------------
CORE.StkPullInputBufPtr
				
				jsr CORE.StkPull
				bcs .9
				sta ZPInputBufPtr
				jsr CORE.StkPull
				bcs .9
				sta ZPInputBufPtr+1

.9				rts				
*--------------------------------------
CORE.StkPull	jsr CORE.StkGet
				bcs .9
				
				dey
				pha
				tya
				sta (pData)				StackPtr
				pla
				
.9				rts				
*--------------------------------------
CORE.StkGet		lda (pData)				StackPtr
				beq .9

				tay
				lda (pData),y
				clc
				rts

.9				lda #E.STACKERROR
				sec
				rts
*--------------------------------------
MAN
SAVE USR/SRC/BIN/SH.S.CORE
LOAD USR/SRC/BIN/SH.S
ASM
