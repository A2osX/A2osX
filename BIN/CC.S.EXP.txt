NEW
  AUTO 3,1
*--------------------------------------
* Input:
*   ZPLineBufPtr, Y,A = Expected type/qual
* Output:
*   CS, A = EC
*   CC, Y,A = type/qual
*--------------------------------------
CC.EXP.Eval00	lda #0
				tay

CC.EXP.Eval		ldx ZPPtr1				local : returned T/Q
				phx
				ldx ZPPtr1+1
				phx

				ldx ZPPtr2				local : expected T/Q
				phx
				ldx ZPPtr2+1
				phx

				ldx ZPPtr3				local : BOP
				phx
				ldx ZPPtr3+1			local : PREOP
				phx

				>STYA ZPPtr2

				stz ZPPtr1
				stz ZPPtr1+1

				lda #$ff				no previous OP
				sta ZPPtr3+1			no PREOPS
				pha
*--------------------------------------
.10				jsr CC.GetCharNB
				bcs .19

				cmp #'('
				bne .20

				jsr CC.GetNextCharNB	skip (
				bcs .19

				>LDYA L.CC.TYPEQUAL
				jsr CC.LookupID
				bcs .12

				jsr CC.EXP.Cast
				bcs .19

				bra .20
*--------------------------------------
.12				>LDYA ZPPtr2			expected T/Q
				jsr CC.EXP.Eval
				bcs .19

				>STYA ZPPtr2			update T/Q

				jsr CC.GetCharNB
				bcs .19

				cmp #')'
				bne .19

				jsr CC.GetNextCharNB	skip )
				bcc .31

.19				jmp CC.EXP.Eval.ESYN
*--------------------------------------
.20				>LDYA L.CC.PREOPS
				jsr CC.LookupOP
				stx ZPPtr3+1

				jsr CC.GetCharNB
				bcs .29

				jsr CC.IsLetter			define, f() or Var ?
				bcs .22

				jsr CC.GetDefine
				bcc .10

				jsr CC.SYM.Lookup
				bcs .22

				ldy #SYM.Q
				lda (ZPLookupSymPtr),y
				and #SYM.Q.FUNC
				bne .21

				jsr CC.EXP.GetVar		Check T/Q & Get value on stack
				bcs .29

				jsr CC.SYM.LookupFree

				bra .30
*--------------------------------------
.21				>LDYA ZPPtr2			get expected T/Q

				jsr CC.F.CallRetV
				bcs .29

				>STYA ZPPtr2			store real T/Q

				jsr CC.SYM.LookupFree

				bra .30
*--------------------------------------
.22				jsr CC.IsDigit10		number ?
				bcs .24

				ldy ZPPtr2
				bne .23

				ldy #SYM.T.SINT
				sty ZPPtr2
				stz ZPPtr2+1

.23				jsr CC.EXP.GetNum
				bcs .29

				bra .30
*--------------------------------------
.24				cmp #'"'				String literal
				bne CC.EXP.Eval.ESYN

				jsr CC.EXP.AddConstCharP
.29				bcs CC.EXP.Eval.Err
*--------------------------------------
.30				jsr CC.GetCharNB
				bcs CC.EXP.Eval.ESYN

.31				jsr CC.IsEndArg			, ; ) ?
				bcc CC.EXP.Eval.End

				jsr CC.IsOPChar
				bcs CC.EXP.Eval.ESYN

				>LDYA L.CC.BOPS			we are at V1 op1 V2 op2...
				jsr CC.LookupOP
				bcs CC.EXP.Eval.ESYN

				stx ZPPtr3				save OP(n)

.33				plx						get OP(n-1)
				bmi .38					$ff....

				cpx ZPPtr3
				bcc .38					OP(n) has precedence, on stack : V1,V2

				>LDYA ZPPtr2			OP(n-1) has precedence...
				jsr CC.EXP.BOPS			compute V(n-1) <OP(n-1)> V(n)
				bcc .33

				bcs CC.EXP.Eval.Err

.38				phx						push back OP(n-1)

				lda ZPPtr3				get OP(n)
				pha						push OP(n) on stack

				jmp .10					go check for next token
*--------------------------------------
CC.EXP.Eval.End	plx						any OP on stack ?
				bmi CC.EXP.Eval.Exit

				>LDYA ZPPtr2			Var Type

				jsr CC.EXP.BOPS
				bcc CC.EXP.Eval.End

				bra CC.EXP.Eval.Err
*--------------------------------------
CC.EXP.Eval.ESYN
				lda #E.ESYN

CC.EXP.Eval.Err
				plx
				bpl CC.EXP.Eval.Err

				sec
				bra CC.EXP.Eval.ExitErr
*--------------------------------------
CC.EXP.Eval.Exit
				lda ZPPtr1+1
				ldy ZPPtr1
				bne .1

				>LDYA ZPPtr2			Type/Qual

.1				and #$FC				ignore SYM.Q.FUNC+SYM.Q.FASTCALL
				clc

CC.EXP.Eval.ExitErr
				plx
				stx ZPPtr3+1
				plx
				stx ZPPtr3

				plx
				stx ZPPtr2+1
				plx
				stx ZPPtr2

				plx
				stx ZPPtr1+1
				plx
				stx ZPPtr1

				rts
*--------------------------------------
CC.EXP.Cast		jsr CC.TYPE.Decl
				bcs .99

				>STYA ZPPtr1

				jsr CC.GetCharNB
				bcs .9

				cmp #')'
				bne .9

				jsr CC.GetNextCharNB	skip )

				clc
				rts

.9				lda #E.ESYN
				sec
.99				rts
*--------------------------------------
* Y,A = Type/Qual, X = OP
*--------------------------------------
CC.EXP.BOPS		bit #SYM.Q.PPPOINTER
				beq .10

				ldy #SYM.T.UINT
				bra .3
				
.10				cpy #SYM.T.UINT
				bcs .3

				cpy #SYM.T.UCHAR
				beq .1

				cpy #SYM.T.SCHAR
				beq .2
				
				lda #E.TMISMATCH
				sec
				rts

.1				>LDYA L.PCC.bBOPS,x
				jmp CODE.EmitPCC

.2				>LDYA L.PCC.bBOPS,x
				jmp CODE.EmitPCC

.3				txa
				clc
				adc CC.Type2FPU-SYM.T.UINT,y
				tax
				jsr CODE.FPUCALL

				clc
				rts
*--------------------------------------
CC.EXP.AddConstCharP
				lda ZPCCConst
				ldx ZPCCConst+1

				jsr CODE.LDAXI
				bcs .99

				>LDYA L.PCC.PushIAddr
				jsr CODE.EmitPCC
				bcs .99

				jsr CODE.DSSelect
				bcs .99

				ldy #0

.1				jsr CC.GetNextChar
				bcs .9

* TODO : add support for \ to next line

				cmp #C.CR
				beq .9

				cmp #'"'
				beq .2

				jsr CODE.EmitData
				bcs .99

				iny
				bra .1

.2				lda #0
				jsr CODE.EmitData
				bcs .99

				jsr CODE.CSSelect
				bcs .99

				jsr CC.GetNextChar		Skip "

				clc
				rts

.9				lda #E.ESYN
				sec
.99				rts
*--------------------------------------
CC.EXP.IntConst	>PUSHW ZPLineBufPtr
				>PUSHWI ZPLineBufPtr
				>PUSHBI 10
				>SYSCALL StrToUL

				>PULLA
				tay

				>PULLA

				inc pStack
				inc pStack

				rts
*--------------------------------------
CC.EXP.GetNum	cpy #SYM.T.FLOAT
				bcc .1

				beq .11

				lda #E.TMISMATCH
*				sec
				rts

.11				>PUSHW ZPLineBufPtr
				>PUSHWI ZPLineBufPtr
				>SYSCALL StrToF
*				bcs .9

				ldy #4

.10				lda (pStack),y
				jsr CODE.PUSHI
				dey
				bpl .10

				>POP 5
				clc
				rts
*--------------------------------------
.1				>PUSHW ZPLineBufPtr
				>PUSHWI ZPLineBufPtr
				>PUSHBI 10

				lda CC.TYPESIGN-1,y
				bmi .2

				>SYSCALL StrToUL
				bra .3

.2				>SYSCALL StrToL

.3				bcs .9

				ldy #1					anticipate 2 bytes if *
				lda ZPPtr2+1
				and #SYM.Q.PPPOINTER
				bne .5

				ldx ZPPtr2
				lda CC.TYPESIZE-1,x

				dec
				tay

.5				lda (pStack),y
				jsr CODE.PUSHI
				dey
				bpl .5

				>POP 4
*				clc
.9				rts
*--------------------------------------
* ZPPtr2 = expected T/Q
* ZPPtr3+1 = PREOPS
*--------------------------------------
CC.EXP.GetVar	stz ExpState

				jsr CC.EXP.POSTOPS		var++, var[0]... ?
				bcs .99

				ldx ZPPtr3+1			preop &, * ...
				jsr CC.EXP.PREOPS
				bcs .99

				lda ExpState
				bmi .8					VonStack

				asl

				bmi .7					AinPTR

				asl
				bmi .6					AonStack

				jsr CC.EXP.GetAddr2
				bcs .99

				bra .7

.6				>LDYA L.PCC.PopAddr2
				jsr CODE.EmitPCC
				bcs .99

.7				jsr CC.EXP.PushValue
				bcs .99
				
.8				lda ZPPtr2				target T
				beq .3

				cmp #SYM.T.VOID
				beq .2

				lda (ZPLookupSymPtr)	SYM.T
				cmp #SYM.T.VOID
				beq .2

				cmp ZPPtr2				T
				bne .9

.2				lda ZPPtr2+1			Q

				ldy #SYM.Q
				cmp (ZPLookupSymPtr),y
				bne .9
				
				clc
				rts

.3				lda (ZPLookupSymPtr)	SYM.T
				sta ZPPtr2				T

				ldy #SYM.Q
				lda (ZPLookupSymPtr),y
				sta ZPPtr2+1			Q

				clc
				rts

.9				lda #E.TMISMATCH
				sec
.99				rts
*--------------------------------------
* POSTOPS
*--------------------------------------
CC.EXP.POSTOPS	>LDYA L.CC.POSTOPS
				jsr CC.LookupOP
				bcs .8

				jmp (J.CC.POSTOPS,x)

.8				clc
				rts
*--------------------------------------
CC.EXP.postinc	lda ExpState
				bit #ExpState.AinPTR
				bne .1

				jsr CC.EXP.GetAddr2
				bcs .99

				lda #ExpState.AinPTR
				tsb ExpState

.1				ldy #SYM.Q
				lda (ZPLookupSymPtr),y
				and #SYM.Q.AAARRAY+SYM.Q.PPPOINTER
				bne .8

				lda (ZPLookupSymPtr)	#SYM.T
				cmp #SYM.T.FLOAT
				bcs .98
				
				tay

				lda CC.TYPESIZE-1,y
				lsr
				bcc .2
				
				>LDYA L.PCC.Inc1
				jmp CODE.EmitPCC

.2				lsr
				bcc .4
				
				>LDYA L.PCC.Inc2
				jmp CODE.EmitPCC
				
.4				>LDYA L.PCC.Inc4	
				jmp CODE.EmitPCC


.8				

.98				lda #E.ESYN
				sec
.99				rts
*--------------------------------------
CC.EXP.postdec	lda ExpState
				bit #ExpState.AinPTR
				bne .1

				jsr CC.EXP.GetAddr2
				bcs .99

				lda #ExpState.AinPTR
				tsb ExpState

.1				ldy #SYM.Q
				lda (ZPLookupSymPtr),y
				and #SYM.Q.AAARRAY+SYM.Q.PPPOINTER
				bne .8

				lda (ZPLookupSymPtr)	#SYM.T
				cmp #SYM.T.FLOAT
				bcs .98
				
				tay

				lda CC.TYPESIZE-1,y
				lsr
				bcc .2
				
				>LDYA L.PCC.Dec1
				jmp CODE.EmitPCC

.2				lsr
				bcc .4
				
				>LDYA L.PCC.Dec2
				jmp CODE.EmitPCC
				
.4				>LDYA L.PCC.Dec4	
				jmp CODE.EmitPCC


.8				

.98				lda #E.ESYN
				sec
.99				rts
*--------------------------------------
CC.EXP.array	ldy #SYM.Q
				lda (ZPLookupSymPtr),y
				and #SYM.Q.AAARRAY
				beq .39

				ldy #SYM.Def
				lda (ZPLookupSymPtr),y
				iny
				ora (ZPLookupSymPtr),y
				beq .1

				jsr CC.EXP.PushAddr		array[int]...
				bcc .2
				
				rts
				
.1				jsr CC.EXP.GetAddr2		array[]...it is a *
				bcs .9
				
				>LDYA L.PCC.PushDeref2
				jsr CODE.EmitPCC
				bcs .9
				
.2				jsr CC.EXP.array.getIdx	...int16 on stack...
				bcs .9

				jsr CC.EXP.GetSymSizeOfInAXC
				jsr CODE.PUSHAXI		...sizeof on stack...
				bcs .9

				ldx #FPU.iMUL
				jsr CODE.FPUCALL		...sizeof*int16...
				bcs .9

				ldx #FPU.iAdd
				jsr CODE.FPUCALL		...add to base address
				bcs .9

.3				jsr CC.GetNextCharNB	skip ']'
				bcs .98
				
				cmp #'['
				bne .8
				
				jsr CC.GetNextCharNB	skip '['
				bcs .98
				
				ldy #SYM.Q
				lda (ZPLookupSymPtr),y
				and #SYM.Q.AAARRAY
.39				beq .99
				
				jsr CC.EXP.array.getIdx	...int16 on stack...
				bcs .9
				
				ldy #SYM.Def+3
				lda (ZPLookupSymPtr),y
				tax
				dey
				lda (ZPLookupSymPtr),y
				jsr CODE.PUSHAXI		[][SIZE] on stack
				
				ldx #FPU.iMUL
				jsr CODE.FPUCALL		[][SIZE] * int16 on stack
				
				jsr CC.EXP.GetSymSizeOfInAXC
				jsr CODE.PUSHAXI		...sizeof on stack...
				bcs .9

				ldx #FPU.iMUL
				jsr CODE.FPUCALL		...sizeof*int16...
				
				ldx #FPU.iAdd
				jsr CODE.FPUCALL		...add to base address
				bcs .9
				
				jsr CC.GetNextCharNB	skip ']'
				bcs .98


* TODO : [][][]
				
.8				lda #ExpState.AonStack
				sta ExpState

				clc
				rts

.98				lda #E.ESYN
				sec
				rts

.99				lda #E.TMISMATCH
				sec
.9				rts
*--------------------------------------
CC.EXP.array.getIdx
				ldy #SYM.T.SINT
				lda #0

				jsr CC.EXP.Eval
				bcs .9

				jsr CC.GetCharNB
				bcs .98

				cmp #']'
				bne .98

				ldy #SYM.Q
				lda (ZPLookupSymPtr),y
				sec
				sbc #SYM.Q.ARRAY
				sta (ZPLookupSymPtr),y
				
				clc
				rts

.98				lda #E.ESYN
				sec
.9				rts
*--------------------------------------
CC.EXP.Struct
*--------------------------------------
CC.EXP.pStruct	lda #E.ESYN
				sec
				rts
*--------------------------------------
* PREOPS
*--------------------------------------
CC.EXP.PREOPS	bmi .8

				jmp (J.CC.PREOPS,x)

.8				clc
				rts
*--------------------------------------
CC.EXP.Ref		ldy #SYM.Q
				lda (ZPLookupSymPtr),y
				clc
				adc #SYM.Q.POINTER
				bcs .9					more than ***

				sta (ZPLookupSymPtr),y

				bit ExpState
				bvs .8

				jsr CC.EXP.PushAddr
				bcs .99

.8				lda #ExpState.VonStack
				sta ExpState

*				clc						Addr on stack
				rts

.9				lda #E.TMISMATCH
*				sec
.99				rts
*--------------------------------------
CC.EXP.Deref	ldy #SYM.Q
				lda (ZPLookupSymPtr),y
				bit #SYM.Q.PPPOINTER
				beq .9

				sec
				sbc #SYM.Q.POINTER
				sta (ZPLookupSymPtr),y

				jsr CC.EXP.GetAddr2
				bcs .99

				>LDYA L.PCC.Deref2
				jsr CODE.EmitPCC
				bcs .99
				
				lda #ExpState.AinPTR
				sta ExpState

*				clc
				rts

.9				lda #E.TMISMATCH
				sec
.99				rts
*--------------------------------------
CC.EXP.Abs

				clc

.99				rts
*--------------------------------------
CC.EXP.negate

				clc

.99				rts
*--------------------------------------
CC.EXP.lnot

				clc

.99				rts
*--------------------------------------
CC.EXP.bnot

				clc

.99				rts
*--------------------------------------
CC.EXP.preinc

				clc

.99				rts
*--------------------------------------
CC.EXP.predec

				clc

.99				rts
*--------------------------------------
CC.EXP.PushAddr	ldy #SYM.SC
				lda (ZPLookupSymPtr),y
				beq .1					SYM.SC.STATIC
* LOCAL

				>LDYA L.PCC.PushLAddrH
				jsr CODE.EmitPCC
				bcs .9

				ldy #SYM.Addr
				lda (ZPLookupSymPtr),y
				eor #$FF
				inc
				jsr CODE.LDAI
				bcs .9

				>LDYA L.PCC.PushLAddrL
				jmp CODE.EmitPCC

* GLOBAL

.1				ldy #SYM.Addr+1
				lda (ZPLookupSymPtr),y
				tax

				dey
				lda (ZPLookupSymPtr),y

				jsr CODE.LDAXI
				bcs .9

				ldy #SYM.Q
				lda (ZPLookupSymPtr),y
				and #SYM.Q.CONST
				beq .2

				>LDYA L.PCC.PushIAddr
				jmp CODE.EmitPCC

.2				>LDYA L.PCC.PushUAddr
				jmp CODE.EmitPCC
				
.9				rts
*--------------------------------------
CC.EXP.GetAddr1	ldy #SYM.SC
				lda (ZPLookupSymPtr),y
				beq .1					SYM.SC.STATIC
* LOCAL
				ldy #SYM.Addr
				lda (ZPLookupSymPtr),y
				eor #$FF
				inc
				jsr CODE.LDAI
				bcs .9

				>LDYA L.PCC.GetLAddr1
				jmp CODE.EmitPCC
* GLOBAL

.1				ldy #SYM.Addr+1
				lda (ZPLookupSymPtr),y
				tax

				dey
				lda (ZPLookupSymPtr),y

				jsr CODE.LDAXI
				bcs .9

				ldy #SYM.Q
				lda (ZPLookupSymPtr),y
				and #SYM.Q.CONST
				beq .2

				>LDYA L.PCC.GetIAddr1
				jmp CODE.EmitPCC

.2				>LDYA L.PCC.GetUAddr1
				jmp CODE.EmitPCC

.9				rts
*--------------------------------------
CC.EXP.GetAddr2	ldy #SYM.SC
				lda (ZPLookupSymPtr),y
				beq .1					SYM.SC.STATIC
* LOCAL
				ldy #SYM.Addr
				lda (ZPLookupSymPtr),y
				eor #$FF
				inc
				jsr CODE.LDAI
				bcs .9

				>LDYA L.PCC.GetLAddr2
				jmp CODE.EmitPCC
* GLOBAL

.1				ldy #SYM.Addr+1
				lda (ZPLookupSymPtr),y
				tax

				dey
				lda (ZPLookupSymPtr),y

				jsr CODE.LDAXI
				bcs .9

				ldy #SYM.Q
				lda (ZPLookupSymPtr),y
				and #SYM.Q.CONST
				beq .2

				>LDYA L.PCC.GetIAddr2
				jmp CODE.EmitPCC

.2				>LDYA L.PCC.GetUAddr2
				jmp CODE.EmitPCC

.9				rts
*--------------------------------------
CC.EXP.PushValue
				jsr CC.EXP.GetSymSizeOfInAXC
				tay
				dey
				jsr CODE.LDYI
				bcs .99

				>LDYA L.PCC.PushValue
				jmp CODE.EmitPCC
				
.99				rts
*--------------------------------------
* out : A,X,C = size
*--------------------------------------
CC.EXP.GetSymSizeOfInAXC
				ldy #SYM.Q
				lda (ZPLookupSymPtr),y
				pha
				lda (ZPLookupSymPtr)	SYM.T
				tay
				pla

CC.EXP.GetYASizeOfInAXC

				bit #SYM.Q.PPPOINTER+SYM.Q.AAARRAY
				bne .1

				lda CC.TYPESIZE-1,y
				ldx #0

				clc
				rts

.1				lda #2					pointer
				ldx #0

				sec						+1 for hMem Storage
				rts
*--------------------------------------
MAN
SAVE usr/src/bin/cc.s.exp
LOAD usr/src/bin/cc.s
ASM
