NEW
PREFIX /A2OSX.BUILD
AUTO 4,1
*---------------------------------------
SRC.PrintLine		>LDA.G ASM.LI.ON
					bpl .9
					>LDA.G MAC.bAdd
					bpl .1
					
					>LDA.G ASM.LI.MON
					bpl .9
					bmi .8
					
.1					
.8					>PUSHW ZPLineBuf
					>PUSHW.G SRC.LINENUM
					ldy #ASM.PC+1
					>PUSHB (pData),y
					dey
					>PUSHB (pData),y
					>LDYA L.MSG.SRCLINE
					>SYSCALL PrintF.YA
.9					rts
*---------------------------------------
SRC.PrintLineErr	>PUSHW ZPLineBuf
					>LDYA L.MSG.LINECR
					>SYSCALL PrintF.YA
					bcs .9
					
					ldx ZPLinePtr
					cpx ZPLineBuf
					beq .4
					
.3					phx
					lda #'-'
					>SYSCALL PutChar.A
					plx
					bcs .9
					dex
					cpx ZPLineBuf
					bne .3
					
.4					lda #'^'
					phy
					>SYSCALL PutChar.A
					ply
					bcs .9

.5					lda #13
					>SYSCALL PutChar.A
					lda #10
					>SYSCALL PutChar.A
					
.9					rts
*---------------------------------------
SRC.ParseLine		jsr SRC.GetChar
					bcs .8
					
					cmp #'*'			Comment?
					beq .8
					cmp #';'			Comment?
					beq .8
					
					>LDA.G MAC.bAdd
					bmi SRC.ParseLine.MACRO

					jmp SRC.ParseLine.LABEL
					
.8					clc
					rts
					
SRC.ParseLine.Macro >LDA.G ASM.PASS		If Pass#2, ignore
					bne .8

					lda (ZPLinePtr)
					cmp #' '			No label, scan to DIR/OP if any
					bne .1
					
					jsr SRC.GetNextCharNB
					bcs .8
					
					lda #' '			Store ONE blank
					jsr MAC.AddChar
					bcs .90
					
					lda (ZPLinePtr)		get back non blank char
					bra .2
					
.1					jsr MAC.AddChar
					bcs .99
								
					jsr SRC.GetNextChar
					bcs .80
					cmp #' '
					bne .1
					
					jsr MAC.AddChar
.90					bcs .99
					
					jsr SRC.GetNextCharNB
					bcs .80
					
.2					cmp #'.'			Directive ?
					bne .4

					ldy #1
					lda (ZPLinePtr),y
					beq .3
					cmp #'E'
					beq .21
					cmp #'e'
					bne .3
					
.21					iny
					lda (ZPLinePtr),y
					beq .3
					cmp #'M'
					beq .22
					cmp #'m'
					bne .3
					
.22					jsr MAC.Store
					bcs SRC.ParseLine.RTS
					
					lda #0
					>STA.G MAC.bAdd
					
.8					clc
					rts

.80					lda #0
					jmp MAC.AddChar
					
.3					lda (ZPLinePtr)
					
.4					jsr MAC.AddChar
					bcs .99
								
					jsr SRC.GetNextChar
					bcs .80
					cmp #' '
					bne .4
					
					jsr SRC.GetNextChar
					bcs .8
					cmp #' '
					beq .80				Comments...
					
					pha
					
					lda #' '
					jsr MAC.AddChar
					
					pla
					bcs .99
					
.5					jsr MAC.AddChar		Store ARG....
					bcs .99
								
					jsr SRC.GetNextChar
					bcs .80
					cmp #' '
					bne .5

					lda #0
					jmp MAC.AddChar		End of Line
					clc
					rts
					
.99					lda #ERR.MACRO.TOO.BIG					
					sec
					
SRC.ParseLine.RTS	rts
*---------------------------------------
SRC.ParseLine.LABEL	lda #0
					sta (ZPLocalBuf)
					>STA.G SYM.bGlobal

					jsr SRC.GetChar
					cmp #' '			no label...go scan dir/opcode
					beq SRC.ParseLine.DirOp
					
					cmp #'.'			local symbol?
					bne	.1

					jsr SRC.GetNextChar
					bcs SRC.ParseLine.InvLbl
					jsr SRC.GetDecimal
					bcs SRC.ParseLine.InvLbl
					
					lda SRC.ACC+1
					ora SRC.ACC+2
					ora SRC.ACC+3
					bne SRC.ParseLine.InvLbl	Max .255
					lda SRC.ACC
					beq SRC.ParseLine.InvLbl	.0 is not allowed

					jsr SYM.AddLocalPC
					bcs SRC.ParseLine.RTS
					bra SRC.ParseLine.DirOp

.1					lda #$ff
					>STA.G SYM.bGlobal

					>LDA.G ASM.PASS
					bne .3

					jsr SYM.AddGlobalPC		Pass #1; try to add global...
					bcc SRC.ParseLine.DirOp yes!!! go scan dir/op
					
					jsr SYM.LookupGlobal	already defined...get it
					
					>LDA.G SYM.Lookup+SYM.F
					bit #SYM.F.RW
					bne .2					R/W, always update...
					
					bit #SYM.F.RESOLVED
					bne SRC.ParseLine.Redef
					
.2					jsr SYM.UpdateGlobal
					bra SRC.ParseLine.DirOp
					
.3					jsr SYM.LookupGlobal	Pass #2: should be already defined...
					bcs SRC.ParseLine.Undef

					jsr SYM.UpdateGlobalPC
					
*---------------------------------------				
SRC.ParseLine.DirOp	jsr SRC.GetNextCharNB	Scan for an Opcode...
					bcs SRC.ParseLine.Ok
					
					cmp #'.'
					bne .5
					
					jsr SRC.GetNextChar
					bcs SRC.ParseLine.InvDir
					
					jsr SRC.ParseLine.Dir
					bcs SRC.ParseLine.Err
					bra SRC.ParseLine.Ok

.5					cmp #'>'
					bne .6
					
					jsr SRC.ParseLine.ExecMacro
					bcs SRC.ParseLine.Err
					bra SRC.ParseLine.Ok
					
.6					jsr SRC.ParseLine.OpCode
					bcs SRC.ParseLine.Err

SRC.ParseLine.Ok	clc
					rts

SRC.ParseLine.InvLbl
					lda #ERR.INV.LABEL
SRC.ParseLine.Err	sec
					rts
					
SRC.ParseLine.Redef lda #ERR.SYMBOL.REDEF
					sec
					rts
					
SRC.ParseLine.Undef	lda #ERR.UNDEF.SYMBOL
					sec
					rts
SRC.ParseLine.InvDir
					lda #ERR.INV.DIR
					sec
					rts
*---------------------------------------
SRC.ParseLine.Dir	>LDYA L.T.DIRECTIVES
					jsr SRC.GetKeyword

					bcs SRC.ParseLine.InvDir
					
					jmp (J.DIRECTIVES,x)
*---------------------------------------
SRC.ParseLine.ExecMacro
					
					
					clc
					rts
*---------------------------------------
SRC.ParseLine.OpCode
					stz SRC.AM.ID
					
					>LDYA ZPOPtr
					>STYA ZPPtr1
					
.1					lda (ZPPtr1)		End Of OpCode List
					ldy #1
					ora (ZPPtr1),y
					beq .9
					
					lda ZPPtr1
					clc
					adc #2
					sta ZPPtr2
					lda ZPPtr1+1
					adc #0
					sta ZPPtr2+1
					
					lda (ZPPtr2)
					tax
					
					ldy #0
					
.2					lda (ZPLinePtr),y
					beq .7
					
					cmp #'a'
					bcc .3
					cmp #'z'+1
					bcs .3
					
					eor #$20
					
.3					iny
					cmp (ZPPtr2),y
					bne .7
					
					dex
					bne .2
					
					lda (ZPLinePtr),y
					beq .8				End of Line, no AM
					
					cmp #' '			A space after opcode ?
					bne .7
					
					tya
					sec					skip OP + ' '
					adc ZPLinePtr
					sta ZPLinePtr
					bcc .5
					
					inc ZPLinePtr+1
					
.5					bra SRC.ParseLine.AM
					
.7					lda ZPPtr1
					clc
					adc (ZPPtr1)
					tax
					lda ZPPtr1+1
					ldy #1
					adc (ZPPtr1),y
					stx ZPPtr1
					sta ZPPtr1+1
					bra .1
					
.8					clc
					rts
					
.9					lda #ERR.INV.OPCODE
					sec
.99					rts
*---------------------------------------
SRC.ParseLine.AM	stz SRC.AM.StrBuf

.1					jsr SRC.GetChar
					bcs .8
					
.10					cmp #' '			another space ?
					beq .8				ignore end of line (comment)
					
					jsr SRC.IsAMReserved
					bcs .2
					
					inc SRC.AM.StrBuf
					ldx SRC.AM.StrBuf
					sta SRC.AM.StrBuf,x
					bra .7
					
.2					jsr SRC.IsMODReserved
					bcs .3
					
					lda #'#'
					inc SRC.AM.StrBuf
					ldx SRC.AM.StrBuf
					sta SRC.AM.StrBuf,x
					bra .7
					
.3					jsr SRC.IsLetter	Any register?
					bcs .6				no, try something else
					
					>LDYA ZPRPtr
					jsr SRC.GetKeyword
					bcs .6
					
					lda (ZPPtr1)		get register len
					tax
					
					ldy SRC.AM.StrBuf
					
.4					inc ZPPtr1
					bne .5
					inc ZPPtr1+1
					
.5					lda (ZPPtr1)
					iny
					sta SRC.AM.StrBuf,y
					dex
					bne .4
					
					sty SRC.AM.StrBuf
					
					bra .1
					
.6					jsr EXP.Eval
					bcs .99
					
					ldx #3
.73					lda SRC.ACC,x					
					bne .72
					dex
					bne .73
					
.72					inx
					lda #'a'
					
					ldy SRC.AM.StrBuf
					
.71					iny
					sta SRC.AM.StrBuf,y
					dex
					bne .71

					sty SRC.AM.StrBuf
					bra .1
					
.7					jsr SRC.GetNextChar
					bcc .10
					
.8					clc
					rts
	
.9					lda #ERR.INV.AM.SYN
					sec
.99					rts
*---------------------------------------
SRC.GetDecimal		jsr SRC.GetChar
					beq .99
					
					stz SRC.ACC+1
					stz SRC.ACC+2
					stz SRC.ACC+3
					
					jsr SRC.IsDigit10
					bcs .99
					
					and #$0F
					sta SRC.ACC
					
.1					jsr SRC.GetNextChar
					bcs .8
					
					cmp #' '
					beq .8
					
					jsr SRC.IsEXPReserved
					bcc .8
					
					jsr SRC.IsAMReserved
					bcc .8
					
					jsr SRC.IsDigit10
					bcs .9
					
					and #$0F
					
					pha
					jsr SRC.ACC10
					pla
					bcs .9

					adc SRC.ACC
					sta SRC.ACC
					bcc .1
					
					inc SRC.ACC+1
					bne .1
					inc SRC.ACC+2
					bne .1
					inc SRC.ACC+3
					bne .1
					
.9					lda #ERR.VAL.TOO.BIG
					sec
					rts

.8					clc
					rts
					
.99					lda #ERR.SYNTAX.ERROR
					sec
					rts
*---------------------------------------
SRC.GetHex			jsr SRC.GetNextChar	skip '$'
					bcs .99
					
					stz SRC.ACC+1
					stz SRC.ACC+2
					stz SRC.ACC+3
					
					jsr SRC.IsDigit16
					bcs .99

					sta SRC.ACC
					
.1					jsr SRC.GetNextChar
					bcs .8
					
					cmp #' '
					beq .8
					jsr SRC.IsEXPReserved
					bcc .8
					jsr SRC.IsAMReserved
					bcc .8
					jsr SRC.IsDigit16
					bcs .99
					
					ldx #4
.2					asl SRC.ACC
					rol SRC.ACC+1
					rol SRC.ACC+2
					rol SRC.ACC+3
					bcs .9
					dex
					bne .2
					ora SRC.ACC
					sta SRC.ACC
					bra .1
					
.8					clc
					rts
					
.9					lda #ERR.VAL.TOO.BIG
					sec
					rts
					
.99					lda #ERR.SYNTAX.ERROR
					sec
					rts
*---------------------------------------
SRC.GetOctal		jsr SRC.GetNextChar	skip '&'
					bcs .99
					
					stz SRC.ACC+1
					stz SRC.ACC+2
					stz SRC.ACC+3
					
					jsr SRC.IsDigit8
					bcs .99
					
					and #$0F
					sta SRC.ACC
					
.1					jsr SRC.GetNextChar
					bcs .8
					
					cmp #' '
					beq .8
					
					jsr SRC.IsEXPReserved
					bcc .8
					
					jsr SRC.IsAMReserved
					bcc .8
					
					jsr SRC.IsDigit8
					bcs .9
					
					asl
					asl
					asl
					asl
					asl
					
					ldx #3
.2					asl
					rol SRC.ACC
					rol SRC.ACC+1
					rol SRC.ACC+2
					rol SRC.ACC+3
					bcs .9
					dex
					bne .2
					bra .1
					
.8					clc
					rts
					
.9					lda #ERR.VAL.TOO.BIG
					sec
					rts
					
.99					lda #ERR.SYNTAX.ERROR
					sec
					rts
*---------------------------------------
SRC.GetBinary		jsr SRC.GetNextChar	skip '%'
					bcs .99
					
					stz SRC.ACC+1
					stz SRC.ACC+2
					stz SRC.ACC+3
					
					cmp #'1'
					beq .10
					
					cmp #'0'
					bne .99
					
.10					and #$01
					sta SRC.ACC
					
.1					jsr SRC.GetNextChar
					bcs .8
					
					cmp #' '
					beq .8
					
					jsr SRC.IsEXPReserved
					bcc .8
					
					jsr SRC.IsAMReserved
					bcc .8
					
					cmp #'1'
					beq .11
					
					cmp #'0'
					bne .8
					
.11					lsr
					
					rol SRC.ACC
					rol SRC.ACC+1
					rol SRC.ACC+2
					rol SRC.ACC+3
					bcs .9
					bra .1
					
.8					clc
					rts
					
.9					lda #ERR.VAL.TOO.BIG
					sec
					rts
					
.99					lda #ERR.SYNTAX.ERROR
					sec
					rts
*---------------------------------------
SRC.GetKeyword		>STYA ZPPtr1		KeyWord table

					stz SRC.Keyword.ID
					
.1					lda (ZPPtr1)
					beq .9				End Of table
					
					tax					KW len
					
.2					ldy #0

.3					lda (ZPLinePtr),y
					beq .5
					
					jsr SRC.IsLetterUC
					bcs .5
					
					iny
					cmp (ZPPtr1),y
					bne .5
					
					dex
					bne .3
					
					lda (ZPLinePtr),y	All chars match...
					beq .4				End of Line ?
					
					jsr SRC.IsLetter
					bcc .5				Additional letters...
					
.4					lda ZPLinePtr
					clc
					adc (ZPPtr1)
					sta ZPLinePtr
					bcc .41
					inc ZPLinePtr+1
.41					ldx SRC.Keyword.ID
					clc
					rts

.5					lda (ZPPtr1)
					sec					Add keyword Len+1
					adc ZPPtr1
					sta ZPPtr1
					bcc .6
					
					inc ZPPtr1+1
					
.6					inc SRC.Keyword.ID
					inc SRC.Keyword.ID
					bra .1
					
.9					sec
					rts
*---------------------------------------
SRC.IsAMReserved	ldx SRC.AM.RESERVED
.1					cmp SRC.AM.RESERVED,x
					beq .8
					dex
					bne .1
					sec
					rts
.8					clc
					rts					
*---------------------------------------
SRC.IsMODReserved	ldx SRC.MOD.RESERVED
.1					cmp SRC.MOD.RESERVED,x
					beq .8
					dex
					bne .1
					sec
					rts
					
.8					clc
					rts					
*---------------------------------------
SRC.IsEXPReserved	ldx SRC.EXP.RESERVED
.1					cmp SRC.EXP.RESERVED,x
					beq .8
					dex
					bne .1
					sec
					rts
					
.8					clc
					rts					
*---------------------------------------
SRC.IsLetterUC		cmp #'A'
					bcc .9
					cmp #'Z'+1
					bcc .99

					cmp #'a'
					bcc .9
					cmp #'z'+1
					
					eor #$20
					
					rts					CC if lowercase
					
.9					sec					
.99					rts	
*---------------------------------------
SRC.IsLetterOrDigit jsr SRC.IsDigit10
					bcc SRC.IsLetterRTS
*---------------------------------------
SRC.IsLetter		cmp #'A'
					bcc .9
					cmp #'Z'+1
					bcc SRC.IsLetterRTS

					cmp #'a'
					bcc .9
					cmp #'z'+1
					rts					CC if lowercase
					
.9					sec					
SRC.IsLetterRTS		rts					
*---------------------------------------
SRC.IsDigit16		jsr SRC.IsDigit10
					bcc .8
					cmp #'A'
					bcc .9
					cmp #'F'+1
					bcc .1
					rts					cc if ok, cs if not
					
.1					sbc #'A'-11			cc so A->10 (11-CC)
					clc
.8					and #$0F					
					rts
					
.9					sec
					rts
*---------------------------------------
SRC.IsDigit10		cmp #'0'
					bcc .9
					cmp #'9'+1
					rts					cc if ok, cs if not
					
.9					sec
					rts
*---------------------------------------
SRC.IsDigit8		cmp #'0'
					bcc .9
					cmp #'7'+1
					rts					cc if ok, cs if not
					
.9					sec
					rts
*---------------------------------------
SRC.GetNextCharNB	jsr SRC.GetNextChar
					bcs .9
					cmp #' '
					beq SRC.GetNextCharNB
					
					clc
					
.9					rts
*---------------------------------------
SRC.GetNextCharUC	jsr SRC.GetNextChar
					bcs .9
					cmp #'a'
					bcc .8
					cmp #'z'+1
					bcs .8
					eor #$20			to Uppercase
					
.8					clc
.9					rts
*---------------------------------------
SRC.GetNextChar		lda (ZPLinePtr)
					beq SRC.GetChar.ERR
					cmp #$0D
					beq SRC.GetChar.ERR
					
					inc ZPLinePtr
					bne SRC.GetChar
					
					inc ZPLinePtr+1
					
SRC.GetChar			lda (ZPLinePtr)
					beq SRC.GetChar.ERR
					cmp #$0D
					beq SRC.GetChar.ERR
					
					clc
					rts
					
SRC.GetChar.ERR		sec
					rts
*---------------------------------------
SRC.ACC10			lda SRC.ACC			ACC*2-> ACC & ACCTMP
					asl
					sta SRC.ACC
					sta SRC.ACCTMP
					lda SRC.ACC+1
					rol
					sta SRC.ACC+1
					sta SRC.ACCTMP+1
					lda SRC.ACC+2
					rol
					sta SRC.ACC+2
					sta SRC.ACCTMP+2
					lda SRC.ACC+3
					rol
					sta SRC.ACC+3
					sta SRC.ACCTMP+3
					bcs .9
					
					ldx #2
.1					asl SRC.ACC			ACC=ACC*4
					rol SRC.ACC+1
					rol SRC.ACC+2
					rol SRC.ACC+3
					bcs .9
					dex
					bne .1
					
					lda SRC.ACC			CC from ROL SRC.ACC+3
					adc SRC.ACCTMP
					sta SRC.ACC
					lda SRC.ACC+1
					adc SRC.ACCTMP+1
					sta SRC.ACC+1
					lda SRC.ACC+2
					adc SRC.ACCTMP+2
					sta SRC.ACC+2
					lda SRC.ACC+3
					adc SRC.ACCTMP+3
					sta SRC.ACC+3		CS if overflow
					
.9					rts					
*---------------------------------------
MAN
SAVE /A2OSX.BUILD/BIN/DEV/ASM.S.SRC
LOAD /A2OSX.BUILD/BIN/DEV/ASM.S
ASM
