NEW
  AUTO 3,1
*--------------------------------------
* Built in Keywords
*--------------------------------------
CC.KW.IF		jsr CC.KW.BEGIN00
				bcs .99

				jsr CC.GetCharNB
				bcs .9

				cmp #'('
				bne .9

				jsr CC.GetNextCharNB
				bcs .9

				jsr CC.EXP.Eval00		Any var type
				bcs .99

				jsr CC.KW.TestZero		Y,A=T/Q

				lda #'E'
				jsr CC.SYM.LookupA
				bcs .99

				lda #$4C				emit JMP else
				jsr CODE.TOABSYX
				bcs .99

				jsr CC.GetCharNB
				bcs .99

				cmp #')'
				bne .9

				jmp CC.KW.STMT

.9				lda #E.CSYN
				sec
.99				rts
*--------------------------------------
CC.KW.IF.END	jsr CC.GetCharNBNL
				bcs .1

				cmp #';'
				beq .1

				>LDYA L.CC.KW2.IF		Check allowed KW for IF....
				jsr CC.LookupID
				bcc .2

.1				lda #'E'				define ELSE Label
				jsr CC.KW.NewLabel
				bcs .99

				clv						pop context
				rts
*--------------------------------------
.2				lda #'X'
				jsr CC.SYM.LookupA
				bcs .99

				lda #$4C				emit JMP exit
				jsr CODE.TOABSYX
				bcs .99

				lda #'E'				define ELSE Label
				jsr CC.KW.NewLabel
				bcs .99

				inc CStackPtr			pop ; or }

				lda #4					replace IF by ELSE keyword
				ldy CStackPtr
				sta (ZPCCStack),y

				jsr CC.KW.STMT
				bcs .99

				bit .99					set V : DONT pop context
				rts

.9				lda #E.CSYN
				sec
.99				rts
*--------------------------------------
CC.KW.ELSE		lda #E.CSYN				illegal
				sec
				rts
*--------------------------------------
CC.KW.ELSE.END	lda #'X'				define EXIT Label
				jsr CC.KW.NewLabel
				bcs .99

				clv						pop context
.99				rts
*--------------------------------------
CC.KW.WHILE		jsr CC.KW.BEGIN00
				bcs .99

				lda #'C'				define CONT Label
				jsr CC.SYM.NewA
				bcs .99

				jsr CC.GetCharNB
				bcs .9

				cmp #'('
				bne .9

				jsr CC.GetNextCharNB
				bcs .9

				jsr CC.EXP.Eval00		Any var type
				bcs .99

				jsr CC.KW.TestZero

				lda #'B'
				jsr CC.SYM.LookupA
				bcs .99

				lda #$4C				emit JMP break:
				jsr CODE.TOABSYX
				bcs .99

				jsr CC.GetCharNB
				bcs .99

				cmp #')'
				bne .9

				jmp CC.KW.STMT

.9				lda #E.CSYN
				sec
.99				rts
*--------------------------------------
CC.KW.WHILE.END	lda #'C'
				jsr CC.KW.GetLabel
				bcs .99

				lda #$4C
				jsr CODE.TOABSYX		emit JMP cont:
				bcs .99

				lda #'B'				define BREAK Label
				jsr CC.KW.NewLabel
				bcs .99

				clv						pop context

.99				rts
*--------------------------------------
CC.KW.DO		jsr CC.KW.BEGIN00
				bcs .99

				lda #'C'				define CONT Label
				jsr CC.SYM.NewA
				bcs .99

				jmp CC.KW.STMT

.99				rts
*--------------------------------------
CC.KW.DO.END	>LDYA L.CC.KW2.DO		Check allowed KW for DO....
				jsr CC.LookupID
				bcs .9

				jsr CC.GetCharNB
				bcs .9

				cmp #'('
				bne .9

				jsr CC.GetNextCharNB
				bcs .9

				jsr CC.EXP.Eval00		Any var type
				bcs .99

				jsr CC.KW.TestnZero

				lda #'C'
				jsr CC.KW.GetLabel
				bcs .99

				lda #$4C				emit JMP cont
				jsr CODE.TOABSYX
				bcs .99

				lda #'B'				define BREAK Label
				jsr CC.KW.NewLabel
				bcs .99

				jsr CC.GetCharNB
				bcs .99

				cmp #')'
				bne .9

				jsr CC.GetNextCharNB
				bcs .9

				clv						pop context
				clc
				rts

.9				lda #E.CSYN
				sec
.99				rts
*--------------------------------------
* for (s1;e2;s3) s;
*
* {				<- new scope : allows for(int i=1; ....)
* 	s1;
*	loop:
* 	while (e2)	jmp break:
* 	{
* 	   s;		jsr s:
* 	cont:
* 	   s3;		jmp loop:
* 	}
* s:
* <s>;
* break:
* }
*--------------------------------------
CC.KW.FOR		jsr CC.GetCharNB
				bcs .29

				cmp #'('
				bne .29

				jsr CC.KW.BEGIN00
				bcs .29

				jsr CC.GetNextCharNB	skip '('
				bcs .29

				>LDYA L.CC.TYPEQUAL
				jsr CC.LookupID
				bcs .1

				jsr CC.DECL
				bcc .2

.19				rts

.1				jsr CC.STMT				get s1
				bcs .19

*				jsr CC.KW.StackDiscard

.2				jsr CC.GetCharNB
				bcs .9

				cmp #';'
				bne .9

				jsr CC.GetNextCharNB	skip ';'
				bcs .9
*--------------------------------------
				lda #'L'				LOOP Label
				jsr CC.SYM.NewA
				bcs .99

				jsr CC.EXP.Eval00		get e2
.29				bcs .99

				jsr CC.KW.TestZero
				bcs .99

				lda #'B'
				jsr CC.SYM.LookupA
				bcs .99

				lda #$4C				emit JMP break:
				jsr CODE.TOABSYX

				lda #'S'
				jsr CC.SYM.LookupA
				bcs .99

				lda #$20				emit JSR s:
				jsr CODE.TOABSYX

				jsr CC.GetCharNB
				bcs .9

				cmp #';'
				bne .9

				jsr CC.GetNextCharNB	skip ';'
				bcs .9
*--------------------------------------
				lda #'C'				CONT Label
				jsr CC.SYM.NewA
				bcs .99

				jsr CC.STMT				get s3
				bcs .99

*				jsr CC.KW.StackDiscard

				jsr CC.GetCharNB
				bcs .9

				cmp #')'
				bne .9

				lda #'L'
				jsr CC.SYM.LookupA
				bcs .99

				lda #$4C
				jsr CODE.TOABSYX		emit JMP loop

				lda #'S'				S Label
				jsr CC.SYM.NewA
				bcs .99

				jmp CC.KW.STMT

.9				lda #E.CSYN
				sec
.99				rts
*--------------------------------------
CC.KW.FOR.END	lda #$60

				jsr CODE.EmitByte		set RTS for JSR code;
				bcs .99

				lda #'B'				define BREAK Label
				jsr CC.KW.NewLabel
				bcs .99

				clv						pop context

.99				rts
*--------------------------------------
CC.KW.SWITCH	jsr CC.GetCharNB
				bcs .98

				cmp #'('
				bne .98

				jsr CC.GetNextCharNB
				bcs .98

				jsr CC.EXP.Eval00		Any var type
				bcs .99					Y,A=T/Q

				tax
				bne .97

				cpy #SYM.T.UCHAR
				bcc .97

				cpy #SYM.T.FLOAT
				bcs .97

				phy
				tya
				jsr CC.Push				push integral type
				ply
				bcs .99

				lda CC.TYPESIZE-1,y

				jsr CC.Push				push SizeOf(type)
				bcs .99

				jsr CC.KW.BEGIN
				bcs .99

				jsr CC.GetCharNB
				bcs .99

				cmp #')'
				bne .98

				jmp CC.KW.STMT

.97				lda #E.TMISMATCH
				sec
				rts

.98				lda #E.CSYN
				sec
.99				rts
*--------------------------------------
CC.KW.SWITCH.END
				lda #'B'				define BREAK Label
				jsr CC.KW.NewLabel
				bcs .99

				clv						pop context

.99				rts
*--------------------------------------
CC.KW.CASE		ldy CStackPtr
				beq .9

				iny 					skip ; or }
				lda (ZPCCStack),y
				cmp #10					SWITCH ??
				bne .9

				lda CStackPtr
				clc
				adc #7
				tay

				lda (ZPCCStack),y		type
				tay
				lda #0					for integral type

				jsr CC.EXP.Eval
				bcs .99

				jsr CC.GetCharNB
				bcs .9

				cmp #':'
				bne .9

				jsr CC.GetNextCharNB	skip ':'

				clc
				rts

.9				lda #E.CSYN
				sec
.99				rts
*--------------------------------------
CC.KW.DEFAULT	ldy CStackPtr
				beq .9

				iny 					skip ; or }
				lda (ZPCCStack),y
				cmp #10					SWITCH ??
				bne .9

				jsr CC.GetCharNB
				bcs .9

				cmp #':'
				bne .9

				jsr CC.GetNextCharNB	skip ':'

				clc
				rts

.9				lda #E.CSYN
				sec
.99				rts
*--------------------------------------
CC.KW.BREAK		lda #'B'

				jsr CC.KW.LookupLabel
				bcs .9

				lda #$4C				emit JMP break
				jmp CODE.TOABSYX

.9				lda #E.CSYN
				sec
				rts
*--------------------------------------
CC.KW.CONTINUE	lda #'C'

				jsr CC.KW.LookupLabel
				bcs .9

				lda #$4C				emit JMP cont
				jmp CODE.TOABSYX

.9				lda #E.CSYN
				sec
				rts
*--------------------------------------
CC.KW.RETURN	ldy CStackPtr
				beq .9

.1				iny 					skip ; or }
				lda (ZPCCStack),y
				bmi .7					f()

				tya
				clc
				adc #5					skip CPStmt (6 bytes)
				tay
				bcc .1

.9				lda #E.STACKERROR
				sec
.99				rts

.7				iny						skip bState
				iny						skip Locals

				iny
				iny						skip CPSID

				iny						get SYM.T
				lda (ZPCCStack),y

				pha

				iny						get SYM.Q
				lda (ZPCCStack),y

				ply

				jsr CC.EXP.Eval
				bcs .99

				jsr CC.SYM.GetYASizeOfInAXC		Y,A=T/Q
				tax						X = sizeof
				jsr CODE.SetRetValue
				bcs .99

				>LDYA L.PCC.LEAVE
				jmp CODE.EmitPCC
*--------------------------------------
CC.KW.SIZEOF
				lda #E.CSYN
				sec
				rts
*--------------------------------------
CC.KW.STRUCT	clc
				.HS B0					BCS
*--------------------------------------
CC.KW.UNION		sec
				stz ZPPtr2				bNewTagDef
				
				ror ZPPtr2+1			bStrucUnion

				bit bPass2
				bpl CC.KW.SU.1			Pass 1: create def
*--------------------------------------
CC.KW.SU.2		jsr CC.GetNextCharNB
				bcs .98

				cmp #'{'
				beq .1					no TAG

				jsr CC.KW.GetTag
				bcs .99

				jsr CC.GetNextCharNBNL
				bcs .98

				cmp #'{'
				bne .2

.1				jsr CC.GetNextCharNBNL	skip '{'

				cmp #'}'
				bne .1

				jsr CC.GetNextCharNBNL	skip '}'

				cmp #';'
				bne .2

				jsr CC.GetNextCharNB	skip ';'

				clc
				rts

.2				clc						reuse buffer

				jsr CC.SYM.Lookup
				bcs .99

				jsr CC.GetCharNB
				bcs .98

				cmp #','
				bne .3

				jsr CC.GetNextCharNBNL
				bcc .2
				bcs .98

.3				cmp #';'
				bne .98

				clc
				rts

.98				lda #E.CSYN
				sec
.99				rts
*--------------------------------------
CC.KW.SU.1		ldy #SYM.T.SU
				lda #0
				ldx #SYM.SC.TAG
				sec						reset buffer
				jsr CC.SYM.BufInitYAX

				jsr CC.GetNextCharNB
				bcs .98

				cmp #'{'
				beq .30					no TAG

				jsr CC.KW.NewTag
				bcc .20

				jsr CC.KW.GetTag
				bcs .99
*--------------------------------------
.20				jsr CC.GetNextCharNBNL
				bcs .98

				cmp #'{'
				beq .30
				
				bit ZPPtr2				bNewTagDef
				bmi .98
				
				bra .41					go create vars...
*--------------------------------------
.30				jsr CC.GetNextCharNBNL	skip '{' of ';'
				bcs .98

				cmp #'}'
				beq .38

				>LDYA L.CC.TYPEQUAL
				jsr CC.LookupID
				bcs .98

				cpx #4					no const nor volatile
				bcc .98

				jsr CC.TYPE.Decl
				bcs .99

				jsr CC.TYPE.SizeOf		get sizeof in X

				jsr CC.KW.SU.AddYAX
				bcs .99

				jsr CC.SYM.Add0000		TODO: bitO & bitW
				bcs .99

				jsr CC.SYM.AddName
				bcs .99

				jsr CC.GetCharNB
				cmp #';'
				bne .98

				bra .30

.38				jsr CC.GetNextCharNB	skip '}'
				bcs .98

				jsr CC.SYM.Add0000		Close F definition
				bcs .99

				cmp #';'
				bne .40

				jsr CC.GetNextCharNB	skip ';'

				bit ZPPtr2				bNewTagDef
				bpl .98					no tag & no var, error

				jmp CC.KW.StoreTag
*--------------------------------------
.98				lda #E.CSYN
				sec
.99				rts
*--------------------------------------
.40				bit ZPPtr2				bNewTagDef
				bpl .41

				jsr CC.KW.StoreTag
				bcs .99

.41				clc						reuse buffer

				ldy #SYM.T.SU
				lda #0
				jsr CC.DECL.YAC
				bcs .99

				jsr CC.GetCharNB
				bcs .98

				cmp #','
				bne .42

				jsr CC.GetNextCharNBNL
				bcc .41
				bcs .98

.42				cmp #';'
				bne .98

				clc
				rts
*--------------------------------------
CC.KW.SU.AddYAX	jsr CC.SYM.AddWord		add T/Q
				bcs .99

				bit ZPPtr2+1			bStrucUnion
				bmi .1

				ldy #SYM.SizeOf
				lda (ZPSymBufPtr),y
				pha
				iny
				lda (ZPSymBufPtr),y
				ply
				
				jsr CC.SYM.AddWord		Add Y/A Offset
				bcs .99
				
				txa
				
				ldy #SYM.SizeOf
*				clc
				adc (ZPSymBufPtr),y
				sta (ZPSymBufPtr),y
				bcc .99
				
				iny
				lda #0
				adc (ZPSymBufPtr),y
				sta (ZPSymBufPtr),y
				
*				clc				
				
.99				rts

.1				txa
				ldy #SYM.SizeOf
				cmp (ZPSymBufPtr),y
				bcs .2
				
				sta (ZPSymBufPtr),y
				
.2				jmp CC.SYM.Add0000		Add Y/A Offset (always 0 for union)
*--------------------------------------
CC.KW.ENUM
				lda #E.CSYN
				sec
				rts
*--------------------------------------
CC.KW.NewTag	>LDA.G CC.hTags
				jsr CC.SYM.NewKey
				bcs .9

				>STYA ZPPtr1			TagID
				dec ZPPtr2				bNewTagDef = true

				jsr CC.SkipX

.9				rts				
*--------------------------------------
CC.KW.GetTag	>PUSHB.G CC.hTags
				>PUSHW ZPLineBufPtr

				>SYSCALL SListLookup
				bcs .9

				phy						Y,A = KeyID
				pha

				jsr CC.SkipX			X = KeyLen

				>PUSHB.G CC.hTags
				pla
				>PUSHA
				pla
				>PUSHA
				>PUSHW ZPSymBufPtr
				>PUSHWI 65535			all
				>PUSHWZ					From Start
				>SYSCALL SListGetData
.9				rts
*--------------------------------------
CC.KW.StoreTag	>PUSHB.G CC.hTags
				>PUSHW ZPPtr1
				>PUSHW ZPSymBufPtr
				>PUSHBI 0
				ldy #SYM.DefSize
				lda (ZPSymBufPtr),y
				>PUSHA

				>SYSCALL SListAddData
				rts
*--------------------------------------
CC.KW.BEGIN00	lda #0
				jsr CC.Push				no T/Q
				bcs CC.KW.BEGIN.RTS

				jsr CC.Push
				bcs CC.KW.BEGIN.RTS

CC.KW.BEGIN		jsr CC.SYM.NewCPSID
				bcs .99

				>LDA.G CC.CPSPFX+3
				jsr CC.Push
				bcs .99

				>LDA.G CC.CPSPFX+2
				jsr CC.Push
				bcs .99

				lda LocalPtr			Locals
				jsr CC.Push
				bcs .99

				lda #0					bState
				jsr CC.Push
				bcs .99

				>LDA.G CC.CmdSave
				jmp CC.Push

.99
CC.KW.BEGIN.RTS	rts
*--------------------------------------
CC.KW.STMT		jsr CC.GetNextCharNBNL
				bcs .9

				cmp #'{'
				bne .1

				jsr CC.GetNextCharNB	skip '{'
				bcs .99

				lda #'}'
				jmp CC.Push

.1				lda #';'
				jmp CC.Push

.9				lda #E.CSYN
				sec
.99				rts
*--------------------------------------
CC.KW.NewLabel	pha

				lda CStackPtr
				clc
				adc #4
				tay

				lda (ZPCCStack),y
				pha
				iny
				lda (ZPCCStack),y
				ply
				>STYA.G CC.CPSPFX+2

				pla
				jmp CC.SYM.NewA
*--------------------------------------
CC.KW.GetLabel	pha

				lda CStackPtr
				clc
				adc #4
				tay

				lda (ZPCCStack),y
				pha
				iny
				lda (ZPCCStack),y
				ply
				>STYA.G CC.CPSPFX+2

				pla
				jmp CC.SYM.LookupA
*--------------------------------------
CC.KW.LookupLabel
				pha

				ldy CStackPtr
				sty ArgIndex

.1				ldy ArgIndex
				beq .9

				iny 					skip ; or }

				lda (ZPCCStack),y
				bmi .9					f()

				iny
				iny
				iny

				lda (ZPCCStack),y
				pha
				iny
				lda (ZPCCStack),y
				iny

				iny
				iny

				sty ArgIndex

				ply
				>STYA.G CC.CPSPFX+2

				pla
				pha
				jsr CC.SYM.LookupA
				bcs .1

				pla
.8				rts

.9				pla
				lda #E.CSYN
				sec
.99				rts
*--------------------------------------
* Input : Value on Stack, Y,A = Type/Qual
*--------------------------------------
CC.KW.TestZero	jsr CC.EXP.GetYASizeOfInAXC
				tax
				cpx #1
				bne .1

				>LDYA L.PCC.TestZero1
				jmp CODE.EmitPCC

.1				cpx #2
				bne .2

				>LDYA L.PCC.TestZero2
				jmp CODE.EmitPCC

.2				jsr CODE.LDXI
				bcs .9

				>LDYA L.PCC.TestZeroX
				jmp CODE.EmitPCC

.9				rts
*--------------------------------------
* Input : Value on Stack, Y,A = Type/Qual
*--------------------------------------
CC.KW.TestnZero	jsr CC.EXP.GetYASizeOfInAXC
				tax
				cpx #1
				bne .1

				>LDYA L.PCC.TestnZero1
				jmp CODE.EmitPCC

.1				cpx #2
				bne .2

				>LDYA L.PCC.TestnZero2
				jmp CODE.EmitPCC

.2				jsr CODE.LDXI
				bcs .9

				>LDYA L.PCC.TestnZeroX
				jmp CODE.EmitPCC

.9				rts
*--------------------------------------
* Input : Value on Stack, Y,A = Type/Qual
*--------------------------------------
CC.KW.StackDiscard

				jsr CC.TYPE.SizeOf
				txa
				beq .8					void

				jsr CODE.AddLocal

.8				clc
.9				rts
*--------------------------------------
MAN
SAVE usr/src/bin/cc.s.kw
LOAD usr/src/bin/cc.s
ASM
