NEW
  AUTO 3,1
*--------------------------------------
* Built in Keywords
*--------------------------------------
CC.KW.IF		jsr CC.KW.BEGIN00
				bcs .99

				jsr CC.GetCharNB
				bcs .9

				cmp #'('
				bne .9

				jsr CC.GetNextCharNB
				bcs .9

				jsr CC.EXP.Eval00		Any var type
				bcs .99

				jsr CC.KW.TestZero		Y,A=T/Q

				lda #'E'
				jsr CC.SYM.LookupA
				bcs .99

				lda #$4C				emit JMP else
				jsr CODE.TOABSYX
				bcs .99

				jsr CC.GetCharNB
				bcs .99

				cmp #')'
				bne .9

				jmp CC.KW.STMT

.9				lda #E.CSYN
				sec
.99				rts
*--------------------------------------
CC.KW.IF.END	jsr CC.GetCharNBNL
				bcs .1

				cmp #';'
				beq .1

				>LDYA L.CC.KW2.IF		Check allowed KW for IF....
				jsr CC.LookupID
				bcc .2

.1				lda #'E'				define ELSE Label
				jsr CC.KW.NewLabel
				bcs .99
				
				clv						pop context
				rts
*--------------------------------------
.2				lda #'X'
				jsr CC.SYM.LookupA
				bcs .99

				lda #$4C				emit JMP exit
				jsr CODE.TOABSYX
				bcs .99

				lda #'E'				define ELSE Label
				jsr CC.KW.NewLabel
				bcs .99

				inc CStackPtr			pop ; or }

				lda #4					replace IF by ELSE keyword
				ldy CStackPtr
				sta (ZPCCStack),y

				jsr CC.KW.STMT
				bcs .99

				bit .99					set V : DONT pop context
				rts

.9				lda #E.CSYN
				sec
.99				rts
*--------------------------------------
CC.KW.ELSE		lda #E.CSYN				illegal
				sec
				rts
*--------------------------------------
CC.KW.ELSE.END	lda #'X'				define EXIT Label
				jsr CC.KW.NewLabel
				bcs .99

				clv						pop context
.99				rts
*--------------------------------------
CC.KW.WHILE		jsr CC.KW.BEGIN00
				bcs .99

				lda #'C'				define CONT Label
				jsr CC.SYM.NewA
				bcs .99

				jsr CC.GetCharNB
				bcs .9

				cmp #'('
				bne .9

				jsr CC.GetNextCharNB
				bcs .9

				jsr CC.EXP.Eval00		Any var type
				bcs .99

				jsr CC.KW.TestZero

				lda #'B'
				jsr CC.SYM.LookupA
				bcs .99

				lda #$4C				emit JMP break:
				jsr CODE.TOABSYX
				bcs .99

				jsr CC.GetCharNB
				bcs .99

				cmp #')'
				bne .9

				jmp CC.KW.STMT

.9				lda #E.CSYN
				sec
.99				rts
*--------------------------------------
CC.KW.WHILE.END	lda #'C'
				jsr CC.KW.GetLabel
				bcs .99

				lda #$4C
				jsr CODE.TOABSYX		emit JMP cont:
				bcs .99

				lda #'B'				define BREAK Label
				jsr CC.KW.NewLabel
				bcs .99

				clv						pop context

.99				rts
*--------------------------------------
CC.KW.DO		jsr CC.KW.BEGIN00
				bcs .99

				lda #'C'				define CONT Label
				jsr CC.SYM.NewA
				bcs .99
				
				jmp CC.KW.STMT

.99				rts
*--------------------------------------
CC.KW.DO.END	>LDYA L.CC.KW2.DO		Check allowed KW for DO....
				jsr CC.LookupID
				bcs .9

				jsr CC.GetCharNB
				bcs .9

				cmp #'('
				bne .9

				jsr CC.GetNextCharNB
				bcs .9

				jsr CC.EXP.Eval00		Any var type
				bcs .99

				jsr CC.KW.TestnZero

				lda #'C'
				jsr CC.KW.GetLabel
				bcs .99

				lda #$4C				emit JMP cont
				jsr CODE.TOABSYX
				bcs .99

				lda #'B'				define BREAK Label
				jsr CC.KW.NewLabel
				bcs .99

				jsr CC.GetCharNB
				bcs .99

				cmp #')'
				bne .9
				
				jsr CC.GetNextCharNB
				bcs .9

				clv						pop context
				clc
				rts
				
.9				lda #E.CSYN
				sec
.99				rts
*--------------------------------------
* for (s1;e2;s3) s;
*
* {				<- new scope : allows for(int i=1; ....)
* 	s1;
*	loop:
* 	while (e2)	jmp break:
* 	{
* 	   s;		jsr s:
* 	cont:
* 	   s3;		jmp loop:
* 	}
* s:
* <s>;
* break:
* }
*--------------------------------------
CC.KW.FOR		jsr CC.GetCharNB
				bcs .29

				cmp #'('
				bne .29

				jsr CC.KW.BEGIN00
				bcs .29

				jsr CC.GetNextCharNB	skip '('
				bcs .29

				>LDYA L.CC.TYPEQUAL
				jsr CC.LookupID
				bcs .1

				jsr CC.DECL
				bcc .2

.19				rts

.1				jsr CC.STMT				get s1
				bcs .19

*				jsr CC.KW.StackDiscard

.2				jsr CC.GetCharNB
				bcs .9

				cmp #';'
				bne .9

				jsr CC.GetNextCharNB	skip ';'
				bcs .9
*--------------------------------------
				lda #'L'				LOOP Label
				jsr CC.SYM.NewA
				bcs .99

				jsr CC.EXP.Eval00		get e2
.29				bcs .99

				jsr CC.KW.TestZero
				bcs .99

				lda #'B'
				jsr CC.SYM.LookupA
				bcs .99

				lda #$4C				emit JMP break:
				jsr CODE.TOABSYX

				lda #'S'
				jsr CC.SYM.LookupA
				bcs .99

				lda #$20				emit JSR s:
				jsr CODE.TOABSYX

				jsr CC.GetCharNB
				bcs .9

				cmp #';'
				bne .9

				jsr CC.GetNextCharNB	skip ';'
				bcs .9
*--------------------------------------
				lda #'C'				CONT Label
				jsr CC.SYM.NewA
				bcs .99

				jsr CC.STMT				get s3
				bcs .99

*				jsr CC.KW.StackDiscard

				jsr CC.GetCharNB
				bcs .9

				cmp #')'
				bne .9

				lda #'L'
				jsr CC.SYM.LookupA
				bcs .99

				lda #$4C
				jsr CODE.TOABSYX		emit JMP loop

				lda #'S'				S Label
				jsr CC.SYM.NewA
				bcs .99

				jmp CC.KW.STMT

.9				lda #E.CSYN
				sec
.99				rts
*--------------------------------------
CC.KW.FOR.END	lda #$60

				jsr CODE.EmitByte		set RTS for JSR code;
				bcs .99

				lda #'B'				define BREAK Label
				jsr CC.KW.NewLabel
				bcs .99

				clv						pop context

.99				rts
*--------------------------------------
CC.KW.SWITCH	jsr CC.GetCharNB
				bcs .98

				cmp #'('
				bne .98

				jsr CC.GetNextCharNB
				bcs .98

				jsr CC.EXP.Eval00		Any var type
				bcs .99					Y,A=T/Q

				tax
				bne .97
				
				cpy #SYM.T.UCHAR
				bcc .97
				
				cpy #SYM.T.FLOAT
				bcs .97

				phy
				tya
				jsr CC.Push				push integral type
				ply
				bcs .99

				lda CC.TYPESIZE-1,y

				jsr CC.Push				push SizeOf(type)
				bcs .99
				
				jsr CC.KW.BEGIN
				bcs .99
				
				jsr CC.GetCharNB
				bcs .99

				cmp #')'
				bne .98

				jmp CC.KW.STMT
				
.97				lda #E.TMISMATCH
				sec
				rts				

.98				lda #E.CSYN
				sec
.99				rts
*--------------------------------------
CC.KW.SWITCH.END
				lda #'B'				define BREAK Label
				jsr CC.KW.NewLabel
				bcs .99
				
				clv						pop context

.99				rts
*--------------------------------------
CC.KW.CASE		ldy CStackPtr
				beq .9

				iny 					skip ; or }
				lda (ZPCCStack),y
				cmp #10					SWITCH ??
				bne .9
				
				lda CStackPtr
				clc
				adc #7
				tay

				lda (ZPCCStack),y		type
				tay
				lda #0					for integral type
				
				jsr CC.EXP.Eval
				bcs .99

				jsr CC.GetCharNB
				bcs .9
				
				cmp #':'
				bne .9

				jsr CC.GetNextCharNB	skip ':'

				clc
				rts
				
.9				lda #E.CSYN
				sec
.99				rts
*--------------------------------------
CC.KW.DEFAULT	ldy CStackPtr
				beq .9

				iny 					skip ; or }
				lda (ZPCCStack),y
				cmp #10					SWITCH ??
				bne .9
				
				jsr CC.GetCharNB
				bcs .9
				
				cmp #':'
				bne .9

				jsr CC.GetNextCharNB	skip ':'
				
				clc
				rts
				
.9				lda #E.CSYN
				sec
.99				rts
*--------------------------------------
CC.KW.BREAK		lda #'B'

				jsr CC.KW.LookupLabel
				bcs .9
				
				lda #$4C				emit JMP break
				jmp CODE.TOABSYX
				
.9				lda #E.CSYN
				sec
				rts
*--------------------------------------
CC.KW.CONTINUE	lda #'C'

				jsr CC.KW.LookupLabel
				bcs .9
				
				lda #$4C				emit JMP cont
				jmp CODE.TOABSYX
				
.9				lda #E.CSYN
				sec
				rts
*--------------------------------------
CC.KW.RETURN	ldy CStackPtr
				beq .9

.1				iny 					skip ; or }
				lda (ZPCCStack),y
				bmi .7					f()

				tya
				clc
				adc #5					skip CPStmt (6 bytes)
				tay
				bcc .1

.9				lda #E.STACKERROR
				sec
.99				rts

.7				iny						skip bState
				iny						skip Locals

				iny
				iny						skip CPSID

				iny						get SYM.T
				lda (ZPCCStack),y

				pha

				iny						get SYM.Q
				lda (ZPCCStack),y

				ply

				jsr CC.EXP.Eval
				bcs .99

				jsr CC.SYM.GetYASizeOfInAXC		Y,A=T/Q
				tax						X = sizeof
				jsr CODE.SetRetValue
				bcs .99

				>LDYA L.PCC.LEAVE
				jmp CODE.EmitPCC
*--------------------------------------
CC.KW.SIZEOF
				lda #E.CSYN
				sec
				rts
*--------------------------------------
CC.KW.STRUCT	>ENTER 4

				jsr CC.GetCharNB
				bcs .99

				ldx #SYM.SC.TAG
				>LDA.G CC.hTags
				jsr CC.SYM.NewKey
				bcs .99

				sta (pStack)			Y,A = KeyID
				tya
				ldy #1
				sta (pStack),y

				jsr CC.SkipX

				jsr CC.GetNextCharNB
				bcs .99

				cmp #'{'
				bne .99

.1				jsr CC.GetNextCharNB
				bcs .99

				cmp #'}'
				bne .1

				jsr CC.GetNextCharNB	skip '}'

				clc
.99				>LEAVE
				rts
*--------------------------------------
CC.KW.UNION
CC.KW.ENUM
				lda #E.CSYN
				sec
				rts
*--------------------------------------
CC.KW.BEGIN00	lda #0
				jsr CC.Push				no T/Q
				bcs CC.KW.BEGIN.RTS
				
				jsr CC.Push
				bcs CC.KW.BEGIN.RTS

CC.KW.BEGIN		jsr CC.SYM.NewCPSID
				bcs .99

				>LDA.G CC.CPSPFX+3
				jsr CC.Push
				bcs .99

				>LDA.G CC.CPSPFX+2
				jsr CC.Push
				bcs .99

				lda LocalPtr			Locals
				jsr CC.Push
				bcs .99

				lda #0					bState
				jsr CC.Push
				bcs .99

				>LDA.G CC.CmdSave
				jmp CC.Push

.99
CC.KW.BEGIN.RTS	rts
*--------------------------------------
CC.KW.STMT		jsr CC.GetNextCharNBNL
				bcs .9

				cmp #'{'
				bne .1

				jsr CC.GetNextCharNB	skip '{'
				bcs .99

				lda #'}'
				jmp CC.Push

.1				lda #';'
				jmp CC.Push

.9				lda #E.CSYN
				sec
.99				rts
*--------------------------------------
CC.KW.NewLabel	pha

				lda CStackPtr
				clc
				adc #4
				tay

				lda (ZPCCStack),y
				pha
				iny
				lda (ZPCCStack),y
				ply
				>STYA.G CC.CPSPFX+2

				pla
				jmp CC.SYM.NewA
*--------------------------------------
CC.KW.GetLabel	pha

				lda CStackPtr
				clc
				adc #4
				tay

				lda (ZPCCStack),y
				pha
				iny
				lda (ZPCCStack),y
				ply
				>STYA.G CC.CPSPFX+2

				pla
				jmp CC.SYM.LookupA
*--------------------------------------
CC.KW.LookupLabel
				pha

				ldy CStackPtr
				sty ArgIndex

.1				ldy ArgIndex
				beq .9

				iny 					skip ; or }

				lda (ZPCCStack),y
				bmi .9					f()
				
				iny
				iny
				iny

				lda (ZPCCStack),y
				pha
				iny
				lda (ZPCCStack),y
				iny
				
				iny
				iny
				
				sty ArgIndex
				
				ply
				>STYA.G CC.CPSPFX+2

				pla
				pha
				jsr CC.SYM.LookupA
				bcs .1
				
				pla
.8				rts
				
.9				pla
				lda #E.CSYN
				sec
.99				rts
*--------------------------------------
* Input : Value on Stack, Y,A = Type/Qual
*--------------------------------------
CC.KW.TestZero	jsr CC.EXP.GetYASizeOfInAXC
				tax
				cpx #1
				bne .1

				>LDYA L.PCC.TestZero1
				jmp CODE.EmitPCC

.1				cpx #2
				bne .2

				>LDYA L.PCC.TestZero2
				jmp CODE.EmitPCC

.2				jsr CODE.LDXI
				bcs .9

				>LDYA L.PCC.TestZeroX
				jmp CODE.EmitPCC

.9				rts
*--------------------------------------
* Input : Value on Stack, Y,A = Type/Qual
*--------------------------------------
CC.KW.TestnZero	jsr CC.EXP.GetYASizeOfInAXC
				tax
				cpx #1
				bne .1

				>LDYA L.PCC.TestnZero1
				jmp CODE.EmitPCC

.1				cpx #2
				bne .2

				>LDYA L.PCC.TestnZero2
				jmp CODE.EmitPCC

.2				jsr CODE.LDXI
				bcs .9

				>LDYA L.PCC.TestnZeroX
				jmp CODE.EmitPCC

.9				rts
*--------------------------------------
* Input : Value on Stack, Y,A = Type/Qual
*--------------------------------------
CC.KW.StackDiscard

				jsr CC.TYPE.SizeOf
				txa
				beq .8					void

				jsr CODE.AddLocal

.8				clc
.9				rts
*--------------------------------------
MAN
SAVE usr/src/bin/cc.s.kw
LOAD usr/src/bin/cc.s
ASM
