NEW
PREFIX
AUTO 4,1
				.LIST OFF	
*--------------------------------------
CMD.Init		>LDYAI 256
				>SYSCALL GetMem
				bcs .9
				>STYA ZPArgVBuf
				txa
				>STA.G CMD.hArgVBuf
				
				lda #PUSHD.STACK
				tay
				sta (pData),y
								
.9				rts				
*--------------------------------------
CMD.Quit		ldy #CMD.hArgVBuf
				jsr .8

				ldy #hFileBuf

.8				lda (pData),y		
				beq .9
				>SYSCALL FreeMem
				clc
.9				rts	
*--------------------------------------
* Read From InputBuf
*--------------------------------------
CMD.Get			>LDYA ZPInputBufPtr
				>STYA ZPInputBufPtrBak
				
				lda (ZPInputBufPtr)
				beq .9
				
				ldx #0					not in "
						
				ldy #0
				
.1				lda (ZPInputBufPtr),y
				beq .7

				cmp #C.CR
				beq .6
				
				cmp #'"'
				bne .2
				
				txa
				eor #$80				toggle " switch
				tax
				
				lda #'"'
				bra .5
				
.2				cmp #';'
				bne .5
				
				txa
				beq .6
				
				lda #';'
				
.5				sta (ZPCLBuf),y
				iny
				cpy #CL.MAX
				bne .1
				
				lda #E.SYN				Line Too long !!!
*				sec
				rts
				
.6				sec						skip CR or ;
				.HS 90					BCC
				
.7				clc
				
				tya
				adc ZPInputBufPtr
				sta ZPInputBufPtr
				bcc .8
				inc ZPInputBufPtr+1
				
.8				lda #0
				sta (ZPCLBuf),y
				
				tya
				>STA.G CL.Len
				lda #$ff
				>STA.G CL.bExec

				clc
				rts
				
.9				lda #C.EOF
				sec
				rts
*--------------------------------------
* in:
* ZPCLBuf : CString command line
* out:
* ZPArgVBuf : 
* /path/excmd\0 arg1\0 arg2\0 ... \0
* - or -
* intcmd\0 arg1\0 arg2\0 ... \0
*--------------------------------------
CL.Parse		>STZ.G CMD.IntCmd

				lda #S.PS.F.HOLD+S.PS.F.DUPENV
				>STA.G CMD.PSFlags

				>PUSHW ZPCLBuf
				>LDYA ZPCLBuf
				>STYA ZPCLBufPtr

				>SYSCALL Args2ArgV
				
				lda #0
				sta (ZPArgVBuf)
				
				lda (ZPCLBufPtr)
				beq .8
				
.1				cmp #'#'				comment ?
				beq .8					yes, ignore remaining

				>LDA.G CMD.IntCmd
				bne .3					we already have Cmd, go check args
				
				ldy #1
				lda (ZPCLBufPtr),y		only one char ?
				bne .2
				
				lda (ZPCLBufPtr)
				cmp #'.'				leading dot ?
				bne .2
				
				>LDA.G CMD.PSFlags		yes, child process will run in same ENV
				and #$ff^S.PS.F.DUPENV
				sta (pData),y
				bra .6					and skip this token
				
.2				jsr CL.CheckCmd
				bcc .6					success, skip token, already added by CheckCmd

				rts
				
.3				jsr CL.CheckIO
				bcc .7					IO token & related args processed
				tay						an error ?
				bne .9					yes...I/O error...
				
				jsr CL.AddCLBufPtrToArgV	no...add as an arg
				bcs .9

.6				jsr CL.NextCLToken
.7				lda (ZPCLBufPtr)
				bne .1
				
.8				clc
				
.9				rts				
*--------------------------------------
* ZPCLBuf-> argv[] (formatted & not empty)
*--------------------------------------
CL.CheckCmd		ldy #$ff

.1				iny
				lda (ZPCLBufPtr),y
				beq .2
				cmp #'/'
				bne .1
				
				bra .4
				
.2				>PUSHW ZPCLBufPtr
				>LDYA L.CMD.INT
				jsr Lookup				no / found, search internal...
				bcs .4					not internal, search PATH
				
				phx
				plx
				bne .3
				
				>LDA.G CMD.PSFlags		if STARTPROC, skip keyword...
				and #$ff^S.PS.F.HOLD
				sta (pData),y			...and toggle S.PS.F.HOLD flag
				clc
.9				rts
				
.3				jsr CL.AddYAToArgV		X unmodified
				bcs .9

				txa
				>STA.G CMD.IntCmd

				clc
				rts

.4				>LDYA ZPCLBufPtr
				jsr CL.AddYAToArgV

				lda #$ff
				>STA.G CMD.IntCmd
				clc

CL.CheckCmd.RTS
				rts
*--------------------------------------
CL.CheckIO		>PUSHW ZPCLBufPtr
				>LDYA L.CL.IO
				jsr Lookup
				bcs .9					not a IO token...should be an arg....
				phx
				
				jsr CL.NextCLToken		skip this IO token
				
				plx
				jmp (J.CL.IO,x)

.9				lda #0
				rts
*--------------------------------------
CL.IO.AMP		>LDA.G CMD.PSFlags
				and #$ff^S.PS.F.HOLD
				sta (pData),y
				clc
				rts
				
CL.IO.IN		lda #O.RDONLY+O.TEXT
				jsr CL.IO.Open
				bcs .9
				jsr IO.Set.In

				jsr CL.NextCLToken 		skip arg
				clc
.9				rts
				
CL.IO.OUTA
CL.IO.1OUTA		lda #O.WRONLY+O.APPEND+O.CREATE+O.TEXT
				bra CL.IO.OUT.1
CL.IO.OUT		
CL.IO.1OUT		lda #O.WRONLY+O.TRUNC+O.CREATE+O.TEXT

CL.IO.OUT.1		jsr CL.IO.Open
				bcs .9
				jsr IO.Set.Out

				jsr CL.NextCLToken 		skip arg
				clc	
.9				rts

CL.IO.2OUTA		lda #O.WRONLY+O.APPEND+O.CREATE+O.TEXT
				bra CL.IO.2OUT.1
CL.IO.2OUT		lda #O.WRONLY+O.TRUNC+O.CREATE+O.TEXT

CL.IO.2OUT.1	jsr CL.IO.Open
				bcs .9
				jsr IO.Set.Err

				jsr CL.NextCLToken	 	skip arg
				clc
.9				rts
*--------------------------------------
CL.IO.Open		pha
				lda (ZPCLBufPtr)
				beq .9					no arg left....
				
				>PUSHWI 0				Aux type
				>PUSHBI S.FI.T.TXT		ftype
				pla
				>PUSHA					flags
				>LDYA ZPCLBufPtr
				>SYSCALL fopen
				rts
				
.9				pla
				lda #E.CSYN
				sec
				rts				
*--------------------------------------
CL.NextCLToken
				lda (ZPCLBufPtr)
				inc ZPCLBufPtr
				bne .1
				inc ZPCLBufPtr+1
.1				tax
				bne CL.NextCLToken
				rts
*--------------------------------------
CL.AddCLBufPtrToArgV
				>LDYA ZPCLBufPtr
CL.AddYAToArgV	>STYA ZPPtr1

				>LDYA ZPArgVBuf
				>STYA ZPPtr2
				
.1				lda (ZPPtr2)			scan to end of argV
				beq .6

.2				inc ZPPtr2
				bne .3
				inc ZPPtr2+1
.3				lda (ZPPtr2)
				bne .2

				inc ZPPtr2
				bne .4
				inc ZPPtr2+1
.4				lda (ZPPtr2)
				bne .2
				
.6				ldy #$ff

.7				iny
*				beq .9
				lda (ZPPtr1),y
				sta (ZPPtr2),y
				bne .7					including str ending \0

				iny
*				beq .9
				sta (ZPPtr2),y			arg[] ending \0
				
				clc
				rts
				
.9				lda #E.BUF	
				sec				
				rts
*--------------------------------------
MAN
SAVE USR/SRC/BIN/SHELL.S.CMD
LOAD USR/SRC/BIN/SHELL.S
ASM
