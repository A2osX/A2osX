NEW
  AUTO 3,1
*--------------------------------------
CC.F.Decl		stz LocalPtr

				jsr CC.PushTQ			push T/Q for RETURN
				bcs .99

				ldx #$80				CPStmt.fDef	state
				jsr CC.STMT.CPStmt.NEW
				bcs .99

				jsr CC.SYM.NewScope
				bcs .99

				jsr CC.GetNextCharNB	Skip (
				bcs .9

				cmp #')'				func()
				beq .6
*--------------------------------------
.1				jsr CC.F.DeclGetTQ
				bcs .99

				>STYA ZPPtr2			Save T/Q

				jsr CC.SYM.AddWord

				jsr CC.GetCharNB
				bcs .9

				jsr CC.IsLetter
				bcs .2

				jsr CC.F.NewArg
				bcs .99

				jsr CC.GetCharNB
				bcs .9

.2				cmp #')'
				beq .6

				cmp #','
				bne .9

				jsr CC.GetNextCharNB	Skip ,
				bcc .1

.9				lda #E.CSYN
				sec
.99				rts
*--------------------------------------
.6				ldy #0
				lda #0
				jsr CC.SYM.AddWord		definition End

				jsr CC.GetNextCharNBNL	Skip )
				bcs .9

				cmp #';'
				bne .7

				jsr CC.SYM.FreeScope	discard local scope

				lda CStackPtr
				clc
				adc #8
				sta CStackPtr			discard this CPStmt + T/Q

				stz LocalPtr			reset for DEBUG Message

				clc
				rts
*--------------------------------------
.7				cmp #'{'
				bne .9

				bit bInitCode
				bmi .8

				dec bInitCode

				lda #$60				RTS
				jsr CODE.EmitByte		Close INIT code
				bcs .99


.8				>LDYA ZPCCCode			f() Code starts HERE
				jsr CC.SYM.SetAddrYA

				lda LocalPtr
				jsr CODE.LDAI			A = f() ARGS size
				bcs .99

				>LDYA L.PCC.ENTER
				jmp CODE.EmitPCC		Store f() Declaration / Start Definition
*--------------------------------------
CC.F.DeclGetTQ	lda (ZPLineBufPtr)
				cmp #'.'
				bne .5

				ldx #2

.1				jsr CC.GetNextChar
				bcs .9

				cmp #'.'
				bne .9

				dex
				bne .1

				jsr CC.GetNextCharNB
				bcs .9

				eor #')'
				bne .9

				ldy #SYM.T.VARIADIC		Type
*				lda #0					Qual
*				clc
				rts
*--------------------------------------
.5				>LDYA L.CC.TYPEQUAL
				jsr CC.LookupID
				bcs .9

				jsr CC.TYPE.Decl
				bcs .9

*	Y,A = Type/Qual

				bra .8

.9				lda #E.CSYN
				sec

.8				rts
*--------------------------------------
CC.F.NewArg		>LDYA.G CC.SymID
				>STYA.G CC.SymIDSave

				>LEA.G CC.ArgBuf
				>STYA ZPSymBufPtr

				>LDYA ZPPtr2
				ldx #SYM.SC.AUTO
				jsr CC.SYM.New
				bcs .9

				jsr CC.SYM.StoreL		Store f() Args in Local scope
				bcs .9

				>LDA.G CC.hSymBuf
				>SYSCALL GetMemPtr
				>STYA ZPSymBufPtr

				>LDYA.G CC.SymIDSave
				>STYA.G CC.SymID

.9				rts
*--------------------------------------
CC.F.Def.END	>LDYA L.PCC.LEAVE
				jsr CODE.EmitPCC
				bcs .9

				jsr CC.Pop				T
				jsr CC.Pop				Q

				jsr CC.SYM.FreeScope

				stz LocalPtr			back to global

				clv						pop context
				clc
.9				rts
*--------------------------------------
* in : ZPSymPtr
*      Y,A = Expected T/Q
*--------------------------------------
CC.F.CallNoRetV	ldy #0					no expected T/Q
				tya
				clc
				.HS B0					BCS
CC.F.CallRetV	sec

				ldx ZPPtr1				local : variadic size
				phx
				ldx ZPPtr1+1			local : bRetV
				phx

				ldx ZPPtr2				local : expected T
				phx
				ldx ZPPtr2+1			local : expected Q
				phx

				>STYA ZPPtr2

				ror ZPPtr1+1			bRetV
*				bpl .20					no return value on stack

*				ldy #SYM.Addr+1
*				lda (ZPLookupSymPtr),y
*				beq .20					SYS/LIB/FPU call, no ret value space

				jsr CC.EXP.GetSymSizeOfInAXC
				jsr CODE.nAddLocal

.20				jsr CC.GetNextCharNB	skip '('
				bcs .10

				ldy #SYM.Q
*			>DEBUG
				lda ZPPtr2				expected T
				bne .1

				lda (ZPLookupSymPtr)	no check required
				sta ZPPtr2

				lda (ZPLookupSymPtr),y
				and #$fC				ignore SYM.Q.FUNC,SYM.Q.FASTCALL
				bra .2

.1				cmp #SYM.T.VOID
				beq .11

				cmp (ZPLookupSymPtr)
				bne .91

.11				lda (ZPLookupSymPtr),y
				and #$fC				ignore SYM.Q.FUNC,SYM.Q.FASTCALL
				cmp ZPPtr2+1			expected Q
				bne .91
*--------------------------------------
.2				sta ZPPtr2+1

				stz ZPPtr1				Reset VARIADIC byte count

				lda #SYM.Def
				>STA.G CC.LookupSymPtr

				jsr CC.F.GetTQ			get First Arg T/Q
				beq .7					end of list, go check ending ')'

.3				cpy #SYM.T.VARIADIC
				bne .4

				lda #0					Expected T/Q = 0 if VARIADIC
				tay

.4				and #$F0				CONST+VOLATILE+FUNC+FASTCALL

				jsr CC.EXP.Eval
				bcs .93

				jsr CC.EXP.GetYASizeOfInAXC
				tax						save Sizeof in X

				jsr CC.F.GetTQ
				cpy #SYM.T.VARIADIC
				bne .50					if VARIADIC, don't advance to next arg

				txa
				clc						make sure pointer only 2 bytes
				adc ZPPtr1
				sta ZPPtr1				Add to byte count
				bra .5

.50				>LDA.G CC.LookupSymPtr
				clc
				adc #2
				sta (pData),y

.5				jsr CC.GetCharNB

.10				bcs .90

				cmp #','
				bne .6

				jsr CC.GetNextCharNB	Skip ','

				jsr CC.F.GetTQ
				bne .3					Another ARG....

				bra .90					extra args....error

.6				cmp #')'
				bne .90

				jsr CC.F.GetTQ
				beq .8					no more arg after ')', exit

				cpy #SYM.T.VARIADIC
				bne .90					missing arg

				lda ZPPtr1				push VARIADIC byte count
				jsr CODE.PUSHI

.7				jsr CC.GetCharNB
				bcs .90

				cmp #')'
				bne .90

.8				jsr CC.GetNextCharNB	Skip )

				jsr CC.F.Call2
				bra .93

.90				lda #E.CSYN
				bra .92

.91				lda #E.TMISMATCH

.92				sec

.93				plx
				stx ZPPtr2+1
				plx
				stx ZPPtr2

				plx
				stx ZPPtr1+1
				plx
				stx ZPPtr1

.99				rts
*--------------------------------------
* X = last var size
*--------------------------------------
CC.F.Call2		ldy #SYM.Q
				lda (ZPLookupSymPtr),y
				and #SYM.Q.FASTCALL
				beq .1

				ldy #SYM.Def			Get first (only) argument
				jsr CC.F.GetTQAtY
				jsr CC.TYPE.SizeOf

				dex
				bne .19

				jsr CODE.PULLA
				bra .1

.19				jsr CODE.PULLYA

.1				jsr CC.F.Call3
				bcs .9

				bit ZPPtr1+1			bRetV
				bmi .5

* NO Return Value : call & discard stack if not in Y,A

				>LDYA ZPPtr2			function T/Q
				jsr CC.TYPE.SizeOf
				txa
				beq .11					void

				cpx #3					A or Y,A
				bcc .11

.10				jsr CODE.INCPSTACK
				dex
				bne .10

.11				clc
.9				rts

* Return Value : call & put result on stack if in Y,A

.5
				ldy #SYM.Addr+1
				lda (ZPLookupSymPtr),y
				cmp #3
				bcs .8					not a SYS/FPU call...Ret value on stack

				>LDYA ZPPtr2			function T/Q
				jsr CC.TYPE.SizeOf
				cpx #3
				bcs .8					leave on stack

				dex
				bne .60

				jsr CODE.PUSHA			push ONE byte on stack
				bra .8

.60				jsr CODE.PUSHYA			push TWO bytes on stack

.8				>LDYA ZPPtr2			T/Q

				clc
				rts
*--------------------------------------
CC.F.Call3		ldy #SYM.Addr+1

				lda (ZPLookupSymPtr),y
				beq .9

				pha

				dey
				lda (ZPLookupSymPtr),y
				tax

				ply						Y=HI,X=LO

				cpy #1
				bne .1

				jmp CODE.SYSCALL

.1				cpy #2
				bne .2

				jmp CODE.FPUCALL

.2				lda #$EA				NOP
				jsr CODE.EmitByte
				bcs .99

				lda #$EA				NOP
				jsr CODE.EmitByte
				bcs .99

				lda #$20				JSR abs
				jmp CODE.TOABSYX

.9				bit bPass2
				bmi .91

				lda #5					leave room for LDX #imm, JSR abs
				clc
				adc ZPCCCode
				sta ZPCCCode

				bcc .90

				inc ZPCCCode+1

.90				clc
				rts

.91				lda #E.FUNDEF
				sec
.99				rts
*--------------------------------------
CC.F.GetTQ		>LDA.G CC.LookupSymPtr
				tay

CC.F.GetTQAtY	lda (ZPLookupSymPtr),y
				pha
				iny
				lda (ZPLookupSymPtr),y
				ply
				rts
*--------------------------------------
MAN
SAVE usr/src/bin/cc.s.f
LOAD usr/src/bin/cc.s
ASM
