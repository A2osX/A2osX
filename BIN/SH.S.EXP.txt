NEW
  AUTO 3,1
				.LIST OFF	
*--------------------------------------
EXP.GET			jsr CORE.ArgV.Next
				bne .1
				
				>LDYA ZPArgVBufPrev		no op, return text value
				clc
				rts
				
.1				>LDYA ZPArgVBufPrev
				>SYSCALL AToL
				bcs .99

				>PULLL M32.ACC
				
.2				>LDYA L.EXP.OP.MATH		+ - .... ?
				jsr CORE.LookupArgVBuf
				bcs .9

				txa
				>STA.G CORE.Operator		

				jsr M32.ACC2ARG
				
				jsr CORE.ArgV.Next		get next argument in ACC
				beq .9
				
				>LDYA ZPArgVBufPtr
				>SYSCALL AToL
				bcs .9

				>PULLL M32.ACC
				jsr EXP.GET.OP
.99				bcs .9
				
				jsr CORE.ArgV.Next	another op ?
				bne .2
				
.8				>PUSHL M32.ACC
				>PUSHBI 4		
				>PUSHW L.M32.Printf
				>LEA.G M32.BUF
				>SYSCALL sprintf
				bcs .9
				
				>LEA.G M32.BUF
				
				rts
				
.9				lda #E.ESYN
				sec
				rts
				
EXP.GET.OP		>LDA.G CORE.Operator
				asl
				tax
				jmp (J.EXP.OP.MATH,x)
*--------------------------------------
EXP.TEST		lda (ZPArgVBufPtr)
				beq .9

				lda #$80
				>STA.G CORE.TestOp		No Op
				
.10				>LDYA L.EXP.BEGIN
				jsr CORE.LookupArgVBuf

				bcs .9
			
				dex						0=[ or 1=![ , $ff or 0
				txa
				asl						in C
				php
				
				>LDA.G CORE.Test		get parent
				asl						discard true/false
				plp						get new
				ror						set ctx and parent
				>STA.G CORE.Test
				
				jsr CORE.ArgV.Next
				beq .9

				>LDYA L.EXP.OP.UNARY	-d -e -f -n -z ?
				jsr CORE.LookupArgVBuf

				bcs .1

				txa
				>STA.G CORE.Operator
			
				jsr EXP.TEST.UNARY
				bcs .9
				
				>EOR.G CORE.Test
				sta (pData),y
				lda (ZPArgVBufPtr)
				bra .8					go check ]

.9				lda #E.ESYN
				sec
.99				rts
				
.1				jsr CORE.ArgV.Next
				beq .9
				
				>LDYA L.EXP.OP.BINARY	-eq -ne .... ?
				jsr CORE.LookupArgVBuf
				bcs .9
				txa
				>STA.G CORE.Operator
				
				jsr EXP.TEST.BINARY
				bcs .9

				>EOR.G CORE.Test
				sta (pData),y

				jsr CORE.ArgV.Next
				beq .9
				
.8				cmp #']'
				bne .9
				
				ldy #1
				lda (ZPArgVBufPtr),y
				bne .9
				
				jsr CORE.ArgV.Next
				beq .80
				
				>LDYA L.EXP.OP.LOGIC
				jsr CORE.LookupArgVBuf
				bcs .9

				txa						0 = AND, 1 = OR
				>STA.G CORE.TestOp
				txa
				beq .84
				>lda.G CORE.Test		OR : prev test is true, exit
				bmi .88
				bra .85
				
.84				>lda.G CORE.Test		AND : prev test is false, exit
				bpl .88
				
.85				>LDA.G CORE.Test
				>STA.G CORE.TestArg
				
				jsr CORE.ArgV.Next
				beq .9
				
				jmp .10			
				
.80				>LDA.G CORE.TestOp
				bne .88					NONE, or OR : exit with last result
				
				>LDA.G CORE.TestArg		AND : stop if false
				>AND.G CORE.Test
				>STA.G CORE.Test
				
.88				clc
				rts
*--------------------------------------
EXP.TEST.UNARY 	jsr CORE.ArgV.Next
				beq EXP.OP.UNARY.ESYN	we need one arg or ]
				
				>LDA.G CORE.Operator
				asl
				tax
				jmp (J.EXP.OP.UNARY,x)

EXP.OP.UNARY.ESYN
				lda #E.ESYN
				sec
				rts
				
EXP.OP.UNARY.D	jsr EXP.OP.UNARY.STAT
				bcs EXP.OP.UNARY.DEF.9
				>LDA.G StatBuf+S.STAT.P.TYPE
				cmp #S.FI.T.DIR
				bne EXP.OP.UNARY.DEF.9
				bra EXP.OP.UNARY.DEF.8
	
EXP.OP.UNARY.E	jsr EXP.OP.UNARY.STAT
				bcs EXP.OP.UNARY.DEF.9
				bra EXP.OP.UNARY.DEF.8		DIR or FILE exist
				
EXP.OP.UNARY.F	jsr EXP.OP.UNARY.STAT
				bcs EXP.OP.UNARY.DEF.9

				>LDA.G StatBuf+S.STAT.P.TYPE
				cmp #S.FI.T.DIR
				beq EXP.OP.UNARY.DEF.9
				bra EXP.OP.UNARY.DEF.8

EXP.OP.UNARY.STAT
				>PUSHEA.G StatBuf
				>LDYA ZPArgVBufPtr
				>SYSCALL STAT
				php
	
				jsr CORE.ArgV.Next
				plp
				rts
			
EXP.OP.UNARY.DEF.8	
				lda #$80				true
				clc
				rts

EXP.OP.UNARY.DEF.9	
				lda #0					false
				clc
				rts
*--------------------------------------
EXP.OP.UNARY.N	lda (ZPArgVBufPtr)		[ -N ] ?
				cmp #']'
				beq EXP.OP.UNARY.DEF.9	FALSE
				
				jsr CORE.ArgV.Next
				beq EXP.OP.UNARY.ESYN
				bra EXP.OP.UNARY.DEF.8	arg is not empty TRUE
				 
EXP.OP.UNARY.Z	lda (ZPArgVBufPtr)		[ -Z ] ?

				cmp #']'
				beq EXP.OP.UNARY.DEF.8	TRUE
				
				jsr CORE.ArgV.Next
				beq EXP.OP.UNARY.ESYN
				bra EXP.OP.UNARY.DEF.9	FALSE
*--------------------------------------
EXP.TEST.BINARY	>LDA.G CORE.Operator
				cmp #6					=, !=, <= <, >=, >
				bcs EXP.TEST.BINARY.NUM
				
				>LDYA ZPArgVBufPrev
				>STYA ZPPtr1
				
				jsr CORE.ArgV.Next
				beq EXP.TEST.BINARY.ESYN
				
				>PUSHW ZPPtr1
				>LDYA ZPArgVBufPtr
				>SYSCALL strcmp
				bcs .1					CS if !=			
				
				lda #%010				010 str1 = str2				
				bra EXP.TEST.BINARY.END
				
.1				asl						CS if <
				bcs .2
				
				lda #%100				010 str1 < str2				
				bra EXP.TEST.BINARY.END
				
.2				lda #%001				010 str1 > str2				
				bra EXP.TEST.BINARY.END
				
EXP.TEST.BINARY.ESYN
				lda #E.ESYN
				sec
				rts
*--------------------------------------
EXP.TEST.BINARY.NUM
				>LDYA ZPArgVBufPrev
				>SYSCALL AToL
				bcs EXP.TEST.BINARY.ESYN

				>PULLL M32.ACC
				
				jsr CORE.ArgV.Next
				beq EXP.TEST.BINARY.ESYN
				
				>LDYA ZPArgVBufPtr
				>SYSCALL AToL
				bcs EXP.TEST.BINARY.ESYN

				>PULLL M32.ARG
				
				jsr M32.Cmp
				
EXP.TEST.BINARY.END				
				pha

				>LDA.G CORE.Operator
				tax
				pla
				and EXP.OP.BINARY.BITS,x
				beq .80

				lda #$80				true
				clc
				rts
				
.80				lda #0					false
				clc
				rts			
*--------------------------------------
MAN
SAVE USR/SRC/BIN/SH.S.EXP
LOAD USR/SRC/BIN/SH.S
ASM
