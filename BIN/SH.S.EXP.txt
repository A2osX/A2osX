NEW
  AUTO 3,1
				.LIST OFF	
*--------------------------------------
EXP.GET			jsr CORE.ArgV.Next
				bne .1
				
				>LDYA ZPArgVBufPrev		no op, return text value
				clc
				rts
				
.1				>LDYA ZPArgVBufPrev
				>SYSCALL AToL			To Int32 on stack
				bcs .9
				
.2				>LDYA L.EXP.OP.MATH		+ - .... ?
				jsr CORE.LookupArgVBuf
				bcs .94

				stx CORE.Operator
				
				jsr CORE.ArgV.Next		get next argument
				beq .94
				
				>LDYA ZPArgVBufPtr
				>SYSCALL AToL			To Int32 on stack
				bcs .94

				jsr EXP.FPU.EXEC
				
				jsr CORE.ArgV.Next	another op ?
				bne .2
				
.8				>PUSHBI 4				ACC on stack
				>PUSHW L.M32.Printf
				>LEA.G M32.BUF
				>SYSCALL sprintf
				bcs .9
				
				>LEA.G M32.BUF
				
				rts
				
.94				>POP 4
				
.9				lda #E.ESYN
				sec
				rts
				
EXP.FPU.EXEC	ldy CORE.Operator
				ldx EXP.OP.MATH.FPU,y

				jmp A2osX.FpuCall
*--------------------------------------
EXP.TEST		lda (ZPArgVBufPtr)
				beq .9

				lda #$80
				sta CORE.LogicOp		No Op
				
.10				>LDYA L.EXP.BEGIN
				jsr CORE.LookupArgVBuf

				bcs .9
			
				dex						0=[ or 1=![ , $ff or 0
				txa
				asl						in C
				php
				
				lda CORE.TestResult		get parent
				asl						discard true/false
				plp						get new
				ror						set ctx and parent
				sta CORE.TestResult
				
				jsr CORE.ArgV.Next
				beq .9

				>LDYA L.EXP.OP.UNARY	-d -e -f -n -z ?
				jsr CORE.LookupArgVBuf

				bcs .1

				stx CORE.Operator
			
				jsr EXP.TEST.UNARY
				bcs .9
				
				eor CORE.TestResult
				sta CORE.TestResult
				lda (ZPArgVBufPtr)
				bra .8					go check ]

.9				lda #E.ESYN
				sec
.99				rts
				
.1				jsr CORE.ArgV.Next
				beq .9
				
				>LDYA L.EXP.OP.BINARY	-eq -ne .... ?
				jsr CORE.LookupArgVBuf
				bcs .9
				
				stx  CORE.Operator
				
				jsr EXP.TEST.BINARY
				bcs .9

				eor CORE.TestResult
				sta CORE.TestResult

				jsr CORE.ArgV.Next
				beq .9
				
.8				cmp #']'
				bne .9
				
				ldy #1
				lda (ZPArgVBufPtr),y
				bne .9
				
				jsr CORE.ArgV.Next
				beq .80
				
				>LDYA L.EXP.OP.LOGIC
				jsr CORE.LookupArgVBuf
				bcs .9

				stx CORE.LogicOp		0 = AND, 1 = OR
				txa
				beq .84
				
				lda CORE.TestResult		OR : prev test is true, exit
				bmi .88
				bra .85
				
.84				lda CORE.TestResult		AND : prev test is false, exit
				bpl .88
				
.85				lda CORE.TestResult
				sta CORE.PrevTestResult
				
				jsr CORE.ArgV.Next
				beq .9
				
				jmp .10			
				
.80				lda CORE.LogicOp
				bne .88					NONE, or OR : exit with last result
				
				lda CORE.PrevTestResult	AND : stop if false
				and CORE.TestResult
				sta CORE.TestResult
				
.88				clc
				rts
*--------------------------------------
EXP.TEST.UNARY 	jsr CORE.ArgV.Next
				beq EXP.OP.UNARY.ESYN	we need one arg or ]
				
				lda CORE.Operator
				asl
				tax
				jmp (J.EXP.OP.UNARY,x)

EXP.OP.UNARY.ESYN
				lda #E.ESYN
				sec
				rts
				
EXP.OP.UNARY.D	jsr EXP.OP.UNARY.STAT
				bcs EXP.OP.UNARY.DEF.9
				>LDA.G StatBuf+S.STAT.P.TYPE
				cmp #S.FI.T.DIR
				bne EXP.OP.UNARY.DEF.9
				bra EXP.OP.UNARY.DEF.8
	
EXP.OP.UNARY.E	jsr EXP.OP.UNARY.STAT
				bcs EXP.OP.UNARY.DEF.9
				bra EXP.OP.UNARY.DEF.8		DIR or FILE exist
				
EXP.OP.UNARY.F	jsr EXP.OP.UNARY.STAT
				bcs EXP.OP.UNARY.DEF.9

				>LDA.G StatBuf+S.STAT.P.TYPE
				cmp #S.FI.T.DIR
				beq EXP.OP.UNARY.DEF.9
				bra EXP.OP.UNARY.DEF.8

EXP.OP.UNARY.STAT
				>PUSHEA.G StatBuf
				>LDYA ZPArgVBufPtr
				>SYSCALL STAT
				php
	
				jsr CORE.ArgV.Next
				plp
				rts
			
EXP.OP.UNARY.DEF.8	
				lda #$80				true
				clc
				rts

EXP.OP.UNARY.DEF.9	
				lda #0					false
				clc
				rts
*--------------------------------------
EXP.OP.UNARY.N	lda (ZPArgVBufPtr)		[ -N ] ?
				cmp #']'
				beq EXP.OP.UNARY.DEF.9	FALSE
				
				jsr CORE.ArgV.Next
				beq EXP.OP.UNARY.ESYN
				bra EXP.OP.UNARY.DEF.8	arg is not empty TRUE
				 
EXP.OP.UNARY.Z	lda (ZPArgVBufPtr)		[ -Z ] ?

				cmp #']'
				beq EXP.OP.UNARY.DEF.8	TRUE
				
				jsr CORE.ArgV.Next
				beq EXP.OP.UNARY.ESYN
				bra EXP.OP.UNARY.DEF.9	FALSE
*--------------------------------------
EXP.TEST.BINARY	lda CORE.Operator
				cmp #6					=, !=, <= <, >=, >
				bcs EXP.TEST.BINARY.NUM
				
				>LDYA ZPArgVBufPrev
				>STYA ZPPtr1
				
				jsr CORE.ArgV.Next
				beq EXP.TEST.BINARY.ESYN
				
				>PUSHW ZPPtr1
				>LDYA ZPArgVBufPtr
				>SYSCALL strcmp
				bcs .1					CS if !=			
				
				lda #%010				010 str1 = str2				
				bra EXP.TEST.BINARY.END
				
.1				asl						CS if <
				bcs .2
				
				lda #%100				010 str1 < str2				
				bra EXP.TEST.BINARY.END
				
.2				lda #%001				010 str1 > str2				
				bra EXP.TEST.BINARY.END

EXP.TEST.BINARY.ESYN4
				>POP 4
				
EXP.TEST.BINARY.ESYN
				lda #E.ESYN
				sec
				rts
*--------------------------------------
EXP.TEST.BINARY.NUM
				>LDYA ZPArgVBufPrev
				>SYSCALL AToL
				bcs EXP.TEST.BINARY.ESYN
			
				jsr CORE.ArgV.Next
				beq EXP.TEST.BINARY.ESYN4
				
				>LDYA ZPArgVBufPtr
				>SYSCALL AToL
				bcs EXP.TEST.BINARY.ESYN4

				>FPU SUB32
				
				>PULLL M32.ACC

				lda M32.ACC+3
				bmi .4					ACC < ARG

				ora M32.ACC+2
				ora M32.ACC+1
				ora M32.ACC
				
				bne .5
				
				lda #%010				010 ACC = ARG
				bra EXP.TEST.BINARY.END	
				
.4				lda #%100				100 ACC > ARG
				bra EXP.TEST.BINARY.END	
				
.5				lda #%001				001	ACC < ARG
			
EXP.TEST.BINARY.END				
				clc
				ldx CORE.Operator
				and EXP.OP.BINARY.BITS,x
				beq .8					false

				lda #$80				true

.8				rts		
*--------------------------------------
MAN
SAVE USR/SRC/BIN/SH.S.EXP
LOAD USR/SRC/BIN/SH.S
ASM
