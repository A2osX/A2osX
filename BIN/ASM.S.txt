PR#3
PREFIX /A2OSX.SRC
NEW
INC 1
AUTO 6
					.LIST OFF
					.OP	65C02
					.OR $2000
					.TF	/A2OSX.BOOT/BIN/ASM
*---------------------------------------
					.INB INC/MACROS.I
					.INB INC/A2OSX.I
					.INB INC/A2OSX.API.I
					.INB INC/LIBSTR.I
*---------------------------------------
SYM.BLOCK.SIZE		.EQ 4096
SYM.BLOCK.MAX		.EQ 8
SRC.IN.DEPTH.MAX	.EQ 7
SRC.LABEL.MAXLEN	.EQ 16
*---------------------------------------
ERR.INV.ARGS		.EQ 1
ERR.SRC.INV.TYPE	.EQ 2
ERR.SRC.TOO.MANY.IN	.EQ 3
ERR.SYNTAX.ERROR	.EQ 99
ERR.SYM.TOO.LONG	.EQ 10
ERR.VAL.TOO.BIG		.EQ 11
ERR.LINE.TOO.LONG	.EQ 20
ERR.INVALID.LABEL	.EQ 21

*--------------------------------------
*			File Header (16 Bytes)
*--------------------------------------
CS.START			cld
					jmp (.1,x)
					.DA #$61			6502,Level 1 (65c02)
					.DA #1				BIN Layout Version 1
					.DA 0
					.DA CS.END-CS.START
					.DA DS.END-DS.START	Data Segment to Allocate
					.DA 0
					.DA 0
*--------------------------------------
* Relocation Table
*--------------------------------------
.1					.DA CS.INIT
					.DA CS.RUN
					.DA CS.DOEVENT		
					.DA	CS.QUIT
L.LIBSTR			.DA LIBSTR
L.MSG.HELP1			.DA MSG.HELP1
L.MSG.HELP2			.DA MSG.HELP2
L.MSG.SRCLINE		.DA MSG.SRCLINE
L.MSG.ERROR			.DA MSG.ERROR
L.READ.BUFFER		.DA READ.BUFFER
T.DIRECTIVES.JMP	.DA DIR.LI
					.DA 0
*---------------------------------------
CS.INIT				>LDYA L.LIBSTR
					>LOADLIBYA
					sta hLIBSTR
					
					ldy #S.PS.hARGS
					lda (pPs),y
					bne CS.INIT.ARGS
					
					>PUSHW L.MSG.HELP1
					>LIBCALL hLIBSTR,LIBSTR.PRINTF
					>PUSHW L.MSG.HELP2
					>LIBCALL hLIBSTR,LIBSTR.PRINTF
					lda #ERR.INV.ARGS
					sec
					rts

CS.INIT.ARGS		>SYSCALL SYS.GetMemPtrA
					>STYA ZPQuickPtr1
					lda (ZPQuickPtr1)
					beq .98
					
.1					ldy #1
					lda (ZPQuickPtr1),y
					cmp #'/'
					bne .2
					ldy #S.PS.hARGS
					lda (pPs),y
					>SYSCALL SYS.PStrCpyA
					bra .3
					
.2					ldy #S.PS.hARGS
					lda (pPs),y
					>PUSHA
					ldy #S.PS.hPREFIX
					lda (pPs),y
					>PUSHA
					>SYSCALL SYS.PStrCat
					
					ldy #SRC.hFILENAME
					sta (pData),y			Store filename
					
.3					lda (pPs)
					ora #S.PS.F.EVENT		Now accept events
					sta (pPs)

					clc
					rts
					
.98					lda #ERR.INV.ARGS

					sec
.99					rts
*--------------------------------------
CS.RUN				ldy #bCANCEL
					lda (pData),y
					bne .99

					ldy #bSTOP
					lda (pData),y
					bne .8
					
					ldy #SRC.COUNT		root file is already opened?
					lda (pData),y
					bne .10 
					
					ldy #SRC.hFILENAME
					lda (pData),y
					
					jsr SRC.OpenFileA
					bcs *
					
.10					jsr SRC.ReadLine
					bcc .2
					cmp #$4C			End Of File?
					bne .9
					
					jsr SRC.FileClose
					
					ldy #SRC.COUNT		end of root file ?
					lda (pData),y
					bne .8				no continue back to previous file
					
					ldy #ASM.PASS
					lda (pData),y		End of pass #2 ??
					bne .1
					inc
					sta (pData),y
					clc
					rts
					
.1					lda #0				End of assembly, exit with no error
.99					sec		
					rts
					
.2					jsr SRC.ParseLine
					bcs .9
					
					>PUSHWI TmpBuffer256
					>PUSHW SRC.LINENUM
					>PUSHW L.MSG.SRCLINE
					>LIBCALL hLIBSTR,LIBSTR.PRINTF
					
.8					clc
					rts

.9					>PUSHA
					>PUSHW SRC.LINENUM
					>PUSHW L.MSG.ERROR
					>LIBCALL hLIBSTR,LIBSTR.PRINTF
					
					sec
					rts
*--------------------------------------
CS.DOEVENT			ldy #S.EVT.hDEV		is Event from active IN device?
					lda (pEvent),y
					ldy #S.PS.hINDEV
					cmp (pPs),y
					bne .9
					lda (pEvent)
					and #S.EVT.F.KEY		is it a KEY event?
					beq .9
					ldy #S.EVT.DATAHI		is it an O or SAPPLE key ?
					lda (pEvent),y
					bne	.9
					ldy #S.EVT.DATALO	
					lda (pEvent),y
					cmp #$03				Ctrl-C
					bne .1
					
					lda #$FF
					ldy #bCANCEL
					sta (pData),y
					bra .8
					
.1					cmp #$13				Ctrl-S
					bne .8
					
					ldy #bSTOP
					lda (pData),y
					eor #$FF
					sta (pData),y
					
.8					clc
					rts
					
.9					sec
					rts
*--------------------------------------
CS.QUIT				jsr SRC.FileClose
					bne CS.QUIT 

					ldy #SRC.hFILENAME
					lda (pData),y
					beq .8
					
					>SYSCALL SYS.FreeMemA
					
.8					lda hLIBSTR
					>SYSCALL SYS.UnloadLibA
					clc
					rts
*---------------------------------------
LOAD.ASM.T
					clc
					rts
*---------------------------------------
SRC.OpenFileA		sta hFileName

					ldy #SRC.COUNT
					lda (pData),y
					cmp #SRC.IN.DEPTH.MAX
					bne .10
					
					lda #ERR.SRC.TOO.MANY.IN
					sec
					rts
					
.10					lda hFileName
					>SYSCALL SYS.MLIOpenA
					bcs .99
					
					pha
					ldy #SRC.COUNT
					lda (pData),y
					clc
					adc #SRC.hREFNUMS
					tay
					pla
					sta (pData),y
					
					ldy #SRC.COUNT
					lda (pData),y
					clc
					adc #SRC.hBUFFERS
					tay
					txa
					sta (pData),y

					lda hFileName
					>SYSCALL SYS.MLIGetFileInfoA
					bcs .99

					>STYA ZPQuickPtr1
					ldy #1
					lda (ZPQuickPtr1),y
					tax
					
					ldy #SRC.COUNT
					lda (pData),y
					clc
					adc #SRC.hFILETYPES
					tay

					txa
					sta (pData),y
					
					cmp #$FA			S-C/BAS?
					beq .8
					
					cmp #$04			TXT ?
					
					bne .98

					>PUSHBI $0D		Line separator for TXT file
					>PUSHBI $FF
					
					ldy #SRC.COUNT
					lda (pData),y
					clc
					adc #SRC.hREFNUMS
					tay
					lda (pData),y
					>PUSHA
					>SYSCALL SYS.MLINewLine
					bcs .99
					
.8					ldy #SRC.COUNT
					lda (pData),y
					inc
					sta (pData),y
					clc
					rts
					
.98					lda #ERR.SRC.INV.TYPE
					
.99					sec
					rts
*---------------------------------------
SRC.ReadLine		ldy #SRC.COUNT
					lda (pData),y
					clc
					adc #SRC.hFILETYPES-1
					tay
					lda (pData),y
					bmi .10
					
					>PUSHWI 256
					>PUSHWI TmpBuffer256
					jsr SRC.ReadFromFile
					bcs .19 
					
					lda #0				replace ending $0D with $00
					sta TmpBuffer256,y
.19					rts

.10					>PUSHWI 3
					>PUSHW L.READ.BUFFER
					jsr SRC.ReadFromFile
					bcs .9 

					lda READ.BUFFER+1
					sta SRC.LINENUM
					lda READ.BUFFER+2
					sta SRC.LINENUM+1
					
					lda READ.BUFFER		LEN
					sec
					sbc #3
					bcc .9				LEN should be at least 3

					tay
					lda #0
					>PUSHYA
					>PUSHW L.READ.BUFFER
					jsr SRC.ReadFromFile
					
					ldy #0
					ldx #0
					
.1					lda READ.BUFFER,y
					bmi .2
					
					sta TmpBuffer256,x
					beq .8				Ending 00
					inx
					beq .99
					iny
					bne .1
					bra .99
					
.2					cmp #$C0			REPEAT char?
					bne .5
					iny
					beq .99
					lda READ.BUFFER,y
					iny
					beq .99
.3					pha
					lda READ.BUFFER,y
					sta TmpBuffer256,x
					pla
					inx
					beq .99
					dec
					bne .3
					iny
					bne .1
					bra .99
					
.5					and #$3F			Compute blank count
.6					pha
					lda #$20
					sta TmpBuffer256,x
					pla
					inx
					beq .99
					dec
					bne .6
					iny
					bne .1
					bra .99
					
.8					clc
.9					rts

.99					lda #ERR.LINE.TOO.LONG
					sec
					rts
*--------------------------------------
SRC.ReadFromFile	ldy #SRC.COUNT
					lda (pData),y
					clc
					adc #SRC.hREFNUMS-1
					tay
					lda (pData),y
					>PUSHA
					>SYSCALL SYS.MLIRead
					bcs .9
					tax					$100 byte transfered ?
					beq .9
					lda #ERR.LINE.TOO.LONG
					sec
.9					rts
*---------------------------------------
SRC.FileClose		ldy #SRC.COUNT
					lda (pData),y
					beq .8
					
					clc
					adc #SRC.hREFNUMS-1
					tay
					lda (pData),y
					>SYSCALL SYS.MLICloseA
					
					ldy #SRC.COUNT
					lda (pData),y
					clc
					adc #SRC.hBUFFERS-1
					tay
					lda (pData),y
					>SYSCALL SYS.FreeMemA
					
					ldy #SRC.COUNT
					lda (pData),y
					dec
					sta (pData),y
					
.8					clc
					rts
*---------------------------------------
SRC.ParseLine		stz SRC.Label.Flags
					stz SRC.BufPtr
					lda TmpBuffer256
					beq SRC.ParseLine.Ok
					cmp #'*'			Comment?
					beq SRC.ParseLine.Ok
					cmp #' '
					beq SRC.ParseLine.OpCde
					
SRC.ParseLine.Sym	cmp #'.'			Local Label?
					bne SRC.ParseLine.SymG
					
					jsr SRC.GetChar
					beq SRC.ParseLine.Err1
					jsr SRC.GetDecimal
					bcs SRC.ParseLine.Err1
					jsr SYM.AddLocal
					bcc SRC.ParseLine.OpCde
					rts
 
SRC.ParseLine.SymG	jsr SYM.ClearLocal
					jsr SRC.GetLabel
					bcs SRC.ParseLine.Err1
					
					inc SRC.Label.Flags	Remember to Add Label
					
					ldx #3				Makes Current Label = PC for now
					ldy #ASM.PC
					lda (pdata),y
.1					sta SRC.LabelValue,x
					dey
					dex
					bpl .1
											
SRC.ParseLine.OpCde	jsr SRC.GetCharNB
					beq SRC.ParseLine.Ok
					
SRC.ParseLine.Ok	lda SRC.Label.Flags
					beq .8
					
					jsr SYM.AddLocal
					
.8					clc					
					rts
					
SRC.ParseLine.Err1	lda #ERR.INVALID.LABEL
SRC.ParseLine.Err	sec
					rts
*---------------------------------------
SRC.GetDecimal		stz SRC.ACC+1
					stz SRC.ACC+2
					stz SRC.ACC+3
					
					jsr SRC.GetChar
					beq .99
					jsr SRC.IsDigit10
					bcs .99
					and #$0F
					sta SRC.ACC
					
.1					jsr SRC.GetChar
					beq .8
					cmp #' '
					beq .8
					jsr SRC.IsDigit10
					bcs .99
					and #$0F
					
					pha
					jsr SRC.ACC10
					pla
					bcs .9
					clc
					adc SRC.ACC
					sta SRC.ACC
					bcc .1
					
					inc SRC.ACC+1
					bne .1
					inc SRC.ACC+2
					bne .1
					inc SRC.ACC+3
					bne .1
					
.9					lda #ERR.VAL.TOO.BIG
					sec
					rts
					
.8					clc
					rts
					
.99					lda #ERR.SYNTAX.ERROR
					sec
					rts
*---------------------------------------
SRC.GetLabel		jsr SRC.GetChar
					
					beq .9
					jsr SRC.IsLetter
					bcs .9
					sta SRC.Label
					
					ldy #1
					
.1					jsr SRC.GetChar
					beq .8
					
					cmp #' '
					beq .8
					
					cmp #'.'
					beq .2
					
					jsr SRC.IsLetterOrDigit
					bcs .9
.2					sta SRC.Label,y
					iny
					cpy #SRC.LABEL.MAXLEN
					bne .1				if equ Carry is set
					
.9					sec
					rts					
					
.8					lda #0
					sta SRC.Label,y
					clc
					rts
*---------------------------------------
SRC.IsLetterOrDigit jsr SRC.IsDigit10
					bcc SRC.IsLetterRTS
*---------------------------------------
SRC.IsLetter		cmp #'A'
					bcc .9
					cmp #'['
					bcc SRC.IsLetterRTS

					cmp #'a'
					bcc .9
					cmp #'{'
					bcs SRC.IsLetterRTS
					
					adc #$20			to Uppercase
					rts
					
.9					sec					
SRC.IsLetterRTS		rts					
*---------------------------------------
SRC.IsDigit10		cmp #'0'
					bcc .9
					cmp #':'
					rts					cc if ok, cs if not
					
.9					sec
					rts
*---------------------------------------
SRC.GetCharNB		jsr SRC.GetChar
					beq .9
					cmp #' '
					beq SRC.GetCharNB
.9					rts
*---------------------------------------
SRC.GetChar			ldx SRC.BufPtr
					lda TmpBuffer256,x
					inc SRC.BufPtr
					and #$7f
					rts
*---------------------------------------
SYM.ClearPrivate
					clc
					rts
*---------------------------------------
SYM.AddPrivate		
					clc
					rts
*---------------------------------------
SYM.LookupPrivate
					clc
					rts
*---------------------------------------
SYM.ClearLocal
					clc
					rts
*---------------------------------------
SYM.AddLocal		
					clc
					rts
*---------------------------------------
SYM.LookupLocal	
					clc
					rts
*---------------------------------------
SYM.AddGlobal		
					clc
					rts
*---------------------------------------
SYM.LookupGlobal	
					clc
					rts
*---------------------------------------
SYM.BLOCK.ALLOC		ldx #0
.1					lda SYM.BLOCKS,x
					beq .2
					inx
					cpx #SYM.BLOCK.MAX
					bne .1				
					lda #ERR.SYM.TOO.LONG
					sec 				Out of block error
					rts
					
.2					phx					Save next free block
					>LDYA SYM.BLOCK.SIZE
					>SYSCALL SYS.GetMem
					bcs .9
					txa
					plx
					sta SYM.BLOCKS,x
					clc
.9					rts		
*---------------------------------------
SRC.ACC10			lda SRC.ACC			ACC*2-> ACC & ACCTMP
					asl
					sta SRC.ACC
					sta SRC.ACCTMP
					lda SRC.ACC+1
					rol
					sta SRC.ACC+1
					sta SRC.ACCTMP+1
					lda SRC.ACC+2
					rol
					sta SRC.ACC+2
					sta SRC.ACCTMP+2
					lda SRC.ACC+3
					rol
					sta SRC.ACC+3
					sta SRC.ACCTMP+3
					bcs .9
					
					ldx #1
.1					asl SRC.ACC			ACC=ACC*8
					rol SRC.ACC+1
					rol SRC.ACC+2
					rol SRC.ACC+3
					bcs .9
					dex
					bne .1
					
					lda SRC.ACC			CC from ROL SRC.ACC+3
					adc SRC.ACCTMP
					sta SRC.ACC
					lda SRC.ACC+1
					adc SRC.ACCTMP+1
					sta SRC.ACC+1
					lda SRC.ACC+2
					adc SRC.ACCTMP+2
					sta SRC.ACC+2
					lda SRC.ACC+3
					adc SRC.ACCTMP+3
					sta SRC.ACC+3		CS if overflow
					
.9					rts					
*---------------------------------------
DIR.LI				clc
					rts
*---------------------------------------
CS.END
T.DIRECTIVES		.AS "AS"
					.AS "AT"
					.AS "AZ"
					.AS "BS"
					.AS "DA"
					.AS "DO"
					.AS "DU"
					.AS "ED"
					.AS "EL"
					.AS "EN"
					.AS "EP"
					.AS "EQ"
					.AS "FI"
					.AS "HS"
					.AS "IN"
					.AS "LI"
					.AS "MA"
					.AS "OP"
					.AS "OR"
					.AS "PG"
					.AS "PH"
					.AS "TA"
					.AS "TF"
					.AS "TI"
					.AS "US"
T.DIRECTIVES.END	.EQ *					
*---------------------------------------
LIBSTR				>PSTRING "libstr.o"
MSG.HELP1			>CSTRING "A2osX-Macro Assembler (S-C MASM 2.0 Based)\n"
MSG.HELP2			>CSTRING "Usage : ASM <src file> [type TXT ($04) or S-C/BAS ($FA)]\n"
MSG.SRCLINE			>CSTRING "%05D-%s\n"
MSG.ERROR			>CSTRING "%05D-Error:$%h\n"
hLIBSTR				.BS	1
hFileName			.BS 1
SRC.LINENUM			.BS 2
SRC.BufPtr			.BS 1
SRC.Label.Flags		.BS 1
SRC.Label			.BS	SRC.LABEL.MAXLEN
SRC.LabelValue		.BS 4
SRC.ACC				.BS 4
SRC.ACCTMP			.BS 4
READ.BUFFER			.BS 256
*--------------------------------------
					.DUMMY
					.OR 0
DS.START				
bSTOP				.BS 1
bCANCEL				.BS 1

SRC.hFILENAME		.BS 1

SRC.COUNT			.BS 1
SRC.hREFNUMS		.BS SRC.IN.DEPTH.MAX	Store ref_num of opened files (Main, .INs & .INBs)
SRC.hBUFFERS		.BS SRC.IN.DEPTH.MAX	Store hMem to allocated buffers
SRC.hFILETYPES		.BS SRC.IN.DEPTH.MAX	Store file type of opened SRC files

DST.hFILENAME		.BS 1
DST.hREFNUM			.BS 1
DST.hBUFFER			.BS 1
DST.hFILETYPE		.BS 1

ASM.T.hFILENAME		.BS 1
ASM.T.hFILE			.BS 1				handle to loaded ASM.T.xxxxx
ASM.PASS			.BS 1
ASM.PH.ON			.BS 1
ASM.LI.OFF			.BS 1
ASM.PC				.BS 4				32Bits PC
ASM.PC.PH			.BS 4				32Bits PC saved for PH directive

SYM.BLOCKS			.BS SYM.BLOCK.MAX
DS.END				.ED
*---------------------------------------
MAN
SAVE BIN/ASM.S
ASM
