# AcosX Words

## Description

This document lists all of the **ACOS Words** supported in the A2osX implementation of **ACOS**.  Note that not all **Words** are implemented at this time, please check the *Status* and *Comment* Columns.  Currently only an interpreter is available (*../bin/bbsd*) | | though a compiler is planned |

## Words
| Word | Syntax | Status | Short | Description | Comment |
|-|-|-|-|-|-|
| ADDINT | ADDINT (*string1* [,*string2*...]) | Not Yet Implemented | Add keys to the interrupt table. | The <tt>ADDINT</tt> command will add more keys to the existing interrupt keys table. previous keys will not be cleared. The functions of the keys is the same as with the <tt>SETINT</tt> command. |  |
| APPEND | APPEND #*device* | Not Yet Implemented | Set write operations for specified device to append to the end. | The <tt>APPEND</tt> statement is generally used to add data to an existing file. If you issue an <tt>APPEND</tt> statement, the file pointer will be moved to the end of the file. You can also find out the length of a file by doing an <tt>APPEND</tt> and then using the <tt>MARK</tt> function. Mark will then return the length of the file in bytes. |  |
| BYTE | byte=*number*<br>byte=(*number*)<br>byte=(*number*)=*number*256 | Not Yet Implemented | Byte-level data manipulation function. | The <tt>BYTE</tt> function is similar to the <tt>FLAG</tt> function. It is a low overhead data storage unit. Just point to where in memory you want the data to be stored using the first syntax, and you can then access the data using the second or third syntax's. |  |
| CHR$ | string=CHR$(ascii code [,number chars]) | Not Yet Implemented | Return string representation of ASCII code. | Returns a string with the character represented by the ASCII code. If extra *numchars* is specified, then returned string will contain that many repetitions of the character instead of just one. |  |
| CLEAR | clear<br>clear #*device* | Not Yet Implemented | Clear device. | The forms to clears share only one thing in common; they both clear data in one form or another. In the first syntax (without an argument), <tt>CLEAR</tt> will reset all the variables to nil, clear all the addresses from the for-next and gosub-return stack, and close all open files. Suggested use is at beginning of program.<p>In its second syntax, <tt>CLEAR</tt> is used to clear out device buffers. The legal device channels are 8, 9, 10. <tt>CLEAR #8</tt> will clear the editor so that any output into the editor will be appended to a clear editor. <tt>CLEAR #9</tt> will clear the top of screen display. You must clear the top of screen display before you write any info into it. <tt>CLEAR #10</tt> will clear the ram drive. any further writes will be appended on to the end. |  |
| CLOCK | CLOCK(0)<br>CLOCK(1)=*expression*<br>*expression*=CLOCK(2) | Not Yet Implemented | Session timer operations. | The <tt>CLOCK</tt> function/statement is used for setting a time limit. It can also be used to find out how long someone has been using the system (i.e. how long since <tt>CLOCK(0)</tt> was called). The following options are available:<p><ul><li><tt>CLOCK(0)</tt>- This statement is used to reset the clock time to zero. It should be executed when your program begins.<li><tt>CLOCK(1)</tt>- You will need to set CLOCK(1) equal to the number of minutes you want as a time limit, or 0 for no limit. when the time limit expires, it will be handled as a "no carrier" situation. The program will jump to the <tt>NOCAR</tt> routine.<br><li><tt>CLOCK(2)</tt>- The CLOCK(2) function will return the number of seconds that a user has been connected. divide this number by 60 to find how many minutes they have been connected.</ul> |  |
| CLOSE | CLOSE<br>CLOSE #*device* | Not Yet Implemented | Close file I/O for specified dev ice. | The <tt>CLOSE</tt> command is used to close a disk file after you are done with it. If you give a device channel with the close command, only that file will be closed. If you <tt>CLOSE</tt> with no arguments, all open files will be closed. |  |
| COPY | COPY *filename* [,#*device*]<br>COPY #*device* [,#*device*] | Not Yet Implemented | Copy file or device contents to target device. | The <tt>COPY</tt> command is used for displaying and copying information from device to device. The first argument can be a filename, in which case, the file is opened and input is taken from that file, or it can be a device. The second device is optional. If present all output will be routed there, otherwise it will be displayed to the modem/console. The second argument may not be another filename. If you wish to copy to a file, open the file with the <tt>OPEN</tt> command, and copy to that device. |  |
| CREATE | CREATE *filename* | Not Yet Implemented | Create an empty file. | The <tt>CREATE</tt> statement is used to create an empty file on the disk. The new file can be opened and read and written to just as any other file would be. If you want to create a new file, you must use the <tt>CREATE</tt> statement first unlike some other languages which will create files by simply using the <tt>OPEN</tt> command on a file that does not already exist. If the file already exists, the file (contents or timestamp) will not be modified in any way. |  |
| CRUNCH | CRUNCH | Not Yet Implemented | Truncate specified message database. | The <tt>CRUNCH</tt> statement is used in conjunction with the MSG commands. It is used to "CRUNCH" together (truncate) a message file to reclaim space from deleted messages. |  |
| DATE$ | *string*=DATE$ | Not Yet Implemented | Return string with current date. | The <tt>DATE$</tt> function returns the current date in MM/DD/YY format. The input will be taken from whatever device was configured as a clock. If 00/00/00 is returned, then there is no clock in the system and the date hasn't been set. |  |
| ECHO | ECHO=*string*<br>ECHO="" | Not Yet Implemented | Specify or clear characters to be echoed during user input. | The <tt>ECHO</tt> statement is used to set the echo character to be used with the <tt>INPUT</tt> statement (e.g <code>ECHO="\*"</code> will mask password entry with asterisks). Once the echo has been set, that character will be sent each time a user types a character when entering text. The <tt>ECHO</tt> statement in the second syntax (setting to an empty string) will reset the echo function to normal where user input will send the character that is being typed. |  |
| EDIT | EDIT(*number*) | Not Yet Implemented | Text editor operations. | The <tt>EDIT</tt> statement is the command used to interface ACOS with its editor. With the different <tt>EDIT</tt> statements, you can clear the editor, see how much space is free, etc. The following list gives all legal calls:<p><ul><li><tt>EDIT(0)</tt>- clears the editor. there will be a total of 4096 bytes free after a clear takes place.<br><li><tt>EDIT(1)</tt>- enter the editor. If no data is present, the editor will start to accept input right away. If other data is present, the editor will start in the prompt mode.<br><li><tt>EDIT(2)</tt>- this is a function that returns the number of bytes used within the editor. If this number equals 0 the editor is empty.<br><li><tt>EDIT(3)</tt>- this is used to set the video width to be used within the editor. Any value from 1 to 255 is legal. the most often used widths are 32, 40, 64, 80, 128. All operations within the editor will be based around this width. You can also read the current width using <tt>EDIT(3)</tt> as a function.<br><li><tt>EDIT(4)</tt>- this is used to set the 'back-space mode' that the editor will use. Certain modes allow more control than others. Mode 0 indicates that the actual mode is not known. The editor will work fine, but some functions will be disabled. Under mode 1, the editor will assume that the user has a 'non-destructible' backspace. This allows all the editor functions to be used and is how the local console is setup. Mode 2 tells the editor that the user has a 'destructible' backspace. Under this mode, some functions are disabled, but the editor speeds up certain other functions. |  |
| END | END | Not Yet Implemented | Terminate program. | Same as AppleSoft, this command terminates program. Returns to ACOS restart state. REMY TODO: Does this just return to A2osX shell? |  |
| FILL | FILL *start*, *length*, *data* | Not Yet Implemented | Fill an area of memory with specified data. | The <tt>FILL</tt> statement is used to fill an area of memory with some bytes of data. Generally it is used to zero out memory. *start* is a 16 bit memory address, *length* is an 8 bit [0-255] number, and *data* is the byte that will be used to fill memory. |  |
| FLAG | *variable*=FLAG<br>FLAG=*memloc*<br>FLAG=(*flagnum*)<br>FLAG(*flagnum*)=*value* | Not Yet Implemented | Bit-level data manipulation function. | The <tt>FLAG</tt> function is a low overhead way to store 1 bit information. You just need to point the <tt>FLAG</tt> function to a point in memory (typically 'ram' or 'ram2') that you wish to store your data in, and you can manipulate as many flags as you need. Each byte of memory can contain 8 flags.<p>To setup the <tt>FLAG</tt> function, you need to first point it to a location in memory (*memloc*), which is typically 'ram' or 'ram2', but you can specify an offset, e.g. <code>FLAG=ram+20</code> will specify that you're using the 20th byte inside of the 'ram' location.<p>Once the pointer is set up, you can use the <tt>FLAG</tt> function just like any variable using the remaining syntax forms outlined for reading/writing flags. |  |
| FOR | FOR *numvar*=*startvalue* TO *targetvalue* [STEP *number*]<br>...<br>NEXT | Not Yet Implemented | Program loop iteration declaration. | Creates a loop in program execution that sets a variable *numvar* to initially *startvalue* and increments its value with each iteration and will repeat until that variable reaches *targetvalue*. The <tt>STEP</tt> keyword is optional, but allows you to specify *number* which overrides the typical +1 increment of the loop, i.e. you can count by 2 by specifying <code>STEP 2</code> or you can *decrement* by specifying a negative step number. In general, operates much the same way as AppleSoft FOR-NEXT loops, However, you can only have ONE for loop active at a time, i.e. the <tt>NEXT</tt> command does not allow for a variable, it only operates on the currently active FOR loop. |  |
| FREE | FREE | Not Yet Implemented | Return amount of free memory. | Has the same function as the AppleSoft <tt>FRE(0)</tt> command, in that it returns the amount of free memory. REMY TODO: Does this garbage collect? |  |
| GET | GET *varstr* | Not Yet Implemented | Get a single character from user. | The <tt>GET</tt> statement is used to get a single keypress from the user. This is a blocking call in that the system will wait until a key is pressed. The key will be returned in *varstr*. Control characters will not be filtered out as they are with <tt>INPUT.</tt> |  |
| GOSUB | GOSUB *label* | In Development | Call subroutine at specified label. | Calls subroutine *label* in the program and sets the point in code so that when a <tt>RETURN</tt> function is encountered, execution will resume after the <code>GOSUB</code> statement. While behaves the same way as AppleSoft basic, it is worth pointing out that ACOS uses labels as targets instead of line numbers. |  |
| GOTO | GOTO *label* | Working | Redirect program execution to specified label. | Redirects program execution to continue from *label*. Unlike <tt>GOSUB</tt>, no record of where the <tt>GOTO</tt> call occurred. As with <tt>GOSUB</tt>, it is worth pointing out that ACOS uses labels as targets intead of line number. |  |
| HOME | HOME | Not Yet Implemented | Clear screen. | Clears the screen and positions the cursor at the top left. REMY TODO: Does this clear the remote session as well? |  |
| IF | IF *condition* [THEN] *statement1* [ELSE] *statement2* | In Development | Logical condition test and execution. | Evaluate *condition* and if true (or greater than zero), execute *statement1*. If optional <tt>ELSE</tt> keyword is specified, then a false condition will execute *statement2*. If <tt>ELSE</tt> is used, it must appear on the same line as the <tt>IF</tt> statement, i.e. there is no multi-line if/then/else construct like some other languages. Logical constructs for *condition* supports parenthesis, <tt>AND</tt>, and <tt>OR</tt>.<p><tt>THEN</tt> is optional (as it is in AppleSoft BASIC) but if you use THEN, it cannot be followed by a label directly.(use IF arg THEN GOTO label). |  |
| INFO | *expression*=INFO(*optional*)<br>INFO(*optional*)=*expression* | Not Yet Implemented | Byte-level data manipulation function, specific to ACOS internals. | INFO can be used as either a statement or as a function. It is really a 'catch-all' of ACOS state value functions in nature in that many values that are more or less unrelated are accessible through it. The following table gives the meanings of all the INFO data.<p><pre>argument r/w       function<br>-------- ----      -----------------<br>INFO(0)  r         is there a caller online? (0=no)<br>INFO(1)  r         capacity of current message file.<br>INFO(2)  r         callers baud rate /300  (1=300)<br>INFO(3)  r/w       current number of nulls.<br>INFO(4)  w         top screen stats.  (1=chat, 2=exec)<br>INFO(5)  r/w       executive user online?  (1=yes)<br>INFO(6)  r         checks bit map for mail/msg bases for room.</pre> |  |
| INPUT | INPUT [#*device*,]  [@*mode*,]  [\\]  ["*text*"]  *variable* [,[\\] *variable*..] | Not Yet Implemented | Get input from user, device, or file. | Gets input from a device or interactively with the user and stores the result in one-to-many variables. There are quite a few variations how the <tt>INPUT</tt> statement can be used, but at a minimum it requires one *variable* to be specified.  <p> Specifying the *device* is required if inputting data from a device handle (e.g. an open file). Omitting the *device* will default to getting input from the user.  <p> A text prompt can be optionally specified by supplying *text* before the variables. The text can serve as a prompt (e.g. "What is your name? *input here*"). If backslash (\\) is put before or after the *text*, this will result in a newline being part of the prompt (note distinction between this and using backslash for multiple variables).  <p> Multiple variables can be specified in either a comma-separated or backslash (\\) way (or a mixture thereof), though this is typically for file input rather than interactive user input. As with the <tt>PRINT</tt> statement, the comma is taken literally (e.g. if you were to read multiple fields from a comma-separated file), and the backslash as part of the variable list implies that there will be a newline to parse (e.g. <code>INPUT #1, A\$\\B\$</code> reads two lines from the file, <tt>A\$</tt> on the first line and <tt>B\$</tt> on the second line).  <p> The *mode* (with '@' symbol prefix) is an optional way of specifying how the <tt>INPUT</tt> command will behave. Using *mode* is ONLY for interactive input and cannot be combined with a *device*. The various modes are as follows: <p> <ul><li><tt>INPUT</tt> - (no mode specified) set the input mode to uppercase, don't accept a blank line.  <li><tt>INPUT @0</tt> - set the input mode to uppercase, don't accept a blank line, just return the first character.  <li><tt>INPUT @1</tt> - set the input mode to uppercase, don't accept a blank line, don't accept any commas.  <li><tt>INPUT @2</tt> - set the input mode to uppercase, blank lines will be accepted.  <li><tt>INPUT @3</tt> - accept everything. (upper & lower).  </ul> |  |
| INSTR | *expression*=INSTR(*match*, *source*) | Not Yet Implemented | Find a string within another and return offset if found. | The <tt>INSTR</tt> function is used to search within a *source* string for the existence of the specified *match* string. The search is case insensitive. The function will return the numerical position of the first character in the *source* string where the *match* was found. Note that the first character in *source* string starts at <tt>1</tt>, not <tt>0</tt> like many other languages. So in other words, if the function returns zero, no match was found. |  |
| KEY | *expression*=KEY(0)<br>*expression*=KEY(1)<br>*expression*=KEY(2) | Not Yet Implemented | Return what key from the interrupt table was caught. | The <tt>KEY</tt> function is used to check and see what if any keys have been pressed. It is generally used to check to see if a routine needs to be interrupted and is used in conjunction with the <tt>SETINT</tt> and <tt>ADDINT</tt> statements. This routine is not blocking and does not wait for a key; it returns either a zero for no key or the ASCII value of the key. In the <tt>KEY(1)</tt> form, a non-zero byte will be returned if the key pressed was the 'file stop' character. In the <tt>KEY(2)</tt> form, a non-zero byte will be returned if the pressed key is the 'file next' key defined in config. |  |
| KILL | KILL *filename*<br>KILL #MSG(*expression*) | Not Yet Implemented | Delete a file or message. | The <tt>KILL</tt> statement can be used in two different ways. In both ways it is used to delete data. In the first form, with the *filename,* it will delete the file from disk. In its second form, it will delete a message within the currently active message base. After using <tt>KILL</tt> on a message, it is always a good idea to follow it with an <tt>UPDATE</tt> to make sure the modified message database is persisted to disk. |  |
| LEFT$ | *string*=LEFT$(*source*, *length*) | Not Yet Implemented | Return a number of characters from the start of a string. | Returns the first *length* characters of *source* string. |  |
| LEN | *expression*=LEN(*string*) | Not Yet Implemented | Return the length of a string. | Returns the length of the supplied *string*. A result of zero means the string is empty. |  |
| LINK | LINK *filename* [,*label*] | Not Yet Implemented | Load and execute another ACOS script. | The <tt>LINK</tt> statement allows you to load a different program segment and execute that one, optionally starting at a specified *label*. The purpose of this is to allow for your code to be split up into multiple segments, but also to support additional code to be used without modifying the other. The *filename* argument is mandatory and is in the standard filename syntax. If you wish the execution to begin at a point other than the beginning of the module, then the *label* argument can be specified in string form (e.g. <code>LINK "A:MSG.SEG","BULLETINS"</code>). The label must be enclosed in quotes or must be in a string variable. Note that for the label to be usable by the <tt>LINK</tt> command, the label must be declared as <tt>PUBLIC</tt> in the target file. |  |
| LOG | LOG *drivespec* | Not Yet Implemented | Change current filesystem drive. | The <tt>LOG</tt> statement simply changes the default disk drive to the *drivespec* drive. If the drive is not legal, a BAD DRIVE SPECIFIER error will occur. |  |
| MARK | *expression*=MARK(*device*)<br>MARK(*device*)=*number* | Not Yet Implemented | Set/get current file position offset. | The <tt>MARK</tt> function will allow you to either set or check the offset within the current file I/O. If you want to go to the beginning of a file, you would issue a <code>MARK(1)=0</code> assuming it was file device #1. <tt>MARK</tt> has a second function in that it can be used to see if a file exists. Normally ACOS will not generate an error if a file exists, so it can be hard to tell if there is one. To see if a file exists: <p><code>OPEN #1,filename<br>IF MARK(1) PRINT "FILE EXISTS"<br>CLOSE #1</code> |  |
| MID$ | *string*=MID$(*source*, *start* [,*length*]) | Not Yet Implemented | Return a number of characters from the middle of a string. | Returns the contents of *source* into *string* starting at character position *start* to the end of *source*, or only up to *length* number of characters. |  |
| MODEM | MODEM(*number*) | Not Yet Implemented | Modem (remote session) manipulation function. | The <tt>MODEM</tt> command is used for controlling the communication session with the remote user. The ACOS language was originally written for modems and thus the keyword is kept for consistency despite A2osX having replaced the underlying communications with a networking stack. Regardless, the functionality remains the same albeit applied to telnet sessions. The modem functions are as follows:<p><ul><li><tt>MODEM(0)</tt> - this command needs to be issued before any other modem command is used. Its function is to initialize the modem driver for later use.<li><tt>MODEM(1)</tt> - this command waits for an incoming call and establishes a connection. Execution will continue when either a call is connected or the user goes into local mode.<li><tt>MODEM(2)</tt> - this command causes the modem to hangup (terminate telnet session). All further output will be sent to console only.</ul> |  |
| MOVE | MOVE *start*, *length* TO *destination* | Not Yet Implemented | Move an area of member. | The <tt>MOVE</tt> statement is used to move segments of memory around. The only limitation is that only a maximum of 255 bytes can be moved at any one time. Both *start* and *destination* are 16 bit memory addresses while *length* is an 8 bit [0-255] number. |  |
| MSG | *expression*=MSG(*number*)<br>MSG(*number*)=*expression*<br>*device*={#MSG(*number*)} | Not Yet Implemented | Message database contents manipulation function. | The <tt>MSG</tt> function is a specialized function for the ACOS message handling routines. Once a message file has been opened via the <tt>READY</tt> command, the <tt>MSG</tt> function is used to access individual messages within the message file. The <tt>MSG</tt> function has two radically different syntaxs. Under the first and second syntax, it is being used to access and set information about a message. For each message, you can maintain one number that gives information about it via the <tt>MSG</tt> function. The <tt>MSG(0)</tt> function returns the number of messages within the message file and may not be changed. To access a message, it is used as a device channel. While to show the editor <tt>COPY #8</tt> would suffice, since the message file is made up of many messages, it is necessary to tell which message you want to work with. <tt>COPY #MSG(3)</tt> would show message number three within the currently open message file. |  |
| NEXT | NEXT | Not Yet Implemented | Perform next iteration of FOR loop. | For use with the <tt>FOR</tt> statement in FOR-NEXT loops. Unlike with AppleSoft or some other BASIC implementations, you cannot use a variable after NEXT. (NEXT X is illegal). |  |
| NIBBLE | NIBBLE=*memloc*<br>*numvar*=NIBBLE(*number*)<br>NIBBLE(*number*)=*number* | Not Yet Implemented | Nibble-level data manipulation function. | The <tt>NIBBLE</tt> function is similar to the <tt>FLAG</tt> function in that it is a low overhead data storage method. With the <tt>NIBBLE</tt> function, you can store 4 bit numbers that have the range 0-15. Use the first syntax of <tt>NIBBLE</tt> to point to the memory where the data will be stored. Use the second and third syntax to read and write the actual data. BJB TODO: Need to clarify the 3rd form. |  |
| NOT | *expression*= NOT *expression* | Not Yet Implemented | Boolean NOT operator. | The <tt>NOT</tt> operator is a boolean logic operator. It changes the value of an expression from true to false or from false to true. In booleon logic, false is considered to be zero while not false or true, is considered to be any other number. The <tt>NOT</tt> operator is most commonly used in <tt>IF</tt> statements. |  |
| ON NOCAR | ON NOCAR GOTO *label* | Not Yet Implemented | Session dropped / timeout handler. | The *ON NOCAR* statement is used to setup a routine that can be used when carrier is lost or otherwise the connection with a remote user is dropped. When the connection is lost, ACOS will then hang up the modem / terminate the connection. It will then change the current execution point to the label that was setup, i.e. a <tt>GOTO</tt> *label*. Whenever you link to another segment you must set up a new *ON NOCAR* vector to a routine within that segment. If you don't have a vector set up and a remote caller drops carrier, the system will just sit there until it times out. |  |
| OPEN | OPEN #*device*, *filename* | Not Yet Implemented | Open a file for I/O. | The <tt>OPEN</tt> statement is used to make disk files ready to do I/O with out a program. You open a disk file using either device channel 1 or 2, and all further references to that channel will access the file associated with it. When you are finished with the file, use the <tt>CLOSE</tt> command. This will free up the device channel for later use. If you try to use a channel that is already in use, or one besides channel 1 or 2, you will get a BAD DEVICE CHANNEL error. If the file you open does not exist, no error will be generated. If you try to read from the file, it will appear to be empty. Use the <tt>CREATE</tt> command to make a file. |  |
| PDL | *expression*=PDL(*number*) | Not Yet Implemented | Return the value of a paddle controller. | The <tt>PDL</tt> function is used to read one of the paddles on the system, specified by *number*. You can read paddle zero through three. The value returned will be in the range 0-255. |  |
| PEEK | *expression*=PEEK(*address*) | Not Yet Implemented | Return the value of specified memory location. | Returns the value of the byte located at *address*. REMY TODO: Does this work in A2osX? Perhaps limit it to $C000-CFFF? |  |
| POKE | POKE *address*, *value* | Not Yet Implemented | Set the value for a specified memory location. | Sets the value of the memory location specified at *address* with *value*. REMY TODO: Does this work in A2osX? Perhaps limit it to $C000-CFFF? |  |
| POP | POP | Not Yet Implemented | Remove the most recent address from the return stack. | Removes the last execution address from the stack, i.e. if a <tt>PUSH</tt> or <tt>GOSUB</tt> was called which put an execution address on the stack, the <tt>POP</tt> command can be used to remove it (and render that <tt>PUSH</tt> or <tt>GOSUB</tt> 'forgotten'). Works the same as the AppleSoft <tt>POP</tt> statement with the exception of it also can be used with the ACOS <tt>PUSH</tt> command. |  |
| POSITION | POSITION #*device,* *record_length,* *record_number* [,*offset*] | Not Yet Implemented | Set the file position offset for a device. | The <tt>POSITION</tt> statement is used to position within a random access file. The *device* argument is the disk device channel number that was used to open the file. The *record_length* argument is the length of each record. The *record_number* argument is the record number to be positioned to. The optional *offset* argument is the offset within the record that is to be positioned to. Note that there is no check to see if files actually conform to *record_length*; it along with the other *record_number* and *offset* arguments simply form a means of providing a calculation for a byte offset in the file as a while. For example, <code>POSITION #1, 1000, 3, 50</code> would result in seeking file device #1 to the 3050'th byte in the file. |  |
| PRINT | PRINT [#*device*,] [*expression*] [,*expression*] [;] | In Development | Output data to a device, session, or screen. | Sends/displays text or data to the screen, remote user, or specified device handler. There are a few rules for <tt>PRINT</tt>:<p><ul><li>control: '<tt>,</tt>' - the comma is used to separate expressions within the print statement and will be printed literally, i.e. this is for creating comma-separated file output.<li>control: '<tt>;</tt>' - the semi-colon is also used to separate expressions it will not be printed when encountered, if a semi-colon is the last character in the line, then the carriage return will be suppressed.<li>control: '<tt>\\</tt>' - the backslash is used to generate a newline character. Using the backslash, there is no need to put a bunch of <code>print:print...</code> statements.<li>exprs: TEXT  - text must be contained within quotes and will be printed exactly as typed. Within quotes, you may have any special characters including return. Note that you MUST close quotes on the same line - multi-line quotes are not allowed.<li>exprs: STRING- the contents of the listed string will be printed.<li>exprs: NUMBER- the content of the listed number will be printed.</ul> |  |
| PUBLIC | PUBLIC *label* | Not Yet Implemented | Declare a label to be accessible via the LINK command. | The <tt>PUBLIC</tt> statement is used to make a label within a program module available to other modules to <tt>LINK</tt> to. If you wish to link to another program module, and start execution at a point other than the beginning of the module, you will need to make that point public. You can have a maximum of 8 public labels within a program module. |  |
| PUSH | PUSH *label* | Not Yet Implemented | Push the current execution address to the return stack. | The <tt>PUSH</tt> statement is a subset of the <tt>GOSUB</tt> statement. It does not actually change the current point of execution, but places a return address on the stack so that the next time a <tt>RETURN</tt> statement is encountered, control will return to this present point. A <tt>POP</tt> statement will remove the last address added to the return table. |  |
| RAM | RAM | Not Yet Implemented | Keyword representing the primary 64-byte scratch RAM. | The <tt>RAM</tt> function is really just a constant pointer. It just points to a free 64 bytes of memory that has been set aside for program use. |  |
| RAM2 | RAM2 | Not Yet Implemented | Keyword representing the secondary 64-byte scratch RAM. | The <tt>RAM2</tt> function is the same as the <tt>RAM</tt> function except that it points to a different 64 bytes that are available for program use. Generally this memory is used in conjunction with the <tt>READ,</tt> <tt>WRITE,</tt> <tt>NIBBLE</tt>, and <tt>BYTE</tt> functions. |  |
| RANDOM | *expression*=RANDOM(*number*) | Not Yet Implemented | Returns a random number between 0 and specified number. | The <tt>RANDOM</tt> function is used to generate a random number within the range 0-*number*. It is important to note that the random number generator only runs when the system goes to get input. In other words, if you take two random numbers in a row without some kind of user input in the middle, the random numbers will always be the same. If you need more than one, use the <tt>RND$</tt> string between. The <tt>RND$</tt> string will cause the random number generator to re-random. REMY TODO: Is there an A2osX random number service that would be used instead? |  |
| READ | READ #*device*, *memloc*, *number* | Not Yet Implemented | Reads binary data. | The <tt>READ</tt> statement is used to load data from a file into memory in its binary form without any processing or changing. The input does not have to come from a file, it can come from the editor or a message file. It is similar to an Apple DOS BLOAD command. BJB TODO: Need to improve this to describe memloc, number. |  |
| READY | READY *filename*<br>READY #MSG(*number*) | Not Yet Implemented | Prepare a message database for use. | The <tt>READY</tt> statement is used to make a message file ready for use. It is similar to an <tt>OPEN</tt> statement being used before a file is accessed. After a message file is ready, all the following references to <tt>MSG</tt> will be directed to that file. Once a message file has been made ready, it can also be used in its second syntax to ready a specific message within the file. This is generally used if further references to the file will use the device channel associated with the message base. |  |
| RETURN | RETURN | In Development | Return from a subroutine. | Return from a subroutine. More specifically, it retrieves the last execution point off the stack and continues program execution from that point. Used in conjunction with <tt>GOSUB</tt> and <tt>PUSH</tt> statements. |  |
| REWIND | REWIND | Not Yet Implemented | Set file position to a previously set location. | The <tt>REWIND</tt> statement is to change the pointer within a message file to some previously accessed point within the file. Normally this is used in conjunction with the <code>READY MSG(x):COPY #7</code> statements. Using <tt>REWIND</tt> will put the internal pointer back to where it was before the last message operation took place. This is generally used for doing a 're-read' function of sorts. |  |
| RIGHT$ | *string*=RIGHT$(*source*, *length*) | Not Yet Implemented | Return a number of characters from the end of a string. | Returns the last *length* number of characters from the *source*. |  |
| RND$ | *char*=RND$ | Not Yet Implemented | Returns a random character. | The <tt>RND$</tt> function is used to generate random characters. Each time <tt>RND$</tt> is accessed a new random character will be returned. Be warned: the random number is generated from timing how long a user takes to enter his input. This is really a pretty random number since it is based on the users typing skill and speed. The only problem is that the random character generator can start repeating patterns after about 15-20 characters have been generated and before another input has taken place. REMY TODO: Is this how your implementation works or are you using an A2osX random generator? |  |
| SET | SET *string*=*memloc*, *number* | Not Yet Implemented | Sets a string to a location in memory. | The <tt>SET</tt> statement is another statement set up for the optimum management of memory. With <tt>SET</tt> you can manually set up pointers for strings anywhere in memory. Along with the locations of the string, you can also specify the length. Whenever the string is accessed, the text present at the memory locations will be returned. |  |
| SETINT | SETINT (*string1* [,*string1*...])<br>SETINT ("")<br>SETINT (*number*) | Not Yet Implemented | Sets the interrupt table with specified keys. | The <tt>SETINT</tt> command is used to set up 'interrupt' keys. Once setup the system will check for those keys whenever text is being displayed. If one of the keys are encountered, all further output will be suppressed until an input statement of some kind is encountered or the <tt>SETINT</tt> is reset. To reset the <tt>SETINT</tt> command, use the second syntax. If you wish to set the interrupt keys to those pre-defined by the ACOS config program, use the third syntax. <tt>SETINT(1)</tt> will set the interrupt key to the 'file stop' character. <tt>SETINT(2)</tt> will set the interrupt keys to the 'file stop' and 'file next' characters. |  |
| STR$ | *string*=STR$(*number*) | Not Yet Implemented | Returns string representation of a numerical expression. | Returns the numerical supplied numerical expression as a string. |  |
| TEXT | TEXT | Not Yet Implemented | Clear the screen and any window on the local console. | Used to clear the screen and any window on the local console. BJB REMY TODO: How is this different from HOME? |  |
| THEN | THEN | Not Yet Implemented | Statement separator for logical IF statements. | Separates statements within <tt>IF</tt> statements. |  |
| TIME$ | *string*=TIME$ | Not Yet Implemented | Returns the current TIME into a string. | The <tt>TIME$</tt> function is used to get the current time from your clock. If your system is equipped with a clock, the time will be returned in a "HH:MM:SS XM" format. If your clock is in the 24 hour configuration then it will be returned in the "HH:MM:SS" format. If you have no clock, then your estimated time on will be returned. The estimated time is based upon the number of characters output and the speed they were sent. The format for estimated time is "HH:MM:SS ET". When the clock is first reset via a <tt>MODEM(0)</tt> command, the time will be "00:00:00 ET" and will advance from there. REMY TODO: How is your implementation of no clocks? |  |
| TONE | TONE (*pitch*, *duration*) | Not Yet Implemented | Generates a tone on the local speaker. | The TONE function is used to generate a tone from the speaker in your computer. BJB TODO: Need to determine limits. |  |
| UPDATE | UPDATE | Not Yet Implemented | Flushes any cached data for the current message database. | The <tt>UPDATE</tt> statement is used to write any information about the current message base from memory out to disk (i.e. a flush operation). Normally, certain things are buffered and will stay within memory for long periods of time. In the event of a power failure or a system reset, this data will be lost before it is written out to disk. Use the <tt>UPDATE</tt> statement to force the data to be written out to disk. |  |
| USE | USE *filename* [,*any options*] | Not Yet Implemented | Call out to an external function. | The <tt>USE</tt> statement is used to access a routine that is external to the ACOS language. What happens is that the <tt>USE</tt> statement loads in an external command and transfer control to that command. The command will normally get parameters from the continuation of the line after the *filename* argument. REMY TODO: This is used for protocol handlers; have you implemented something for this? |  |
| VAL | *expression*=VAL(*string*) | Not Yet Implemented | Returns the numerical value of a string. | Returns the numerical value of a number spelled out in a string. |  |
| WHEN$ | WHEN\$=*address*<br>*string*=WHEN\$<br>WHEN\$=*string* | Not Yet Implemented |  | The <tt>WHEN$</tt> function is really just a data compression scheme. You initially point <tt>WHEN$</tt> to a address in memory. At this address there must be 2 free bytes. When you read from <tt>WHEN$,</tt> the 2 bytes will be retrieved from the memory location and translated into a "MM/DD/YY" format. When you assign <tt>WHEN$</tt> a value, the current date will be read and changed into a 2 byte compressed format and saved at the current address pointer. |  |
| WIDTH | *expression*=WIDTH(*number*) | Not Yet Implemented |  | The <tt>WIDTH</tt> function is really an interface to the config program. It will return 4 widths that were setup as the most commonly used widths under config, along with the width that should be used for a default when the video width is not known. <tt>WIDTH(1-4)</tt> will return the 4 most commonly used widths. <tt>WIDTH(0)</tt> will return the number of the width(1-4) that should be used as a default. |  |
| WRITE | WRITE #*device*, *memloc*, *number* | Not Yet Implemented | Writes binary data. | The <tt>WRITE</tt> statement is the opposite of the <tt>READ</tt> statement. It is used to write unprocessed binary data from memory to a file or other device. Almost all the device channels can be written and none will generate errors. Just specify the memory location and length to be written. BJB TODO: Need to expand on this for the arguments. |  |



## License
A2osX is licensed under the GNU General Pulic License |

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) | | any later version |

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details |

The full A2osX license can be found **[Here](../LICENSE)** |

## Copyright

Copyright 2015 - 2021, Remy Gibert and the A2osX contributors |
