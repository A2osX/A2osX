# AcosX Words

## Description

This document lists all of the **ACOS Words** supported in the A2osX implementation of **ACOS**.  Note that not all **Words** are implemented at this time, please check the *Status* and *Comment* Columns.  Currently only an interpreter is available (*../bin/bbsd*) | | though a compiler is planned |

## Words
| Word | Syntax | Status | Description | Comment |
|-|-|-|-|-|
| ADDINT | (string1 [,string2...]) | dev | The ADDINT command will add more keys to the existing interrupt keys table. previous keys will not be cleared. The functions of the keys is the same as with the SETINT command. |
| APPEND | #device | dev | The APPEND statement is generally used to add data to an existing file. If you issue an APPEND statement, the file pointer will be moved to the end of the file. You can also find out the length of a file by doing an APPEND and then using the MARK function. Mark will then return the length of the file in bytes. |
| BYTE | byte=number<br>byte=(number)<br>byte=(number)=number256 | dev | The BYTE function is similar to the FLAG function. It is a low overhead data storage unit. Just point to where in memory you want the data to be stored using the first syntax, and you can then access the data using the second or third syntax's. |
| CHR$ | string=CHR$(ascii code [,number chars]) | dev | Returns a string with the character represented by the ascii code. If extra numchars is specified, then returned string will contain that many repetitions of the character instead of just one. |
| CLEAR | clear<br>clear #device | dev | The forms to clears share only one thing in common; they both clear data in one form or another. In the first syntax (without an argument), CLEAR will reset all the variables to nil, clear all the addresses from the for-next and gosub-return stack, and close all open files. Suggested use is at beginning of program.<p>In its second syntax, CLEAR is used to clear out device buffers. The legal device channels are 8, 9, 10. CLEAR #8 will clear the editor so that any output into the editor will be appended to a clear editor. CLEAR #9 will clear the top of screen display. You must clear the top of screen display before you write any info into it. CLEAR #10 will clear the ram drive. any further writes will be appended on to the end. |
| CLOCK | CLOCK(0)<br>CLOCK(1)=expression<br>expression=CLOCK(2) | dev | The CLOCK function/statement is used for setting a time limit. It can also be used to find out how long someone has been using the system (i.e. how long since CLOCK(0) was called). The following options are available:<p><ul><li><tt>CLOCK(0)</tt>- This statement is used to reset the clock time to zero. It should be executed when your program begins.<li><tt>CLOCK(1)</tt>- You will need to set CLOCK(1) equal to the number of minutes you want as a time limit, or 0 for no limit. when the time limit expires, it will be handled as a "no carrier" situation. The program will jump to the NOCAR routine.<br><li><tt>CLOCK(2)</tt>- The CLOCK(2) function will return the number of seconds that a user has been connected. divide this number by 60 to find how many minutes they have been connected.</ul> |
| CLOSE | CLOSE<br>CLOSE #device | dev | The CLOSE command is used to close a disk file after you are done with it. If you give a device channel with the close command, only that file will be closed. If you CLOSE with no arguments, all open files will be closed. |
| COPY | COPY filename [,#device]<br>COPY #device [,#device] | dev | The COPY command is used for displaying and copying information from device to device. The first argument can be a filename, in which case, the file is opened and input is taken from that file, or it can be a device. The second device is optional. If present all output will be routed there, otherwise it will be displayed to the modem/console. The second argument may not be another filename. If you wish to copy to a file, open the file with the OPEN command, and copy to that device. |
| CREATE | CREATE filename | dev | The CREATE statement is used to create an empty file on the disk. The new file can be opened and read and written to just as any other file would be. If you want to create a new file, you must use the CREATE statement first unlike some other languages which will create files by simply using the OPEN command on a file that does not already exist. If the file already exists, the file will not be touched in any way. |
| CRUNCH | CRUNCH | dev | the CRUNCH statement is used in conjunction with the MSG commands. it is used to "CRUNCH" together a message file in while messages have been killed. this allows you to maintain a sequential message file and get rid of all the blank deleted entries that might be there. |
| DATE$ | string=DATE$ | dev | the DATE$ function returns the current date in MM/DD/YY format. the input will be taken from whatever device was configured as a clock. if 00/00/00 is returned, then there is no clock in the system and the date hasn't been set. |
| ECHO | ECHO=string1 | dev |          ECHO=""<br>the ECHO statement is used to set the echo character to be used with the INPUT statement. once the echo has been set, that character will be sent each time a user types a character when entering text. the ECHO statement in the second syntax will reset the echo to the character that is being typed. |
| EDIT | EDIT(number) | dev | the EDIT statement is the command used to interface acos with its editor. with the different EDIT statements, you can clear the editor, see how much space is free, etc. the following list gives all legal calls....<p><ul><li>EDIT(0)- clears the editor. there will be a total of 4096 bytes free after a clear takes place.<br><li>EDIT(1)- enter the editor. if no data is present, the editor will start to accept input right away. if other data is present, the editor will start in the prompt mode.<br><li>EDIT(2)- this is a function that returns the number of bytes used within the editor. if this number equals 0 the editor is empty.<br><li>EDIT(3)- this is used to set the video width to be used within the editor. any value from 1 to 255 is legal. the most often used widths are 32,40,64,80,128. all operations within the editor will be based around this width. you can also read the current width using EDIT(3) as a function.<br><li>EDIT(4)- this is used to set the 'back-space mode' that the editor will use. certain modes allow more control than others. mode 0 indicates that the actual mode is not known. the editor will work fine, but some functions will be disabled. under mode 1, the editor will assume that the user has a 'non-destructible' backspace. this allows all the editor functions to be used and is how the local console                  is setup. mode 2 tells the editor that the user has a                  'destructible' backspace. under this mode, some functions                  are disabled, but the editor speeds up certain other                  functions. |
| END | END | dev | same as applesoft, terminates program. returns to acos restart state. |
| FILL | FILL start,length,data | dev | the FILL statement is used to fill an area of memory with some bytes of data. generally it is used to zero out memory. START is a 16 bit memory address, length is an 8 bit [0-255] number, and DATA is the byte that will be used to fill memory. |
| FLAG | expression=FLAG | dev |          FLAG=number         FLAG=(number)         FLAG(number)=number1<br>the FLAG function is a low overhead way to store 1 bit information. you just need to point the FLAG function to a point in memory that you wish to store your data in, and you can manipulate as many flags as you need. each byte of memory can contain 8 flags. to setup the FLAG function, use the first syntax to point the function to a point in memory where the flags will be stored. once the pointer is setup, you can use the FLAG just like a variable using the second and third syntax for reading and writing the flags. |
| FOR | FOR numvar=number TO number STEP number | dev |            ; NEXT<br>appears to have same function and limits as applesoft FOR-NEXT loops. |
| FREE | FREE | dev | appears to have same function as applesoft FRE(0) command. |
| GET | GET varstr | dev | the GET statement is used to get a single keypress from the keyboard. when encountered, the system will wait until a key is pressed. the key will be returned in <varstr>. control characters will not be filtered out as they are with INPUT. |
| GOSUB | GOSUB label | dev | appears to have same function as applesoft GOSUB. only thing worth noting is that acos uses labels as targets instead of line numbers. |
| GOTO | GOTO label | dev | appears to have same function as applesoft GOTO, again with the exception that acos uses labels not line numbers. |
| HOME | HOME | dev | appears to have same function as applesoft HOME. clears current window. |
| IF | IF argument [THEN] statement [ELSE] statement | dev | appears to have same function as applesoft IF-THEN except it supports the ELSE directive when the statement was false. ELSE is optional. THEN is also optional but if you use THEN, it cannot be followed by a label directly.(use IF arg THEN GOTO label). |
| INFO | expression=INFO(optional) | dev |          INFO(optional)=expression<br>INFO can be used as either a statement or as a function. it is really a 'catch-all' in nature. many values that are more or less unrelated are returned. the following table gives the meanings of all the INFO data.<br>argument r/w       function-------- ---       -----------------INFO(0)  r         is there a caller online? (0=no)INFO(1)  r         capacity of current message file.INFO(2)  r         callers baud rate /300  (1=300)INFO(3)  r/w       current number of nulls.INFO(4)  w         top screen stats.  (1=chat, 2=exec)INFO(5)  r/w       executive user online?  (1=yes)INFO(6)  r         checks bit map for mail/msg bases for room. |
| INPUT | INPUT [#device,]  [@number,]  [\]  ["text"] | dev |                variable [{,\}] variable..]<br>the INPUT statement is broken down into 4 different parts. the first part is the input device to be used. when omitted, the input is taken from the modem/console, otherwise input is taken from that device. the second part is the input mode. there is a restrictive mode placed on the input so that the inputed data is what you desire. the third part of INPUT is the prompt. the prompt is basically just a text string that will be printed prior to getting the input. the newline character '\' can be used at the beginning of the text. the last part of INPUT is the variable list. this is a list of variables that will be assigned the input. each variable in the list is separated by either a comma or backslash. if separated by a comma, then the actual typed input must be divided by a comma. if divided by a backslash, then the text must be separated by a carriage return.<br>         INPUT default- set the input mode to uppercase, don't accept a                        blank line.<br>         INPUT mode 0 - set the input mode to uppercase, don't accept a                        blank line, just return the first character.<br>         INPUT mode 1 - set the input mode to uppercase, don't accept a                        blank line, don't accept any commas.<br>         INPUT mode 2 - set the input mode to uppercase, blank lines will                        be accepted.<br>         INPUT mode 3 - accept everything. (upper & lower). |
| INSTR | expression=INSTR(string,string) | dev | the INSTR function is used to search within a string for the existance of another string. the first string is that string which you are searching for. the second string is what will be searched. the case of the text will be ignored. the function will return the number of the first character where the match was found. if the function returns zero, no match was found. |
| KEY | expression=KEY(0) | dev |          expression=KEY(1)         expression=KEY(2)<br>the KEY function is used to check and see what if any keys have been pressed. it is generally used to check to see if a routine needs to be interrupted and is used in conjuction with the SETINT and ADDINT statements. this routine does not wait for a key, it returns either a zero for no key or the ascii value of the key. in the KEY(1) form, a non-zero byte will be returned if the key pressed was the 'file stop' character. in the KEY(2) form, a non-zero byte will be returned if the pressed key is the 'file next' key define in config. |
| KILL | KILL filename | dev |          KILL #MSG(expression)<br>the KILL statement can be used in two different ways. in both ways it is used to delete data. in the first form, with the filename, it will delete the file from disk. in its second form, it will kill a message within the currently active message base. after using KILL on a message, it is always a good idea to follow it with an UPDATE. |
| LEFT$ | string=LEFT$(string,length) | dev | appears to have same function as applesoft LEFT$. |
| LEN | expression=LEN(string) | dev | appears to have same function as applesoft LEN. |
| LINK | LINK filename [,string-label] | dev | this statement will allow two program segments to be linked together. it is in this way that the problem of not enough memory is dealt with. the filename argument is mandatory and is in standard filename syntax. if you wish the execution to begin at a point other than the beginning of the module, then add on a comma followed by the name of the label IN STRING FORM. the label must be enclosed in quotes or must be in a string. ex: LINK "A:MSG.SEG","BULLETINS". you must also make use the PUBLIC command within the segment you are linking to so that the labels address is available to the link command. |
| LOG | LOG drivespec | dev | the LOG statement simply changes the default disk drive to the <drivespec> drive. if the drive is not legal, a BAD DRIVE SPECIFIER error will occur. |
| MARK | expression=MARK(device) | dev |          MARK(device)=number<br>the MARK function will allow you to either set or check the point at which a file is doing i/o. if you want to go to the beginning of a file, you would issue a MARK(1)=0 assuming it was file 1. MARK has a second function in that it can be used to see if a file exists. normally acos will not generate an error if a file exists, so it can be hard to tell if there is one. to see if a file exists:                   OPEN #1,filename                   IF MARK(1) PRINT "FILE EXISTS"                   CLOSE #1 |
| MID$ | string=MID$(string,start [,length]) | dev | appears to have same function as applesoft MID$. |
| MODEM | MODEM(number) | dev | the MODEM command is multiple function for controlling the modem.<br>                   MODEM(0)- this command needs to be issued before any other                             modem command is used. its function is to                             initialize the modem driver for later use.<br>                   MODEM(1)- this command waits for an incoming call and                             establishes a connection. execution will continue                             when either a call is connected or the user goes                             into local mode.<br>                   MODEM(2)- this command causes the modem to hangup. all                             further output will be sent to console only. |
| MOVE | MOVE start,length TO destination | dev | the MOVE statement is used to move segments of memory around. the only limitation is that only a maximum of 255 bytes can be moved at any one time. both START and DESTINATION are 16 bit memory addresses while LENGTH is an 8 bit [0-255] number. |
| MSG | expression=MSG(number) | dev |          MSG(number)=expression         device={#MSG(number)}<br>the MSG function is a specialized function for the acos message handling routines. once a message file has been opened via the READY command, the MSG function is used to access individual messages within the message file. the MSG function has two radically different syntaxs. under the first and second syntax, it is being used to access and set information about a message. for each message, you can maintain one number that gives information about it via the MSG function. the MSG(0) function returns the number of messages within the message file and may not be changed. to access a message, it is used as a device channel. while to show the editor COPY#8 would suffice, since the message file is made up of many messages, it is necessary to tell which message you want to work with. COPY#MSG(3) would show message number three within the currently open message file. |
| NEXT | NEXT | dev | similar to the applesoft NEXT statement which is used with FOR-NEXT loops but with the exception you cannot use a variable after NEXT. (NEXT X is illegal). |
| NIBBLE | NIBBLE=number | dev |          NIBBLE(number)         NIBBLE(number)=number16<br>the NEXT function is similar to the FLAG function in that it is a low overhead data storage method. with the NIBBLE function, you can store 4 bit numbers that have the range 0-15. use the first syntax of NIBBLE to point to the point in memory where the data will be stored. use the second and third syntax to read and write the actual data. |
| NOT | expression= NOT expression | dev | the NOT operator is a booleon logic operator. it changes the value of an expression from true to false or from false to true. in booleon logic, false is considered to be zero while not false or true, is considered to be any other number. the NOT operator is most commonly used in IF statements. |
| ON NOCAR | ON NOCAR GOTO label | dev | the ON NOCAR statement is used to setup a routine that can be used whne carrier is lost from a remote user. when the carrier is lost, acos will then hang up the modem. it will then change the current execution point to the label that was setup. whenever you link to another segment you must set up a new ON NOCAR vector to a routine within that segment. if you don't have a vector set up and a remote caller drops carrier, the system will just sit there until it times out. |
| OPEN | OPEN #device,filename | dev | the OPEN statement is used to make disk files ready to do i/o with out a program. you open a disk file using either device channel 1 or 2, and all further references to that channel will access the file associated with it. when you are finished with the file, use the CLOSE command. this will free up the device channel for later use. if you try to use a channel that is already in use, or one besides channel 1 or 2, you will get a BAD DEVICE CHANNEL error. if the file you open does not exist, no error will be generated. if you try to read from the file, it will appear to be empty. use the CREATE command to make a file. |
| PDL | expression=PDL(number) | dev | the PDL function is used to read one of the paddles on the system. you can read paddle zero through three. the number returned will be in the range 0-255. |
| PEEK | expression=PEEK(address) | dev | appears to be the same as the applesoft PEEK function. |
| POKE | POKE address,value | dev | appears to be the same as the applesoft PEEK function. |
| POP | POP | dev | appears to be the same as the applesoft POP statement with the exception of it also can be used with the acos PUSH command. |
| POSITION | POSITION #device,number,number [,number] | dev | the POSITION statement is used to position within a random access file. the first argument is the disk device channel number that was used to open the file. the second field is the length of each record. the third field is the record number to be positioned to. the fourth field is the offset with in the record that is to be positioned to. |
| PRINT | PRINT [#device,] [expression] | dev |                [,expression] [;]<br>rules for PRINT:<br>         control: ',' - the comma is used to separate expressions within the                        print statement and will be printed literally.<br>         control: ';' - the semi-colon is also used to separate expressions                        it will not be printed when encountered, if a semi-                        colon is the last character in the line, then the                        carriage return will be suppressed.<br>         control: '\' - the backslash is used to generate a newline character                         using the backslash, there is no need to put a bunch                         of print:print... statements.<br>         exprs: TEXT  - text must be contained within quotes and will be                        printed exactly as typed. within quotes, you may have                        any special characters including return. having an                        open quote with no close can prove to be an                        interesting experience.<br>         exprs: STRING- the contents of the listed string will be printed.<br>         exprs: NUMBER- the content of the listed number will be printed. |
| PUBLIC | PUBLIC label | dev | the PUBLIC statement is used to make a label within a program module available to other modules to link to. if you wish to link to another program module, and start execution at a point other than the beginning of the module, you will need to make that point public. you can have a maximum of 8 public labels within a program module. |
| PUSH | PUSH label | dev | the PUSH statement is a sub-set of the GOSUB statement. it does not actually change the current point of execution, but places a return address in a table so that the next time a RETURN statement is encountered, control will return to this present point. a POP statement will remove the last address added to the return table. |
| RAM | RAM | dev | the RAM function is really just a constant pointer. it just points to a free 64 bytes of memory that has been set aside for program use. |
| RAM2 | RAM2 | dev | the RAM2 function is the same as the RAM function except that it points to a different 64 bytes that are available for program use. generally this memory is used in conjunction with the READ, WRITE, NIBBLE and BYTE functions. |
| RANDOM | expression=RANDOM(number) | dev | the RANDOM function is used to generate a random number within the range 0-number. a new random number will be generated everytime the system goes to get input. if you take two random numbers in a row, they will always be the same. if you need more than one, use the RND$ string between. the will do a temporary re-random. |
| READ | READ # device,memloc,number | dev | the READ statement is used to load data from a file into memory in its binary form without any processing or changing. the input does not have to come from a file, it can come from the editor or a message file. it is similar to an apple dos BLOAD command. |
| READY | READY filename | dev |          READY #MSG(number)<br>the READY statement is used to make a message file ready for use. it is similar to an OPEN statement being used before a file is accessed. after a message file is ready, all the following references to MSG will be directed to that file. once a message file has been made ready, it can also be used in its second syntax to ready a specific message within the file.this is generally used if further references to the file will use the device channel associated with the message base. |
| RETURN | RETURN | dev | appears to have same function as the applesoft RETURN statement. |
| REWIND | REWIND | dev | the REWIND statement is to change the pointer within a message file to some previously accessed point within the file. normally this is used in conjunction with the READY MSG(x):COPY #7 statements. using REWIND will put the internal pointer back to where it was before the last message operation took place. this is generally used for doing a 're-read' function of sorts. |
| RIGHT$ | string=RIGHT$(string,length) | dev | appears to have same function as the applesoft RIGHT$. |
| RND$ | char=RND$ | dev | the RND$ function is used to generate  random characters. each time RND$ is accessed a new random character will be returned. be warned: the random number is generated from timing how long a user takes to enter his input. this is really a pretty random number since it is based on the users typing skill and speed. the only problem is that the random character generator can start repeating patterns after about 15-20 characters have been generated and before another input has taken place. |
| SET | SET string=memloc,number | dev | the SET statement is another statement set up for the optimum management of memory. with SET you can manually set up pointers for strings anywhere in memory. along with the locations of the string, you can also specify the length. whenever the string is accessed, the text present at the memory locations will be returned. |
| SETINT | SETINT (string1 [,string1...]) | dev |          SETINT ("")         SETINT (number)<br>the SETINT command is used to set up 'interrupt' keys. once setup the system will check for those keys whenever text is being displayed. if one of the keys are encountered, all further output will be supressed until an input statement of some kind is encountered or the SETINT is reset. to reset the SETINT command, use the second syntax. if you wish to set the interrupt keys to those pre-defined by the acos config program, use the third syntax. SETINT(1) will set the interrupt key to the 'file stop' character. SETINT(2) will set the interrupt keys to the 'file stop' and 'file next' characters. |
| STR$ | string=STR$(number) | dev | appears to have same function as the applesoft STR$. |
| TEXT | TEXT | dev | used to clear the screen and any window on the local console. |
| THEN | THEN | dev | same as applesoft THEN, separates statements within IF statements. |
| TIME$ | string=TIME$ | dev | the TIME$ function is used to get the current time from your clock. if your system is equipped with a clock, the time will be returned in a "HH:MM:SS XM" format. if your clock is in the 24 hour configuration then it will be returned in the "HH:MM:SS" format. if you have no clock, then your estimated time on will be returned. the estimated time is based upon the number of characters output and the speed they were sent. the format for estimated time is "HH:MM:SS ET". when the clock is first reset via a MODEM(0) command, the time will be "00:00:00 ET" and will advance from there. |
| TONE | TONE (number,number) | dev | the TONE function is used to generate a tone from the speaker in your computer. the first argument is the pitch and the second is the duration. |
| UPDATE | UPDATE | dev | the UPDATE statement is used to write any information about the current message base from memory out to disk. normally, certain things are buffered and will stay within memory for long periods of time. in the event of a power failure or a system reset, this data will be lost before it is written out to disk. use the UPDATE statement to force the data to be written out to disk. |
| USE | USE filename [,any options] | dev | the USE statement is used to access a routine that is external to the acos language. what happens is that the USE statement loads in an external command and transfer control to that command. the command will normally get parameters from the continuation of the line after the filename argument. |
| VAL | expression=VAL(string) | dev | appears to have same function as applesoft VAL. |
| WHEN$ | WHEN$=address | dev |          string=WHEN$         WHEN$=string<br>the WHEN$ function is really just a data compression scheme. you initially point WHEN$ to a address in memory. at this address there must be 2 free bytes. when you read from WHEN$, the 2 bytes will be retrieved from the memory location and translated into a "MM/DD/YY" format. when you assign WHEN$ a value, the current date will be read and changed into a 2 byte compressed format and saved at the current address pointer. |
| WIDTH | expression=WIDTH(number) | dev | the WIDTH function is really an interface to the config program. it will return 4 widths that were setup as the most commonly used widths under config, along with the width that should be used for a default when the video width is not known. WIDTH(1-4) will return the 4 most commonly used widths. WIDTH(0) will return the number of the width(1-4) that should be used as a default. |
| WRITE | WRITE #device,memloc,number | dev | the WRITE statement is the opposite of the READ statement. it is used to write unprocessed binary data from memory to a file or other device. almost all the device channels can be written and none will generate errors. just specify the memory location and length to be written. |




## License
A2osX is licensed under the GNU General Pulic License |

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) | | any later version |

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details |

The full A2osX license can be found **[Here](../LICENSE)** |

## Copyright

Copyright 2015 - 2021, Remy Gibert and the A2osX contributors |
