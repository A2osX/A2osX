*** Auto generated by docgen.cmd ***  

## Copyright 
Copyright 2015 - 2020, Remy Gibert and the A2osX contributors. 

# ARP.Clear  
 Clear ARP Cache  
**In:**   

## RETURN VALUE   

# ARP.Query  
 Query ARP Cache and returns HW address  
**In:**  
 PUSHW PTR to MAC (to fill)  
 PUSHW PTR to IP  

## RETURN VALUE  
 CC: hit: MAC filled  
 CS: missed   

# ARP.Add  
 Add a static ARP cache record  
**In:**  
 PUSHW PTR to MAC  
 PUSHW PTR to IP  

# ARP.GetCache  
 Return a Ptr to ARP Cache Table  
**In:**  

## RETURN VALUE  
  Y,A = PTR to ARP.CACHE  

# DNS.Clear  
 Clear DNS Cache  
**In:**   

## RETURN VALUE   

# DNS.Query  
 Query DNS for specified host  
**In:**  
  PUSHW = PTR to IP to fill with cached data  
*	PUSHW = hostname PTR to PSTR   

## RETURN VALUE  
  CC: hit: IP filled with address  
  CS: missed   

# DNS.Add  
 Add a static DNS record  
**In:**  
 PUSHW = PTR to IP  
 PUSHW = hostname CSTR to Add  

# DNS.GetCAche  
 Return a Ptr to DNS Cache Table  
**In:**  

## RETURN VALUE  
  Y,A = PTR to DNS.CACHE  

# Socket  
Create a new socket  

## C  
`hFD socket(short int type, short int protocol);`  

## ASM  
**In:**  
`>PUSHB protocol`  
`lda type`  
`>LIBCALL hLIBTCPIP,LIBTCPIP.socket`  

## RETURN VALUE  
CC: A = hSOCKET  
CS: A = EC  

# Bind  
bind a name to a socket  

## C  
`int bind(hFD fd, const struct sockaddr *addr);`  

## ASM  
**In:**  
`>PUSHW addr`  
`lda fd`  
`>LIBCALL hLIBTCPIP,LIBTCPIP.socket`  

## RETURN VALUE  
CC: A = hSOCKET  
CS: A = EC  

# Connect  
Initiate a connection on a socket  

## C  
`int connect(hFD fd, const struct sockaddr *addr);`  

## ASM  
**In:**  
`>PUSHW addr`  
`lda fd`  
`>LIBCALL hLIBTCPIP,LIBTCPIP.socket`  

## RETURN VALUE  
CC: A = hSOCKET  
CS: A = EC  

# Listen  
Listen for connections on a socket  

## C  
`int listen(hFD fd);`  

## ASM  
**In:**  
`lda fd`  
`>LIBCALL hLIBTCPIP,LIBTCPIP.listen`  

## RETURN VALUE  
CS: A = EC  

# Accept  
Accept a connection on a socket  

## C  
`hFD Accept(hFD fd);`  

## ASM  
**In:**   
`lda fd`  
`>LIBCALL hLIBTCPIP,LIBTCPIP.accept`  

## RETURN VALUE   
A = hSocket  

# Shutdown  
Close socket  

## C  
`int shutdown(int fd);`  

## ASM  
**In:**  
`lda fd`  
`>LIBCALL hLIBTCPIP,LIBTCPIP.shutdown`  

## RETURN VALUE  

# Read (STREAM)  

## C  
`int skt.read(hFD fd, void *buf, int count);`  

## ASM  
**In:**  
`>PUSHWI count`  
`>PUSHW buf`  
`lda fd`  
`>LIBCALL hLIBTCPIP,LIBTCPIP.read`  

## RETURN VALUE  
CC: Y,A = bytes read  
CS: A = EC  

# Write (STREAM)  

## C  
`int skt.write(hFD fd, const void *buf, int count);`  

## ASM  
**In:**  
`>PUSHWI count`  
`>PUSHW buf`  
`lda fd`  
`>LIBCALL hLIBTCPIP,LIBTCPIP.write`  

## RETURN VALUE  
CC: Y,A = bytes written  
CS: A = EC  

# Recv (RAW,DGRAM,SEQPACKET)  

# RecvFrom (RAW,DGRAM,SEQPACKET)  

## C  
`hMem recv(hFD fd);`  
`hMem recvfrom(hFD fd, struct sockaddr *addr);`  

## ASM  
**In:**  
`>PUSHW addr`		(RecvFrom)  
`lda fd`  
`>LIBCALL hLIBTCPIP,LIBTCPIP.Recv`  

## RETURN VALUE  
CC: A = hMem  
CS: A = EC  

# Send (RAW,DGRAM,SEQPACKET)  

# SendTo (RAW,DGRAM,SEQPACKET)  

## C  
`int skt.send(hFD fd, const void *buf, int count);`  
`int skt.sendto(hFD fd, const void *buf, int count, const struct sockaddr *addr);`  

## ASM  
**In:**  
`>PUSHW addr`		(SendTo)  
`>PUSHWI count`  
`>PUSHW buf`  
`lda fd`  
`>LIBCALL hLIBTCPIP,LIBTCPIP.send`  

## RETURN VALUE  
CC: Y,A = bytes written  
CS: A = EC  

# GetSockOpt  
Set Socket Options  

## C  
`int getsockopt(hFD fd);`  

## ASM  
**In:**  
`lda fd`  
`>LIBCALL hLIBTCPIP,LIBTCPIP.GetSockOpt`  

## RETURN VALUE  

# SetSockOpt  
Set Socket Options  

## C  
`int setsockopt(hFD fd, short int opts);`  

## ASM  
**In:**  
`>PUSHBI opts`  
`lda fd`  
`>LIBCALL hLIBTCPIP,LIBTCPIP.SetSockOpt`  

## RETURN VALUE  

# EOF  
End Of File  

## C  
`int eof(hFD fd);`  

## ASM  
**In:**  
`lda fd`  
`>LIBCALL hLIBTCPIP,LIBTCPIP.EOF`  

## RETURN VALUE  
CC : A = 0 if some data, A = $ff if EOF  
CS : A = Socket Error  

# GetTable  
Get socket table  

## C  
`void * gettable();`  

## ASM  
**In:**  
`>LIBCALL hLIBTCPIP,LIBTCPIP.GetTable`  

## RETURN VALUE  

## License
A2osX is licensed under the GNU General Public License.

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

The full A2osX license can be found **[Here](../LICENSE)**.

*** End of Auto generated file ***  
