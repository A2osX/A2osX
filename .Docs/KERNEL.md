*** Auto generated by docgen.cmd ***  

## Copyright 
Copyright 2015 - 2020, Remy Gibert and the A2osX contributors. 

# Shift  

## ASM  
A = argument index.  

## RETURN VALUE  
CC : success  
Y,A = PTR To Arg[A]  
CS : Out Of Bound  

# ArgV  

## ASM  
A = argument index.  

## RETURN VALUE  
CC : success  
Y,A = PTR To Arg[A]  
CS : Out Of Bound  

# Arg2ArgV  
Expand String and convert to StrV List  

## C  
short int arg2argv(char* args, char* argv[])  

## ASM  
`>PUSHW args`  
`>PUSHW argv`  
`>LIBC Arg2ArgV`  

## RETURN VALUE  
A = Arg count  

# LoadDrv  

## ASM  
 Y,A = PTR to "NAME.DRV [PARAM]" C-String  

## RETURN VALUE  
none  

# InsDrv  

## ASM  
`>PUSHW src  
`>PUSHW drvcsstart  
`>PUSHW drvcsend  
`>PUSHW drvidend  
`>LIBC insdrv`  

## RETURN VALUE  
Y,A = Ptr to installed driver  

# GetDevByName  
 Y,A = Ptr to device name (C-String)  

## RETURN VALUE  
CC = OK, CS = ERROR  
A = hFD  

# MkFD  

## C  
`short int mkfd(short int type);`  

## ASM  
`>PUSHB DevID`  
`>LIBC MKFD`  

## RETURN VALUE  
A = hFD  

# MKDev  
Create a CDEV or BDEV  

## C  
`int mkdev (S.FD *fd, const char *devname)`  

## ASM  
`>PUSHW fd`  
`>PUSHW devname`  
`>LIBC mkdev`  

## RETURN VALUE  
 A = hDEV  

# IOCTL  

## C  
`int ioctl(int fd, short int request, void *param);`  

## ASM  
`>SS`  
`>PUSHW fd`  
`>PUSHB request`  
`>PUSHW param`  
`>LIBC IOCTL`  
`>SR`  

## RETURN VALUE  
 Y,A = ...  

# OpenDir  

## C  
`#include <dirent.h>`  
`DIR *opendir(const char *name);`  

## ASM  
`>LDYA name`  
`>LIBC opendir`  

## RETURN VALUE  
 CC : success  
  Y,A = pDIR  
 CS : error  
  A = EC  

# ReadDir  

## C  
`#include <dirent.h>`  
`struct dirent *readdir(DIR *dirp);`  

## ASM  
`>LDYA dirp`  
`>LIBC readdir`  

## RETURN VALUE  
 CC : success  
  Y,A = pDIRENT  
 CS : error  
  A = EC  
  note : A = 0 means no more entry  

# CloseDir  

## C  
`#include <dirent.h>`  
`int closedir(DIR *dirp);`  

## ASM  
`>LDYA dirp`  
`>LIBC closedir`  

## RETURN VALUE  
 none, always succeed.  

# PutEnv  
Change or add an environment variable, string is 'NAME=VALUE'  

## C / CSH  
`#include <stdlib.h>`  
`int putenv(char *string);`  

## ASM  
`>LDYA string`  
`>LIBC putenv`  

## RETURN VALUE  
 CC, Y,A = 0  
 CS, Y,A = -1, ERRNO  

# SetEnv  
Change or add an environment variable  

## C / CSH  
`#include <stdlib.h>`  
`int setenv(const char *envname, const char *envval, int overwrite);`  

## ASM  
`>PUSHW envname`  
`>PUSHW envval`  
`>PUSHW overwrite`  
`>LIBC setenv`  

## RETURN VALUE  
 CC, Y,A = 0  
 CS, Y,A = -1, ERRNO  

# GetEnv  
searches the environment list to find the environment variable name,  
and returns a pointer to the corresponding value string.  

## C / CSH  
`#include <stdlib.h>`  
`char *getenv(const char *name);`  

## ASM  
`>LDYA name`  
`>LIBC getenv`  

## RETURN VALUE  
 CC : Y,A = PTR to VALUE (C-String)  
 CS : Y,A = NULL  

# UnsetEnv  
Remove an environment variable  

## C / CSH  
`#include <stdlib.h>`  
`int unsetenv(const char *name);`  

## ASM  
`>LDYA name`  
`>LIBC unsetenv`  

## RETURN VALUE  
 CC, Y,A = 0  
 CS, Y,A = -1, X=ERRNO  

# GetErrMsg  
Get error description for this errcode  

## C / CSH  
`int geterrmsg(short int errcode, char *buf);`  

## ASM  
`>PUSHB errcode`  
`>PUSHW buf`  
`>LIBC GetErrMsg`  

## RETURN VALUE  

# FAdd,FSub,FMul,FDiv,FMod  
Return X*Y, X/Y, X+Y, X-Y  

## ASM  
`>PUSHF X (float)`  
`>PUSHF Y (float)`  
`>FPU fmul`  
`>FPU fdiv`  
`>FPU fmod`							TODO  
`>FPU fadd`  
`>FPU fsub`  

## RETURN VALUE  
 On stack (float)  

# float  
Return 'floated' long  

## C  
`float f = (float)l;  

## ASM  
`>PUSHL l` (long)  
`>FPU float`  

## RETURN VALUE  
 On stack (float)  

# Add32,Sub32,Mul32,IMul32,Div32,IDiv32,Mod32,IMod32,Cmp32,ICmp32  
Return X+Y, X-Y, X*Y, X/Y, X mod Y....  

## ASM  
`>PUSHL X (long)`  
`>PUSHL Y (long)`  
`>FPU add32`  
`...`  

## RETURN VALUE  
 On stack (long)  

# GetMemStat  
 Y,A = Ptr to 24 bytes buffer  

## RETURN VALUE  
 Buffer filled with memory stats  

# lrintf  
Return float rounded into a long  

## C  
`#include <math.h>`  
`long int lrintf (float x);`  

## ASM  
`>SL`  
`>SS`  
`>PUSHF x`  
`>LIBC lrintf`  
`>SR`  

## RETURN VALUE  
 On stack (long)  

# Logf,sqrtf,Expf,Cosf,Sinf,Tanf,ATanf  
Return Log(x), Sqr(x), E^X, Cos(x), Sin(X), Tan(x), ATan(x)  

## C  
`#include <math.h>`  
`float logf ( float x);`  
`float sqrtf ( float x);`  
`float expf ( float x);`  
`float cosf ( float x);`  
`float sinf ( float x);`  
`float tanf ( float x);`  
`float atanf ( float x);`  

## ASM  
`>SF`  
`>SS`  
`>PUSHF x (Float)`  
`>LIBC logf`  
`>SR`  

## RETURN VALUE  
 On stack (Float)  

# powf  
Return the value of x raised to the power y  

## C  
`#include <math.h>`  
`float powf(float x, float y);`  

## ASM  
`>SF`  
`>SS`  
`>PUSHF x`  
`>PUSHF y`  
`>LIBC powf`  
`>SR`  

## RETURN VALUE  
 On stack (float)  

## MD5  
Return MD5 Hash for input String  

# C  
`void md5 (const char* str, char* digest);`  

# ASM  
`>PUSHW str`  
`>PUSHW digest`  
`>LIBC md5`  

## RETURN VALUE  
CC  

## MD5Init  
Initialize a MD5 computation  

# C  
`void *md5init();`  

# ASM  
`>LIBC MD5Init`  

## RETURN VALUE  
Y,A = pMD5  

## MD5Update  
Add Data to MD5 computation  

# C  
`void md5update (void *md5, char *data, int len);`  

# ASM  
`>PUSHW md5`  
`>PUSHW data`  
`>PUSHW len`  
`>LIBC MD5Update`  

## RETURN VALUE  

## MD5Finalize  

# C  
`void md5finalize (void *md5, char* digest);`  

# ASM  
`>PUSHW md5`  
`>PUSHW digest`  
`>LIBC MD5Finalize`  

## RETURN VALUE  

# Realloc  

## C / CSH  
`#include <stdlib.h>`  
`void *realloc(void *ptr, size_t size);`  

## ASM  
`>SS`  
`>PUSHW ptr`  
`>PUSHW size`  
`>LIBC realloc`  
`>SR`  

## RETURN VALUE  
 YA = ptr  
 X = hMem  

# Malloc  

## C / CSH  
`#include <stdlib.h>`  
`void *malloc(size_t size);`  

## ASM  
`>LDYA ptr`  
`>LIBC malloc`  

## RETURN VALUE  
 CC : success  
  YA = PTR to Mem (Uninitialised)  
*	X = hMem  
 CS :  
  A = EC  

# Free  

## C / CSH  
`#include <stdlib.h>`  
`void free(void *ptr);`  

## ASM  
`>LDYA ptr`  
`>LIBC free`  

## RETURN VALUE  
 none.  

# Online  
Get ProDOS Volume Info  

## C  
`int online(short int volid, void *buf);`  

## ASM  
`>PUSHB volid`  
`>PUSHW buf`  
`>LIBC Online`  

## RETURN VALUE  

# ChTyp  
Change Type of a ProDOS File  

## C  
`int chtyp(const char *filepath, short int filetype);`  

## ASM  
`>PUSHW filepath`  
`>PUSHB filetype`  
`>LIBC ChTyp`  

## RETURN VALUE  

# ChAux  
Change AuxType of a ProDOS File  

## C  
`int chaux(const char *filepath, int auxtype);`  

## ASM  
`>PUSHW filepath`  
`>PUSHW auxtype`  
`>LIBC ChAux`  

## RETURN VALUE  

# SetAttr  
Change Attributes of a ProDOS File  

## C  
`int setattr(const char *filepath, short int attributes);`  

## ASM  
`>PUSHW filepath`  
`>PUSHB attributes`  
`>LIBC setattr`  

## RETURN VALUE  

# ExecV  

## C / CSH  
`#include <unistd.h>`  
`int execv(const char* argv[], int flags);`  

## ASM  
`>SS`  
`>PUSHW argv`  
`>PUSHW flags`  
`>LIBC execv`  
`>SR`  

## RETURN VALUE  
Y,A = Child PSID  

# ExecL  

## C / CSH  
`#include <unistd.h>`  
` int execl(const char *args, int flags);`  

## ASM  
`>SS`  
`>PUSHW args`  
`>PUSHW flags`  
`>LIBC execl`  
`>SR`  

## RETURN VALUE  
Y,A = Child PSID  

# Fork  

## C / CSH  
`#include <unistd.h>`  
`pid_t fork(void);`  

## ASM  
`>LIBC fork`  

## RETURN VALUE  
A = Child PSID  

# Kill  

## C  
`int kill(int pid, int sig);`  

## ASM  
`>SS`  
`>PUSHW pid`  
`>PUSHW sig`  
`>LIBC kill`  
`>SR`  

## RETURN VALUE  

# GetPS(int PID)  
*  

## C  
`void *getps (int PID);`  

## ASM  
`>LDYA PID`  
`>LIBC GetPS`  

## RETURN VALUE  
 Y,A = Ptr to PS struct  

# LoadTxtFile  
Load TXT a file in memory (with ending 0)  

## C  
`void *loadtxtfile ( const char * filename );`  

## ASM  
`>LDYA filename`  
`>LIBC loadtxtfile`  

## RETURN VALUE  
 Y,A = Ptr to loaded file  

# LoadFile  
Load a file in memory  

## C  
`void *loadfile(const char *filename, short int flags, short int ftype, int auxtype);`  

## ASM  
`>PUSHW filename`  
`>PUSHB flags`  
`>PUSHB ftype`  
`>PUSHW auxtype`  
`>LIBC loadfile`  

## RETURN VALUE  
 Y,A = Ptr to loaded file  

# FileSearch  
Search a file in the provided PATH list  
And return, if found, the full path to it.  

## C  
`int filesearch(char *filename, char *searchpath, char *fullpath, stat *filestat);`  

## ASM  
`>SS`  
`>PUSHW filename`  
`>PUSHW fullpath`  
`>PUSHW searchpath`  
`>PUSHW filestat`  
`>LIBC filesearch`  
`>SR`  

## RETURN VALUE  
CC : success  
DstBuf = FilePath  
DstStat = S.STAT  
CS : not found  

# GetPWUID  

## C  
`#include <pwd.h>`  
`int getpwuid(int uid, S.PW *passwd);`  

## ASM  
`PUSHB uid`  
`>PUSHW passwd`  
`>LIBC getpwuid`  

## RETURN VALUE  

# GetGRGID  

## C  
`#include <pwd.h>`  
`int getgrgid(int gid, S.GRP *group);`  

## ASM  
`>PUSHB gid`  
`>PUSHW group`  
`>LIBC getgrgid`  

## RETURN VALUE  

# GetPWName  

## C  
`#include <pwd.h>`  
`int getpwname(const char* name, S.PW *passwd);`  

## ASM  
`>PUSHW name`  
`>PUSHW passwd`  
`>LIBC getpwname`  

## RETURN VALUE  

# GetGRName  

## C  
`#include <pwd.h>`  
`int getgrname(const char* name, S.GRP *group);`  

## ASM  
`>PUSHW name`  
`>PUSHW group`  
`>LIBC getgrname`  

## RETURN VALUE  

# PutPW  

## C  
`#include <pwd.h>`  
`int putpw(S.PW* passwd);`  

## ASM  
`>LDYA passwd`  
`>LIBC putpw`  

## RETURN VALUE  

# PutGR  

## C  
`#include <pwd.h>`  
`int putgr(S.GRP *group);`  

## ASM  
`>LDYA group`  
`>LIBC putgr`  

## RETURN VALUE  

# OpenSession  

## C  
`#include <pwd.h>`  
`SESSION *opensession(const char *name, const char *passwd);`  

## ASM  
`>PUSHW name`  
`>PUSHW passwd`  
`>LIBC OpenSession`  

## RETURN VALUE  

# CloseSession  

## C  
`#include <pwd.h>`  
`int closesession(SESSION *);`  

## ASM  
`>PUSHB hSID`  
`>LIBC CloseSession`  

## RETURN VALUE  

# SListGetData  

## ASM  
`>SS`  
`>PUSHW pSList`  
`>PUSHW KeyID`  
`>PUSHW DataPtr` (0 if KERNEL should allocate a buffer)  
`>PUSHW DataLen` (Data bytes to return, 0 if String mode)  
`>PUSHW DataOfs` (Start offset in Data)  
`>KAPI SListGetData`  
`>SR`  

## RETURN VALUE  
 Y,A = DataPtr  

# SListAddData  

## ASM  
`>SS`  
`>PUSHW pSList`  
`>PUSHW KeyID`  
`>PUSHW DataPtr`  
`>PUSHW DataLen` (Data bytes to add, 0 if String mode)  
`>KAPI SListAddData`  
`>SR`  

## RETURN VALUE  

# SListSetData  

## ASM  
`>SS`  
`>PUSHW pSList`  
`>PUSHW KeyID`  
`>PUSHW DataPtr`  
`>PUSHW DataLen` (Data bytes to set, 0 if String mode)  
`>KAPI SListSetData`  
`>SR`  

## RETURN VALUE  

# SListGetByID  

## ASM  
`>SS`  
`>PUSHW pSList`  
`>PUSHW KeyID`  
`>PUSHW KeyPtr`  
`>KAPI SListGetByID`  
`>SR`  

## RETURN VALUE  
 Y,A = Next KeyID  

# SListNewKey  

## ASM  
`>SS`  
`>PUSHW pSList`  
`>PUSHW KeyPtr`  
`>PUSHW ScopeID`  
`>PUSHWI NextPtr`  
`>KAPI SListNewKey`  
`>SR`  

## RETURN VALUE  
 Y,A = KeyID  

# SListLookup  

## ASM  
`>SS`  
`>PUSHW pSList`  
`>PUSHW KeyPtr`  
`>PUSHW ScopeID`  
`>PUSHWI NextPtr`  
`>KAPI SListLookup`  
`>SR`  

## RETURN VALUE  
 Y,A = KeyID  

# SListFree  

## ASM  
`>LDYA pSList`  
`>KAPI SListFree`  

## RETURN VALUE  

# SListNew  

## ASM  
`lda Opt`  
`>KAPI SListNew`  

## RETURN VALUE  
Y,A=pSList  

# Socket  

## C / CSH  
`#include <sys/socket.h>`  
`int socket(int socket_family, int socket_type, int protocol);`  

## ASM  
`>SS`  
`>PUSHWI AF_`  
`>PUSHWI SOCK_`  
`>PUSHWI Protocol`  
`>LIBC Socket`  
`>SR`  

## RETURN VALUE  
 CC = success  
 YA = sockfd  

# Bind  

## C / CSH  
`#include <sys/socket.h>`  
`int bind(int socket, const struct sockaddr *address, socklen_t address_len);`  

## ASM  
`>SS`  
`>PUSHW socket`  
`>PUSHW address`  
`>PUSHWI address_len`  
`>LIBC Bind`  
`>SR`  

## RETURN VALUE  
 CC = success  

# Connect  

## C / CSH  
`#include <sys/socket.h>`  
`int connect(int socket, const struct sockaddr *address, socklen_t address_len);`  

## ASM  
`>SS`  
`>PUSHW socket`  
`>PUSHW address`  
`>PUSHWI address_len`  
`>LIBC Bind`  
`>SR`  

## RETURN VALUE  
 CC = success  

# Listen  

## C / CSH  
`#include <sys/socket.h>`  
`int listen(int socket, int backlog);`  

## ASM  
`>SS`  
`>PUSHW socket`  
`>PUSHWI backlog`  
`>LIBC Listen`  
`>SR`  

## RETURN VALUE  
 CC = success  

# Accept  

## C / CSH  
`#include <sys/socket.h>`  
`int accept(int socket, struct sockaddr *restrict address, socklen_t *restrict address_len);`  

## ASM  
`>SS`  
`>PUSHW socket`  
`>PUSHW address`  
`>PUSHWI address_len`  
`>LIBC Accept`  
`>SR`  

## RETURN VALUE  
 CC = success  
 YA = hFD  
 CS = error  
 YA = -1 (ERRNO)  

# ChMod  
change permissions of a file  

## C  
`int chmod(const char *pathname, int mode);`  

## ASM  
`>PUSHW pathname`  
`>PUSHW mode`  
`>LIBC chmod`  

## RETURN VALUE  

# FStat  
Return information about a FD  

## C  
`#include <sys/stat.h>`  
`int fstat(int fd, struct stat *statbuf);`  

## ASM  
`>SS`  
`>PUSHW fd`  
`>PUSHW statbuf`  
`>LIBC fstat`  
`>SR`  

## RETURN VALUE  

# Stat  
Return information about a file  

## C  
`#include <sys/stat.h>`  
`int stat(const char *pathname, struct stat *statbuf);`  

## ASM  
`>SS`  
`>PUSHW pathname`  
`>PUSHW statbuf`  
`>LIBC stat`  
`>SR`  

## RETURN VALUE  

# MKDir  
create a directory  

## C  
`int mkdir(const char *pathname, int mode);`  

## ASM  
`>SS`  
`>PUSHW pathname`  
`>PUSHW mode`  
`>LIBC mkdir`  
`>SR`  

## RETURN VALUE  
CC : success  
CS : error  
A = EC  

# MKFIFO  
return a pathname to a new FIFO  

## C  
`#include <sys/stat.h>`  
`int mkfifo(const char *path, mode_t mode);`  

## ASM  
`>SS`  
`>PUSHW path`  
`>PUSHW mode`  
`>LIBC mkfifo`  
`>SR`  

## RETURN VALUE  
CC = OK, CS = ERROR  

# MkNod  
Create a special or ordinary file.  
(CDEV, BDEV, DSOCK, SSOCK, PIPE)  

## C  
`#include <sys/stat.h>`  
`int mknod(const char *pathname, mode_t mode, dev_t dev);`  

## ASM  
`>SS`  
`>PUSHW pathname`  
`>PUSHW mode`  
`>PUSHW dev`  
`>LIBC mknod`  
`>SR`  

## RETURN VALUE  
CC = OK, CS = ERROR  
A = hFILE  

# pipe  

## C  
`hFD pipe(int size);`  

## ASM  
`>LDYA size`  
`>LIBC pipe`  

## RETURN VALUE  
CC = OK, CS = ERROR  
A = hFD  

# fileno  
map a stream pointer to a file descriptor  

## C / CSH  
`#include <stdio.h>`  
`int fileno(FILE *stream);`  

## ASM  
`>LDYA stream`  
`>LIBC fileno`  

## RETURN VALUE  
 CC = success  
 YA = fildes  

# fputc (BLOCKING)  
Print A (char) to hFILE  

## C / CSH  
`#include <stdio.h>`  
`int fputc(int c, FILE *stream);`  

## ASM  
`>PUSHW character`  
`>PUSHW stream`  
`>LIBC fputc`  

## RETURN VALUE  
CC = success  

# putchar (BLOCKING)  
Print A (char) to StdOut  

## C / CSH  
`#include <stdio.h>`  
`int putchar ( int c );`  

## ASM  
`lda c`  
`>LIBC putchar`  

## RETURN VALUE  
CC = success  

# puts (BLOCKING)  
Write Str to StdOut, appends '\r\n'  

## C / CSH  
`#include <stdio.h>`  
`int puts ( const char * str );`  

## ASM  
`>LDYAI str`  
`>LIBC PutS`  

## RETURN VALUE  
CC : success Y,A > 0  
CS : Y,A = EOF  

# fputs (BLOCKING)  
Write Str to FILE  

## C / CSH  
`#include <stdio.h>`  
`int fputs (const char *s, FILE *stream);`  

## ASM  
`>SS`  
`>PUSHW s`  
`>PUSHW stream`  
`>LIBC fputs`  
`>SR`  

## RETURN VALUE  
CC = success  

# fgets (BLOCKING)  
read bytes from stream into the array  
pointed to by s, until n-1 bytes are read, or a <newline> is read and  
transferred to s, or an end-of-file condition is encountered. The  
string is then terminated with a null byte.  

## C / CSH  
`#include <stdio.h>`  
`char *fgets(char *s, int n, FILE *stream);`  

## ASM  
`>PUSHW s`  
`>PUSHW n`  
`>PUSHW FILE`  
`>LIBC fgets`  

## RETURN VALUE  
 Y,A: s  
CC = success  

# getchar (BLOCKING)  
Get char from StdIn  

## C / CSH  
`#include <stdio.h>`  
`int getchar (void);`  

## ASM  
`>LIBC getchar`  

## RETURN VALUE  
 CC = success  
  A = char  

# getc (BLOCKING)  
Get char from Node  

## C / CSH  
`#include <stdio.h>`  
`int getc(FILE *stream);`  

## ASM  
`>LDYA pStream`  
`>LIBC getc`  

## RETURN VALUE  
 CC = success  
  A = char  

# ungetc  
push byte back into input stream  

## C / CSH  
`#include <stdio.h>`  
`int ungetc(int c, FILE *stream);`  

## ASM  
`>SS`  
`>PUSHW stream`  
`>PUSHW c`  
`>SR`  
`>LIBC ungetc`  

## RETURN VALUE  
 CC = success  
  A = char  

# FOpen  
Open a file  

## C / CSH  
`#include <stdio.h>`  
`FILE *fopen ( const char *filename, short int flags, short int ftype, int auxtype );`  

## ASM  
`>SS`  
`>PUSHW filename`  
`>PUSHB flags`  
 + O.RDONLY : if R and exists -> ERROR  
 + O.WRONLY : if W and exists -> CREATE  
 + O.TRUNC : Reset Size To 0  
 + O.APPEND : Append  
 + O.TEXT   : Open/Append in Text mode  
 + O.CREATE : Create if not exists  
`>PUSHB ftype`  
`>PUSHW auxtype`  
`>LIBC FOpen`  
`>SR`  

## DESCRIPTION  
TODO: replace flags/ftype/auxtype with mode="w+,t=TYP,x=AUXTYPE"  
 + r  = O_RDONLY  
 + r+ = O_RDWR  
 + w  = O_WRONLY | O_CREAT | O_TRUNC  
 + w+ = O_RDWR | O_CREAT | O_TRUNC  
 + a  = O_WRONLY | O_CREAT | O_APPEND  
 + a+ = O_RDWR | O_CREAT | O_APPEND  
 + ,t=123 or t=$ff or t=TXT  
 + ,x=12345 or x=$ffff  

## RETURN VALUE  
 CC : YA = pFILE  
 CS : YA = EC  

# FClose  
Close a file  

## C / CSH  
`#include <stdio.h>`  
`int fclose(FILE *stream);`  

## ASM  
`>LDYA stream`  
`>LIBC FClose`  

## RETURN VALUE  

# FRead (BLOCKING)  
Read bytes from file  

## C  
`#include <stdio.h>`  
`int fread (FILE *stream, void * ptr, int count );`  

## ASM  
`>PUSHW stream`  
`>PUSHW ptr`  
`>PUSHW count`  
`>LIBC FRead`  

## RETURN VALUE  
 Y,A = Bytes Read  

# FWrite (BLOCKING)  
Write bytes to file  

## C  
`#include <stdio.h>`  
`int fwrite (FILE *stream, const void *ptr, int count);`  

## ASM  
`>PUSHW stream`  
`>PUSHW ptr`  
`>PUSHW count`  
`>LIBC fwrite`  

## RETURN VALUE  
 Y,A = Bytes Written  

# FFlush  

## C  
`#include <stdio.h>`  
`int fflush(FILE *stream);`  

## ASM  
`>LDYA stream`  
`>LIBC fflush`  

# FSeek  
Set the file-position indicator for hFILE  

## C / CSH  
`#include <stdio.h>`  
`int fseek(FILE *stream, long offset, int whence);`  

## ASM  
`>SS`  
`>PUSHW stream`  
`>PUSHL offset`  
`>PUSHW whence`  
`>LIBC fseek`  
`>SR`  

# FEOF  
Test the end-of-file indicator for hFILE  

## C / CSH  
`#include <stdio.h>`  
`int feof(FILE *stream);`  

## ASM  
`>LDYA stream`  
`>LIBC feof`  

## RETURN VALUE  
 CC :  
 A = $ff EOF  
 A = 0 NOT EOF  
 CS :  

# FTell  
Return the current value of the file-position indicator  

## C / CSH  
`#include <stdio.h>`  
`long ftell(FILE *stream);`  

## ASM  
`>LDYA stream`  
`>LIBC ftell`  

## RETURN VALUE  
On stack (long)  

# Remove  
Remove a file or directory  

## C  
`#include <stdio.h>`  
`int remove ( const char *pathname );`  

## ASM  
`>LDYA pathname`  
`>LIBC remove`  

## RETURN VALUE  

# Rename  
Rename a file  

## C  
`#include <stdio.h>`  
`int rename ( const char * oldpath, const char * newpath );`  

## ASM  
`>SS`  
`>PUSHW oldpath`  
`>PUSHW newpath`  
`>LIBC rename`  
`>SR`  

## RETURN VALUE  

# PrintF (BLOCKING)  

# FPrintF (BLOCKING)  

# SPrintF  
Prints C-Style String  

## C / CSH  
`#include <stdio.h>`  
`int printf ( const char *format, ... );`  
`int fprintf ( FILE *stream, const char *format, ... );`  
`int sprintf ( char *str, const char *format, ... );`  

## ASM  
PrintF : (example is for printing Y,A as integer : format="%I", 2 bytes)  
`>PUSHW format`  
`>PUSHW i`  
`...`  
`>PUSHBI 2`	#bytecount  
`>LIBC PrintF`  
FPrintF :  
`>PUSHW FILE`  
`>PUSHW format`  
`>PUSHW i`  
`...`  
`>PUSHBI 2`	#bytecount  
`>LIBC fprintf`  
SPrintF :  
`>PUSHW str`  
`>PUSHW format`  
`>PUSHW i`  
`...`  
`>PUSHBI 2`	#bytecount  
`>LIBC sprintf`  

## RETURN VALUE  
CC : success, Y,A = bytes sent  
CS : error, A = code from Output  
Specifiers :  
+ %% : print % char  
+ %b : pull 1 byte to Print BIN  
+ %d : pull 1 byte unsigned DEC 0..255  
+ %D : pull 2 bytes unsigned DEC 0..65535  
+ %u : pull 4 bytes long unsigned DEC 0..4294967295  
+ %e : pull 5 Bytes float (-)1.23456789e+12  
+ %f : pull 5 Bytes float (-)3.1415  
+ %h : pull 1 byte to Print HEX  
+ %H : pull 2 bytes to Print HEX  
+ %i : pull 1 byte to Print signed DEC -128..127  
+ %I : pull 2 bytes to Print signed DEC -32768..32767  
+ %L : pull 4 bytes signed DEC -2147483648..2147483647  
+ %s : pull 2 bytes ptr to C-Style String  
+ %S : pull 2 bytes ptr to P-Style String  

Modifiers for len and padding :  
+ %d	  : '9'  '12'  
+ %2d	  : ' 9' '12'  
+ %02d  : '09' '12'  
+ %11s  : 'ABCDEFGH   '  
+ %011s : 'ABCDEFGH000'  
+ %2f	  :	'3.14'  


# ScanF (BLOCKING)  

# FScanF (BLOCKING)  

# SScanF  
Read formatted data from string  

## C  
`int scanf( const char *format, ... );`  
`int fscanf( FILE *stream, const char *format, ... );`  
`int sscanf ( const char *s, const char *format, ... );`  

## ASM  
ScanF :  
`>PUSHW format`  
`>PUSHW ptr`  
`...`  
`>PUSHB bytecount`  
`>LIBC scanf`  
FScanF :  
`>PUSHB stream`  
`>PUSHW format`  
`>PUSHW ptr`  
`...`  
`>PUSHB bytecount`  
`>LIBC fscanf`  
SScanF :  
`>PUSHW s`  
`>PUSHW format`  
`>PUSHW ptr`  
`...`  
`>PUSHB bytecount`  
`>LIBC sscanf`  
Specifiers :  
+ %i : short int  
+ %d : byte  
+ %I : int  
+ %D : word  
+ %L : long int  
+ %U : dword  
+ %h : HEX byte  
+ %H : HEX word  
+ %s : string  

TODO : %10s  

## RETURN VALUE  
A = Number of arguments filled.  

# Random  

## C / CSH  
`#include <stdlib.h>`  
`long random(void);`  

# StrToF  
Convert String to 40 bits Float  

## C / CSH  
`#include <stdlib.h>`  
`float strtof (const char* str, char** endptr );`  

## ASM  
`>SF`  
`>SS`  
`>PUSHW str`  
`>PUSHWI EndPtr`  
`>LIBC StrToF`  
`>SR`  

## RETURN VALUE  
On stack (float) at pBase  

# AToF  
Convert String to 40 bits Float  

## C / CSH  
`#include <stdlib.h>`  
`float atof ( const char* str );`  

## ASM  
`>SF`  
`>LDYA str`  
`>LIBC atof`  

## RETURN VALUE  
On stack (float) at pBase  

# StrToL/StrToUL  
Convert String to 32 bits (unsigned) int  

## C / CSH  
`#include <stdlib.h>`  
`long strtol (const char* str, char** endptr, int base);`  
`unsigned long strtoul (const char* str, char** endptr, int base);`  

## ASM  
`>SL`  
`>SS`  
`>PUSHW str`  
`>PUSHW EndPtr`  
`>PUSHW Base`  
`>LIBC StrToL`  
`>SR`  

## RETURN VALUE  
On stack (long) at pBase  

# atol  
Convert String to 32 bits long  

## C / CSH  
`#include <stdlib.h>`  
`long atol ( const char * str );`  

## ASM  
`>SL`  
`>LDYA str`  
`>LIBC atol`  

## RETURN VALUE  
On stack (long)  

# atoi  
Convert String to 16 bits int  

## C /CSH  
`#include <stdlib.h>`  
`int atoi ( const char * str );`  

## ASM  
`>LDYA str`  
`>LIBC atoi`  

## RETURN VALUE  
 Y,A = int  

# RealPath  

## C / CSH  
`#include <limits.h>`  
`#include <stdlib.h>`  
`char *realpath(const char *path, char *resolvedpath);`  

## ASM  
`>SS`  
`>PUSHW path`  
`>PUSHW resolvedpath`  
`>LIBC realpath`  
`>SR`  

## DESCRIPTION  
Return the canonicalized absolute pathname.  
If resolvedpath is specified as NULL, then realpath() uses  
malloc() to allocate a buffer of PATH_MAX bytes to hold  
the resolved pathname, and returns a pointer to this buffer.  
The caller should deallocate this buffer using free().  

## RETURN VALUE  
CC : Y,A = Ptr to resolvedpath  
CS : Y,A = NULL, ERRNO set  

# Expand  

## C / CSH  
`#include <stdlib.h>`  
`char *expand(const char *str, char *expanded);`  

## ASM  
`>SS`  
`>PUSHW str`  
`>PUSHW expanded`  
`>LIBC expand`  
`>SR`  

## RETURN VALUE  
CC : Y,A = PTR to Expanded String  
CS : Y,A = NULL, ERRNO  

# StrDup  
Create a new copy of this C-String  

## C  
`#include <string.h>`  
`char *strdup(const char *s);`  

## ASM  
Y,A = Ptr to source C-String  
CC : success   
 Y,A = PTR to String  
CS : error  
 A = SYS error code  

# StrLen  
Returns Length of C-String  

## C  
`#include <string.h>`  
`size_t strlen(const char *s);`  

## ASM  
`>LDYAI str`  
`>LIBC strlen`  

## RETURN VALUE   
Y,A = String length  

# StrCat  
Concatenate strings  

## C  
`#include <string.h>`  
`char * strcat ( char * destination, const char * source );`  

## ASM  
`>PUSHWI destination`  
`>PUSHWI source`  
`>LIBC strcat`  

## RETURN VALUE   
Y,A = destination  

# StrCpy  
`#include <string.h>`* Copy string  

## C  
`#include <string.h>`  
`char *strcpy(char *restrict dst, const char *restrict src);`  

## ASM  
`>PUSHWI destination`  
`>PUSHWI source`  
`>LIBC strcpy`  

## RETURN VALUE   
Y,A = destination  

# StrUpr/StrLwr  
Convert string to UPPERCASE/lowercase  

## C  
`#include <string.h>`  
`int strupr ( char * str);`  
`int strlwr ( char * str);`  

## ASM  
`>LDYAI str`  
`>LIBC strupr`  
`>LIBC strlwr`  

## RETURN VALUE   
Uppercased/lowercased String in Buffer  
Y,A = str  

# StrCmp  
Compare 2 strings  

## C  
`#include <string.h>`  
`int strcmp(const char *s1, const char *s2);`  

## ASM  
`>PUSHWI s1`  
`>PUSHWI s2`  
`>LIBC strcmp`  

## RETURN VALUE   
CC : match  
CS : no match  
 CC, Y,A=0  
 CS, Y,A > 0 or < 0  

# StrCaseCmp  
Compare 2 strings, ignoring case  

## C  
`#include <string.h>`  
`int strcasecmp(const char *s1, const char *s2);`  

## ASM  
`>PUSHWI s1`  
`>PUSHWI s2`  
`>LIBC strcasecmp`  

## RETURN VALUE   
CC : match  
CS : no match  
 CC, Y,A=0  
 CS, Y,A > 0 or < 0  

# StrVNew  

## ASM  
`>LDYA size`  
`>LIBC StrVNew`  

## RETURN VALUE  

# StrVSet  

## ASM  
`>PUSHW pSTRV`  
`>PUSHW id`  
`>PUSHW ptr`  
`>LIBC StrVSet`  

## RETURN VALUE  

# StrVGet  

## ASM  
`>PUSHW pSTRV`  
`>PUSHW id`  
`>PUSHW ptr`  
`>LIBC StrVGet`  

## RETURN VALUE  
 CC: Y,A = Ptr  
 CS: A = E.NOKEY  

# TBufGetL  

## ASM  
`>SS`  
`>PUSHW pTBuf`  
`>PUSHW LineNum`  
`>PUSHW DataPtr`  
`>KAPI TBufGetL`  
`>SR`  

## RETURN VALUE  

# TBufGetB  

## ASM  
`>SS`  
`>PUSHW pTBuf`  
`>PUSHW DataOfs`  
`>PUSHW DataPtr`  
`>PUSHW DataLen`  
`>KAPI TBufGetB`  
`>SR`  

## RETURN VALUE  

# TBufIns  

## ASM  
`>SS`  
`>PUSHW pTBuf`  
`>PUSHW DataOfs`  
`>PUSHW DataPtr`  
`>PUSHW DataLen`  
`>KAPI TBufIns`  
`>SR`  

## RETURN VALUE  

# TBufDel  

## ASM  
`>SS`  
`>PUSHW pTBuf`  
`>PUSHW DataOfs`  
`>PUSHW DataLen`  
`>KAPI TBufDel`  
`>SR`  

## RETURN VALUE  

# TBufNew  

## ASM  
`>KAPI TBufNew`  

## RETURN VALUE  

# TBufFree  

## ASM  
`>LDYA pTBuf`  
`>KAPI TBufFree`  

## RETURN VALUE  

# Time  
Get System Time in Buffer  

## C  
`void time (struct tm* timeptr);`  

## ASM  
`>LDYA timer`  
`>LIBC time`  

## RETURN VALUE  
S.TIME filled with System date/time  

# PTime2Time  
 Convert ProDOS Time To S.TIME  

## C  
`void PTime2Time (long ptime, const struct tm* timeptr );`  

## ASM  
`>PUSHL ptime`  
`>PUSHW timer`  
`>LIBC PTime2Time`  

## RETURN VALUE  

# StrFTime  

## C  
Convert S.TIME struct to CSTR  
`void strftime (char* str, const char* format, const struct tm* timeptr );`  

## ASM  
`>PUSHW str`  
`>PUSHW format`  
+ %a : Abbreviated weekday name : Thu  
+ %A : Full weekday name : Thursday  
+ %b : Abbreviated month name : Aug  
+ %B : Full month name : August  
+ %d : Day of the month, zero-padded (01-31)  
+ %H : Hour in 24h format (00-23) 14  
+ %I : Hour in 12h format (01-12) 02  
+ %m : Month as a decimal number (01-12) 08  
+ %M : Minute (00-59) 55  
+ %p : AM or PM designation PM  
+ %S : Second (00-61) 02  
+ %w : Weekday as a decimal number with Sunday as 0 (0-6)  
+ %y : Year, last two digits (00-99)  
+ %Y : Year four digits 2001  

`>PUSHW timeptr`  
`>LIBC strftime`  

## RETURN VALUE  
  none. always succeed.  

# CTime2Time  
 Convert CTime Time To S.TIME  

## C  
`void CTime2Time (long* ctime, const struct tm* timeptr );`  

## ASM  
`>PUSHW ctime`  
`>PUSHW timer`  
`>LIBC CTime2Time`  

## RETURN VALUE  

# open  

## C / CSH  
`int open(const char *pathname, short int flags);`  

## ASM  
`>PUSHW pathname`  
`>PUSHB flags`  
`>LIBC open`  

## RETURN VALUE  
A = hFD  
REG File created on ProDOS : T=TXT,X=$0000  

# close  

## C  
`#include <unistd.h>`  
`int close(int fd);`  

## ASM  
`>LDYA fd`  
`>LIBC close`  

# read  

## C  
`#include <unistd.h>`  
`size_t read(int fd, void *buf, size_t count);`  

## ASM  
`>PUSHW fd`  
`>PUSHW buf`  
`>PUSHW count`  
`>LIBC read`  

## RETURN VALUE  
CC: Y,A = bytes read  
CS: A = EC  

# write  

## C  
`#include <unistd.h>`  
`int write(int fd, const void *buf, int count);`  

## ASM  
`>PUSHW fd`  
`>PUSHW buf`  
`>PUSHW count`  
`>LIBC write`  

## RETURN VALUE  
CC: Y,A = bytes written  
CS: A = EC  

# LSeek  
Set the file-position indicator for hFD  

## C  
`int lseek(off_t fildes, off_t offset, short int whence );`  

## ASM  
`>PUSHB hFD`  
`>PUSHL offset`  
`>PUSHB whence`  
`>LIBC fseek`  

# ChOwn  

## C  
`#include <unistd.h>`  
 `int chown(const char *pathname, uid_t owner, gid_t group);`  

## ASM  
`>SS`  
`>PUSHW pathname`  
`>PUSHW owner`  
`>PUSHW group`  
`>LIBC chown`  
`>SR`  

## RETURN VALUE  

# GetCWD  

## C  
`#include <unistd.h>`  
 `char *getcwd(char *buf, size_t size);`  

## ASM  
`>PUSHW buf`  
`>PUSHW size`  
`>LIBC chown`  

## RETURN VALUE  
 NULL CS  
 buf CC  

# ChDir  

## Description  
chdir() changes the current working directory of the calling  
        process to the directory specified in path.  

## See also  
getcwd()  

## C  
`#include <unistd.h>`  
`int chdir(const char *path);`  

## ASM  
`>LDYA path`  
`>LIBC chdir`  

## RETURN VALUE  
 CS : YA = int RC < 0 $FFxx  
 CC : YA = 0  

# GetHostName  

## Description  
gethostname() returns the null-terminated hostname in the  
character array name, which has a length of len bytes.  If the  
null-terminated hostname is too large to fit, then the name is  
truncated, and no error is returned  

## See also  

## C  
`#include <unistd.h>`  
` int gethostname(char *name, size_t len);`  

## ASM  
`>SS`  
`>PUSHW name`  
`>PUSHW len`  
`>LIBC GetHostName`  
`>SR`  

## RETURN VALUE  
 CS : YA = -1, ERRNO  
 CC : YA = 0  

## License
A2osX is licensed under the GNU General Public License.

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

The full A2osX license can be found **[Here](../LICENSE)**.

*** End of Auto generated file ***  
