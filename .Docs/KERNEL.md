*** Auto generated by docgen.cmd ***  

# GetArgC
Returns argument count in the process command line.

## In:
+ none.

## Out: 
+ A = Command line Arg Count (Including /path/cmd)

# GetArg.A

## In:
+ A = argument index.

## Out: 
+ CC : success
 + Y,A = CStr To Arg[A]
+ CS : Out Of Bound

# GetDevByID.A

## IN: 
+ A = DevID

## OUT:
+ CC = OK, CS = ERROR
+ Y,A = DEVSLOT
+ note: X Unmodified

# GetDevByName.YA

## IN: 
+ Y,A = Ptr to device name (PStr)

## OUT:
+ CC = OK, CS = ERROR
+ X = DEVID
+ Y,A = DEVSLOT

# GetDevStatus.A

## IN: 
+ A = DevID

## OUT:
+ CC = OK, CS = ERROR
+ Y,A = Ptr to S.DEVINFO

# OpenDir.YA

## In:
+ Y,A = PATH (C-String)

## Out: 
+ CC : success
 + A = hDIR
+ CS : error
 + A = EC

# ReadDir.A

## In: 
+ A = hDIR

## Out: 
+ CC : success
 + X = hDIRENT
 + Y,A = PTR to S.DIRENT
+ CS : error
 + A = EC
 + note : A = 0 means no more entry

# CloseDir.A

## In: 
+ A = hDIR

## Out:
+ none, always succeed. 

# NewPStrYA
Create a new copy of PSTR

## In:
+ Y,A = PTR to buffer

## Out:
+ CC : success 
 + Y,A = PTR to String
 + X = hMem (PSTR)
+ CS : error
 + A = SYS error code

# ExpandPStr.YA

## In:
+ Y,A = PTR to String to Expand (PSTR)

## Out:
+ X = hMem to Expanded String (PSTR)
+ Y,A = PTR to Expanded String 

# PutEnv.YA

## In:
+ Y,A = PTR to String NAME=VALUE (PSTR)

## Out:

# SetEnv

## In:
+ PUSHW = PTR To Value (PSTR)
+ PUSHW = PTR To Name (PSTR)

## Out:

# GetEnv.YA

## In:
+ Y,A = PTR to NAME (PSTR)

## Out:
+ CC : Y,A = PTR to VALUE (PSTR)
+ CS : not found

# UnsetEnv.YA

## In:
+ Y,A = PTR To Name (PSTR)

## Out:

# FileSearch
Search a file in the provided PATH list
And return, if found, the full path to it.

## In:
+ PUSHW = Ptr to Search Path (CSTR) %LIB%;/SYS/SLIB
+ PUSHW = Ptr to File Name (CSTR)		
+ PUSHW = Ptr to DstBuf
+ PUSHW = Ptr to DstStat

## Out:
+ CC : success
 + DstBuf = FilePath
 + DstStat = S.STAT
+ CS : not found

# GetFullPath.YA

## In :
+ Y,A = Filename (PSTR)

## Out :
+ CC : success
 + Y,A = FullPath (PSTR)
 + X = hMem of FullPath
+ CS : A = Error Code

# LoadFile

## In:
+ PUSHW = AUXTYPE (Handled by....
+ PUSHB = TYPE  ...
+ PUSHB = MODE  ...
+ PUSHW = PATH ...FOpen)

## Out:
+ Y,A = File Length
+ X = hMem of Loaded File

# SaveFile

## In:
+ PUSHW = SrcPtr
+ PUSHW = SrcLen
+ PUSHW = AUXTYPE (Handled by....
+ PUSHB = TYPE  ...
+ PUSHB = MODE  ...
+ PUSHW = PATH ...FOpen)

# ChTyp

## In:
+ PUSHB = TYPE
+ PUSHW = PATH

# ChMod

## In:
+ PUSHW = UID
+ PUSHW = PATH

# ChOwn

## In:
+ PUSHW = UID
+ PUSHW = PATH

# ChGrp

## In:
+ PUSHW = GID
+ PUSHW = PATH

# GetMem

## In: 
+ PUSHW = Size Requested
+ PUSHB = Options
 + S.MEM.F.INIT0 : init memory with 00
 + S.MEM.F.ALIGN : page aligned

## Out:
+ CC : success
 + YA = PTR to Mem
*	X = hMem
+ CS :
 + A = EC

# GetMem0.YA

## In: 
+ Y,A = Size Requested

## Out:
+ CC : success
 + YA = PTR to Mem (ZERO Initialised)
*	X = hMem
+ CS :
 + A = EC

# GetMem.YA

## In: 
+ Y,A = Size Requested

## Out:
+ CC : success
 + YA = PTR to Mem (Uninitialised)
*	X = hMem
+ CS :
 + A = EC

# FreeMem.A

## In:
+ A = hMem To Free

## Out:
+ none.
+ (X,Y unmodified)

# GetMemPtr.A

## In:
+ A = hMem

## Out:
+ Y,A = PTR to MemBlock
+ (X unmodified)

# GetMemByID.A

## In:
+ A = hMem

## Out:
+ Y,A = ZPMemMgrSPtr = PTR to S.MEM
+ X unmodified

# GetMemStat.YA

## In:
+ Y,A = 24 bytes buffer

## Out:
+ Buffer filled with memory stats

# ExecProcessNewEnv.YA

# ExecProcess.YA	(Blocking Parent PID)

# CreateProcessNewEnv.YA 

# CreateProcess.YA (Non Blocking)

## In:
 + Y,A = PTR To Cmd Line

## Out:
 + A = Child PSID

# GetPSByID.A

## In : 
+ A = PID

## Out : 
+ Y,A = PTR to TSKSLOT

# Sleep
Make current process suspend until next RUN

## In : 
+ (none)

## Out : 
+ (none)

# Str2StrArray.YA
Convert a CSTR (e.g. : command Line) to a Array of CSTRs (Args[])

## In: 
+ Y,A = PTR to String

## Out:
+ CC : success
 + Y,A = PTR to StrArray
 + X = hMem
+ CS : error
 + A = SYS error code

# Stat
Return information about a file

## In :
+ PUSHW = PTR to S.STAT buffer
+ PUSHW = PTR to Filename (PSTR)

## Out :

# MKDirYA

## In: 
+ Y,A = DIR name

## Out:
+ CC : success
+ CS : error
 + A = EC

# MkNod.YA
return a hFile for a given Device Name

## IN: 
+ Y,A=DevName

## OUT:
+ CC = OK, CS = ERROR
+ A = hFILE

# MkNod.A
return a hFile for a given Socket

## IN: 
+ A=hSocket

## OUT:
+ CC = OK, CS = ERROR
+ X = hFILE
+ Y,A = pFILE

# MKFIFO
return a S.FILE to a new FIFO

## IN: 

## OUT:
+ CC = OK, CS = ERROR
+ A = hFILE

# FOpen
Open a file

## In :
+ PUSHW = AUXTYPE
+ PUSHB = TYPE
+ PUSHB = MODE
 + SYS.FOpen.R : if R and exists -> ERROR
 + SYS.FOpen.W : if W and exists -> CREATE
 + SYS.FOpen.A : Append
 + SYS.FOpen.T : Open/Append in Text mode
 + SYS.FOpen.X : Create if not exists
+ PUSHW = PATH (PSTR)

## Out : 
+ CC : A = hFILE
+ CS : A = EC

# FClose.A
Close a file

## In :
+ A = hFILE

## Out :

# FRead.A
Read ONE byte from file

## In :
+ A = hFILE

## Out :
+ A = Byte Read

# FWrite.AY

## In:
+ A = hFILE
+ Y = char

# Out:
+ Y,A = Bytes Written

# FRead
Read bytes from file

## In :
+ PUSHW = Dest Ptr
+ PUSHW = Bytes To Read
+ PUSHB = hFILE

## Out :
+ Y,A = Bytes Read

# FWrite

## In:
+ PUSHW = Src Ptr
+ PUSHW = Bytes To Write
+ PUSHB = hFILE

# Out:
+ Y,A = Bytes Written

# FFlush.A

## In:
+ A = hFILE

# FSeek

## In:
+ PUSHW = OffsetHi
+ PUSHW = OffsetLo
+ PUSHB = From
+ PUSHB = hFILE

# FTell.A

## In:
+ A = hFILE

## Out:
 + Y,A,X = Offset

# FEOF.A

## In:
+ A = hFILE

## Out:
+ CC : 
 + A=0 EOF
 + A =0 NOT EOF
+ CS :

# Remove.YA

# Rename
Rename a file

## In :
+ PUSHW = New Name
+ PUSHW = Old Name

## Out :

# FPutC.AY
Print A (char) to File

## In:
+ A : char to print
+ Y = hFILE

## Out: 
+ CC = success

# PutChar.A
Print A (char) to StdOut

## In:
+ A : char to print

## Out: 
+ CC = success

# GetChar
Get char from StdIn

## In:
+ none.

## Out: 
+ CC = success
 + A = char

# GetC.A
Get char from File

## In:
+ A = hFILE

## Out: 
+ CC = success
 + A = char

# FPutS
Write String to FILE

## In:
+ PUSHW : CPtr 
+ PUSHB : hFILE

## Out: 
+ CC = success

# PutS.YA
Write String to StdOut

## In:
+ Y,A : CPtr 

## Out: 
+ CC = success

# FGetS
Read String From FILE

## In:
+ PUSHW : CPtr 
+ PUSHB : hFILE

## Out: 
+ CC = success

# GetS.YA
Read String From StdIn

## In:
+ Y,A : CPtr 

## Out: 
+ CC = success

# SScanF
Scan a PStr (in progress)

## In:
+ PUSHW PTR to target buffer
+ PUSHW PSTR pattern	(ex: "%d.%d.%d.%d")
 + %d : byte
+ PUSHW PSTR to scan (ex: "192.168.1.5")

## Out:

# PrintF.YA/SPrintF.YA/FPrintF.YA
Prints C-Style String

## In:
PrintF.YA : 
 + Y,A = PTR to CStr
SPrintF.YA : 
 + Y,A = PTR to CStr
 + PULLW = Ptr to Dst Buffer
FPrintF.YA : 
 + Y,A = PTR to CStr
 + PULLB = hNode

## Out:
+ CC : success
+ CS : error code from Output
+ Specifiers :
 + %a : pull 2 bytes to Print Access right String 'drwxrwxrwx'
 + %b : pull 1 byte to Print BIN 
 + %B : pull 2 bytes to Print BIN
 + %d : pull 1 byte unsigned DEC 0..255
 + %D : pull 2 bytes unsigned DEC 0..65535
 + %u : pull 2 bytes PTR to 4 bytes long unsigned DEC 0..4294967295
 + %e : pull 2 bytes PTR to 6 Bytes Real +1.23456789e+12
 + %f : pull 2 bytes PTR to 6 Bytes Real 3.1415
 + %h : pull 1 byte to Print HEX
 + %H : pull 2 bytes to Print HEX
 + %i : pull 1 byte to Print signed DEC -128..127
 + %I : pull 2 bytes to Print signed DEC -32768..32767
 + %L : pull 2 bytes PTR to 4 bytes signed DEC -2147483648..2147483647
 + %n : pull 1 byte to Print low Nibble HEX
 + %N : pull 1 byte to Print high Nibble HEX
 + %s : pull 2 bytes ptr to C-Style String
 + %S : pull 2 bytes ptr to P-Style String
 + \b : Print 'BS' (08)
 + \e : Print 'ESC' ($1B,27)
 + \f : Print 'FF' ($0C,12)
 + \n : Print 'LF' ($0A,10)
 + \r : Print 'CR' ($0D,13)
 + \\\\ : Print \
 + \% : Print %
+ Modifiers for len and padding : 
 + %d	  : '9'  '12'
 + %2d	  : ' 9' '12'   				
 + %02d  : '09' '12'
 + %11s  : 'ABCDEFGH   '	
 + %011s : 'ABCDEFGH000'
 + %2f	  :	'3.14'

# AToI
Convert String to 32 bit int

## In:
+ PUSHW PTR to target buffer DWORD
+ PUSHW Source String (PSTR)

## Out:

# StrLen.YA
Returns Length of C-String

## In: 
+ Y,A = Ptr to CSTR

## Out: 
+ Y,A = String length

# StrCat
Append SRC to DST

## In: 
+ PUSHW = Ptr to SRC (CSTR)
+ PUSHW = Ptr to DST (CSTR)

## Out: 
+ DST = DST+SRC

# StrCpy
Copy string

## In: 
+ PUSHW = Ptr to SRC (CSTR)
+ PUSHW = Ptr to DST (CSTR)

## Out: 
+ DST = SRC

# StrMatch
Compare a String against pattern

## In: 
 + PUSHW = PTR to Pattern (e.g. '*test?.txt')
 + PUSHW = PTR to Src String 

## Out: 
 + CC : match
 + CS : no match

# StrUpr.YA/StrLwr.YA
Convert string to UPPERCASE/lowercase

## In:
 + Y,A = PTR to String (CSTR)

## Out:
 + Uppercased/lowercased String in Buffer

# StrFTime
Convert S.TIME struct to CSTR

## In: 
+ PUSHW = Dst PTR To CSTR Buf
+ PUSHW = Src PTR To Format String
 + %a : Abbreviated weekday name : Thu
 + %A : Full weekday name : Thursday 
 + %b : Abbreviated month name : Aug 
 + %B : Full month name : August 
 + %d : Day of the month, zero-padded (01-31)
 + %H : Hour in 24h format (00-23) 14 
 + %I : Hour in 12h format (01-12) 02 
 + %m : Month as a decimal number (01-12) 08 
 + %M : Minute (00-59) 55 
 + %p : AM or PM designation PM 
 + %S : Second (00-61) 02 
 + %w : Weekday as a decimal number with Sunday as 0 (0-6) 
 + %y : Year, last two digits (00-99)
 + %Y : Year four digits 2001 
+ PUSHW = Src PTR To S.Time

## Out:
 + none. always succeed.
