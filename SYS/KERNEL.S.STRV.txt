NEW
  AUTO 3,1
*/--------------------------------------
* # NewStrV
* **In:**
*  A = Initial Size (Page)
* ## RETURN VALUE
*  X = hStrV
*  Y,A = Ptr
*\--------------------------------------
*K.NewStrV
*/--------------------------------------
* # StrVGet
* ## ASM
* `>PUSHB hSTRV`
* `>PUSHW index`
* `>SYSCALL StrVGet`
* ## RETURN VALUE
*  CC: Y,A = Ptr
*  CS: Y,A = NULL
*\--------------------------------------
K.StrVGet		>PULLA 					index
				eor #$ff
				sta ZPPtr2
				
				>PULLA
				eor #$ff
				sta ZPPtr2+1
				
				>PULLA
				>SYSCALL GetMemPtr
				>STYA ZPPtr1			strV
				
.1				inc	ZPPtr2
				bne .2
				
				inc	ZPPtr2
				beq .8
				
.2				jsr STRV.NStrPtr1
				bcc .1
				
.9				rts
				
.8				lda (ZPPtr1)
				tay
				dec
				beq .9
				
				>LDYA ZPPtr1
				clc
				rts
*/--------------------------------------
* # StrVAdd
* ## ASM
* `>PUSHB hSTRV`
* `>PUSHW str`
* `>SYSCALL StrVAdd`
* ## RETURN VALUE
* 
*\--------------------------------------
*K.StrVAdd		>PULLW ZPPtr2			str
*				>PULLA
*				>SYSCALL GetMemPtr
*				>STYA ZPPtr1
*/--------------------------------------
* # StrVDup
* **In:**
*  Y,A = Src StrV
* ## RETURN VALUE
*  X = hMem of new StrV
*  A = Str Count
*\--------------------------------------
K.StrVDup		>STYA ZPPtr1
				>STYA ZPPtr2

				ldy #0
				ldx #0
				
.1				lda (ZPPtr2),y
				beq .2
				
.11				iny
				bne .1
				
				inx
				inc ZPPtr2+1
				bra .1
				
.2				iny
				bne .3
				inx
				inc ZPPtr2+1
				
.3				lda (ZPPtr2),y
				bne .11
				
				txa
				
				jsr K.getmem
				bcs .9
				
				>STYA ZPPtr2
				phx
				
				ldx #0
				
				ldy #0
				
.4				lda (ZPPtr1),y
.5				sta (ZPPtr2),y
				beq .6

				iny
				bne .4
				
				inc ZPPtr1+1
				inc ZPPtr2+1
				bra .4
				
.6				inx

				iny
				bne .7
				
				inc ZPPtr1+1
				inc ZPPtr2+1
				
.7				lda (ZPPtr1),y
				bne .5
				sta (ZPPtr2),y			Ending \0

				txa
				plx						hMem
				
				clc
.9				rts
*/--------------------------------------
* # Str2StrV
* Expand String and convert to StrV List
* ## C
* short int str2strv(char* args, char* argv[])
* ## ASM
* `>PUSHW argv`
* `>LDYA args`
* `>SYSCALL Str2StrV`
* ## RETURN VALUE
* A = Arg count
*\--------------------------------------
K.Str2StrV		jsr K.Expand

				bcs .9
				>STYA ZPPtr1
				stx .80+1

				>PULLW ZPPtr2			Get target buffer
				ldx #0					Arg Count
				ldy #0					bInQuote

.1				jsr SHARED.GetCharPtr1
				beq .8

				cmp #C.SPACE
				beq .1					skip leading spaces

.2				cmp #'"'				found a quote ?
				bne .3
				
				tya
				eor #$ff
				tay
				bra .7				skip quote and check next char

.3				cmp #C.SPACE
				bne .6				regular char ...store...
				tya
				bmi .4				between quotes... store space...

				inx					Found one arg !!!
				lda #0				set this token End
				jsr SHARED.PutCharPtr2
				bra .1
				
.4				lda #C.SPACE
.6				jsr SHARED.PutCharPtr2

.7				jsr SHARED.GetCharPtr1
				bne .2

				inx
				
.8				jsr SHARED.PutCharPtr2	set Argv[x] Ending 0

				sta (ZPPtr2)		set Array Ending 0
				phx
.80				lda #$FF			SELF MODIFIED
				jsr K.FreeMem		Discard expanded string
				pla					get back Arg Count

*				clc
				rts
.9				>RET 2				Discard target buffer
*--------------------------------------
STRV.NStrPtr1	ldy #$ff
				
.1				iny

				lda (ZPPtr1)
				beq .2
				
				inc ZPPtr1
				bne .1
				inc ZPPtr1+1
				bra .1
				
.2				tya
				beq .9

				inc ZPPtr1
				bne .8
				inc ZPPtr1+1			skip \0
				
.8				clc
				rts
				
.9				sec
				rts
*--------------------------------------
MAN
SAVE USR/SRC/SYS/KERNEL.S.STRV
LOAD USR/SRC/SYS/KERNEL.S
ASM
