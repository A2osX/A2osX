NEW
  AUTO 3,1
*--------------------------------------
* SYSCALL (AUXLC to AUXLC)
* Used by user & kernel for inter bank Calls 
* In:
*   X = SYSfnc.Index
*   Y,A = free for Inline param
*--------------------------------------
GP.CodeStart	jmp GP.SysCall
*--------------------------------------
* LIBCALL (AUXLC to AUXLC)
* Used by user 
* In:
*   Y = LIB.ID
*   X = LIBfnc.Index
*   A = free for Inline param
*--------------------------------------
				jmp GP.LibCall
*--------------------------------------
* AppleTalk MLICALL (AUXLC to MAINLC)
* Used by user
* In:
*   Y,A = Params
*--------------------------------------
				jmp GP.AtkCall
*--------------------------------------
* ROMCALL (AUXLC to ROMLC)
* Used by Kernel
* In:
*   X = ROM Function
*	Y,A = Param
*--------------------------------------
				jmp GP.FpuCall
*--------------------------------------
* BADCALL
*--------------------------------------
				lda #MLI.E.BADCALL
				sec
				rts
*--------------------------------------
* SLEEP
*--------------------------------------
GP.Sleep		php
				sei

				phy
				ldy #S.PS.A
				sta (pPs),y
				
				txa
				iny						#S.PS.X
				sta (pPs),y
				
				pla
				iny						#S.PS.Y
				sta (pPs),y
				
				pla
				iny						#S.PS.P
				sta (pPs),y

				pla						get PC LO
				plx						get PC HI
				
				inc						Advance one byte because of return by RTI
				bne GP.Sleep2
				inx
				
GP.Sleep2		ldy #S.PS.PC
				sta (pPs),y

				txa
				iny						#S.PS.PC+1
				sta (pPs),y

				tsx
				
				inx						
				inx						keep PC HI,LO from KERNEL jsr PSExec/PSResume
				
				inx						Stack Ptr is $1ff if empty
				
				txa
				
				beq .3

				tay						Save !Byte count for later
				
.2				pla
				>PUSHA
				inx
				bne .2
				
				tya
	
.3				>PUSHA					push CPU Stack BC to restore on top of Soft Stack

				inc $1fe				PC=PC+1
				bne .4
				inc $1ff				because of RTI
				
.4				lda (pPs)
				ora #S.PS.F.SLEEP
				sta (pPs)
				
				lda #0					cld,clc,cli
				pha
				rti						exit to kernel with CC
*--------------------------------------
*     *** MUST BE REINTRANT ***
*--------------------------------------
GP.SysCall		dec IRQ.InKernel

				pha
				phy
				ldy #S.PS.A
				sta (pPs),y
				
				txa
				iny						#S.PS.X
				sta (pPs),y
				
				pla
				iny						#S.PS.Y
				sta (pPs),y
				
				tay
				pla
				
				jsr K.SYSCALL2
				bcc .2					no error quit...
				
				tax						CS,A=0 ?
				beq .3					Yes, BLOCKING I/O

.2				inc IRQ.InKernel
				rts						Unmodified Carry

.3				pla						get PC LO
				plx						get PC HI				
*				sec
				sbc #2					move back JSR GP.SysCall -3 (jsr $BF00) +1 (RTI) 
				bcs .4
				
				dex
				
.4				inc IRQ.InKernel
				bra GP.Sleep2
*--------------------------------------
GP.LibCall		dec IRQ.InLib

				pha						No need to save X, K.GetMemPtr will leave it unmodified
				tya						Get LIB hMem in A
				jsr K.GetMemPtr			Get LIB Code Segment (MemMgr in $E000, no BNK change)
				>STYA .1+1
				pla
.1				jsr $FFFF				SELF MODIFIED

GP.LibCall.8	inc IRQ.InLib			
GP.LibCall.RTS	rts
*--------------------------------------
GP.AtkCall		dec IRQ.InKernel

				>STYA .1
				jsr GO.ProDOS
				jsr MLI
				.DA #MLIATALK
.1				.DA *
				jsr GO.A2osX
				
				inc IRQ.InKernel
				rts
*/--------------------------------------
* # FAdd,FSub,FMult,FDiv,FPwr
* Return X+Y, X-Y, X*Y, X/Y, X^Y
* ## ASM
* **In:**
* `>PUSHF X (float)`
* `>PUSHF Y (float)`
* `>FPU fadd`
* `>FPU fsub`
* `>FPU fmult`
* `>FPU fdiv`
* `>FPU fpwr`
* ## RETURN VALUE
*  On stack (float)
*\--------------------------------------
*/--------------------------------------
* # Log,Sqr,Exp,Cos,Sin,Tan,ATan
* Return Log(x), Sqr(x), E^X, Cos(x), Sin(X), Tan(x), ATan(x)
* ## C
* `float log ( float x);`
* `float sqr ( float x);`
* `float exp ( float x);`
* `float cos ( float x);`
* `float sin ( float x);`
* `float tan ( float x);`
* `float atan ( float x);`
* ## ASM
* **In:**
* `>PUSHF x (Float)`
* `>FPU log`
* ## RETURN VALUE
*  On stack (Float)
*\--------------------------------------
* >PUSHL ARG
* >PUSHL ACC
* >FPU ADD32
* >PULLL (ARG+ACC)
*--------------------------------------
MATH.ADD32		clc
				.HS B0					BCS
MATH.SUB32		sec
				
				php
				
				jsr MATH.PopACC32

				ldy #0
				ldx #3
				
				plp
				bcs .2
				
.1				lda (pStack),y
				adc ACC32,y
				sta (pStack),y
				iny
				dex
				bpl .1
				
				rts
				
.2				lda (pStack),y
				sbc ACC32,y
				sta (pStack),y
				iny
				dex
				bpl .2
				
MATH.SUB32.RTS	rts
*--------------------------------------
* >PUSHL ARG
* >PUSHL ACC
* >(I)MUL32
* >PULLL (ARG*ACC)
*--------------------------------------
MATH.UMUL32		clc
				.HS B0					BCS
MATH.IMUL32		sec

				php
				jsr MATH.MULDIVMOD.COMMON
				jsr MATH.MUL32

				plp
				bcc MATH.SUB32.RTS
				
MATH.RETURN.ITMP
				lda ACC32.Sign
				eor ARG32.Sign
				bpl MATH.PutTMP32
				bra MATH.PutNotTMP32
*--------------------------------------
* >PUSHL ARG
* >PUSHL ACC
* >(I)DIV32
* >PULLL (ARG / ACC)
*--------------------------------------
* >PUSHL ARG
* >PUSHL ACC
* >(I)MOD32
* >PULLL (ARG mod ACC)
*--------------------------------------
MATH.UDIV32		clc
				.HS B0					BCS
MATH.IDIV32		sec
				clv
				bra MATH.DIVMOD
				
MATH.UMOD32		clc
				.HS B0					BCS
MATH.IMOD32		sec
				bit MATH.SUB32.RTS		$60

MATH.DIVMOD		php
				jsr MATH.MULDIVMOD.COMMON
				jsr MATH.DIVMOD32

				plp
				bcc .3
				bvs MATH.RETURN.ITMP	IMOD
				
				lda ACC32.Sign			IDIV
				eor ARG32.Sign
				bmi MATH.PutARG32
				bra MATH.PutNotARG32

.3				bvs MATH.PutARG32		DIV
*--------------------------------------
MATH.PutTMP32	lda #TMP32				MOD
				.HS 2C					BIT ABS
*--------------------------------------
MATH.PutARG32	lda #ARG32
				sta .1+1
				
				ldy #3
				
.1				lda $ff,y				SELF MODIFIED
				sta (pStack),y
				dey
				bpl .1

				rts
*--------------------------------------
MATH.PutNotTMP32
				lda #TMP32
				.HS 2C					BIT ABS
*--------------------------------------
MATH.PutNotARG32
				lda #ARG32
				sta .1+1
				
				ldy #0
				ldx #3
				
				sec

.1				lda $ff,y				SELF MODIFIED
				eor #$ff				two's complement of X bytes
				adc #0
				sta (pStack),y
				iny
				dex
				bpl .1
				
				rts
*--------------------------------------
MATH.PopACC32	ldy #$ff

.1				iny
				lda (pStack),y
				sta ACC32,y
				cpy #3
				bne .1
				
				sta ACC32.Sign
				
				tya
*				sec						Add 3+CS=4
				adc pStack
				sta pStack

				rts
*--------------------------------------
MATH.GetARG32	ldy #0

.1				lda (pStack),y
				sta ARG32,y
				iny
				cpy #4
				bne .1

				sta ARG32.Sign

				rts
*--------------------------------------
MATH.MULDIVMOD.COMMON
				php

				jsr MATH.PopACC32
				jsr MATH.GetARG32
				
				plp
				bcc .1
				
				jsr MATH.ACC32ABS
				jsr MATH.ARG32ABS

.1				rts
*/--------------------------------------
* # float
* Return 'floated' long
* ## C
* `float f = (float)12345678;
* ## ASM
* **In:**
*  `>PUSHL X` (long)
* ## RETURN VALUE
*  On stack (float)
*\--------------------------------------
*/--------------------------------------
* # lrintf
* Return float rounded into a long
* ## C
* `long int lrintf (float x);`
* ## ASM
* **In:**
* `>PUSHF x`
* `>SYSCALL lrintf`
* ## RETURN VALUE
*  On stack (long)
*\--------------------------------------
*--------------------------------------
GP.FpuCall		dec IRQ.InKernel
				jsr .1
				inc IRQ.InKernel

				clc
				rts
				
.1				cpx #16					< FADD ?
				bcc GP.RomCall.JmpX		INT32
				
				phx
				jsr GP.SetFAC			Get float from stack
								
				plx
				cpx #26					> FPWR ?
				bcs .2
*--------------------------------------
* FADD -> FPWR : 2 * float
*--------------------------------------
				lda pStack
				clc
				adc #5
				sta pStack
				
				phx
				jsr GP.SetARG
				plx
*--------------------------------------
* LOG -> ATAN : 1 * float
*--------------------------------------
.2				jsr GP.ROMCALL
			
GP.GETFAC.ON.STACK
				lda pStack
				ldy pStack+1
				
				sta FORPNT				Ptr to dst buffer
				sty FORPNT+1
				
				ldx #FPU.GETFAC
*--------------------------------------
GP.RomCall		phx
				ldx $D000
				stx .8+1
				
				bit	RROMBNK1
				
				plx
				jsr GP.RomCall.JmpX
				
.8				ldx #$ff
				bit $C000,x
				bit $C000,x
				
				rts
			
GP.RomCall.JmpX	jmp (.1,x)
				
.1				.DA MATH.ADD32
				.DA MATH.SUB32
				.DA MATH.UMUL32
				.DA MATH.IMUL32
				.DA MATH.UDIV32
				.DA MATH.IDIV32
				.DA MATH.UMOD32
				.DA MATH.IMOD32
				
* http://www.txbobsc.com/scsc/scdocumentor/E7A0.html

				.DA $E7C1				FADDT
				.DA $E7AA				FSUBT
				.DA $E987				FMULTT.1
				.DA $EA6B				FDIVT+2
				.DA $EE97				FPWRT

				.DA $E941				LOG
				.DA $EE8D				SQR
				.DA $EF09				EXP
				.DA $EFEA				COS
				.DA $EFF1				SIN
				.DA $F03A				TAN
				.DA $F09E				ATN

				.DA $E9E3				LOAD.ARG.FROM.YA
				.DA $EAF9				LOAD.FAC.FROM.YA
				
				.DA $EB27				SETFOR		(GETFAC)
				.DA $EBB2				FCOMP

				.DA $E82E				NORMALIZE.FAC.2 (L->F)
				.DA $EBF2				QINT		(F->L)

				.DA $EC4A				FIN			AToF
				.DA $ED36				FOUT.1		PrintF
*--------------------------------------
GP.SetARG		ldx #FPU.SETARG
				.HS 2C					BIT ABS
GP.SetFAC		ldx #FPU.SETFAC
				
				>LDYA pStack
				bra GP.ROMCALL
*--------------------------------------
K.Float			ldy #3

.1				lda (pStack),y
				sta FAC,y			Reverse Order
				dey
				bpl .1
				
				dec pStack				keep 5 bytes on stack
				
				stz	FAC.SIGN
				lda #$80+32
				sta FAC					Positive + Exp=32
				
				ldx #FPU.LTOF

MATH.RomCallPushFAC
				jsr GP.ROMCALL
				jmp GP.GETFAC.ON.STACK
*--------------------------------------
K.lrintf		jsr GP.SetFAC
				
				inc pStack				keep 4 bytes on stack
				
				ldx #FPU.QINT
				jsr GP.ROMCALL	

				ldy #3
				
.1				lda FAC+1,y
				sta (pStack),y
				dey
				bpl .1

				clc
				rts				
*--------------------------------------
GP.MLICall		stx .1
				sta K.MLI.PARAMS
				jsr GO.ProDOS
				jsr MLI
.1				.BS 1
				.DA K.MLI.PARAMS
				jsr GO.A2osX
				rts
*--------------------------------------
GO.ProDOS		pha
				lda $D000				We re coming from AUXLC, saving bank...
				sta GO.A2osX.BNK+1
				pla
				php
				clc
				.HS	2C					bit abs
				
GO.A2osX		php
				sec
				
				sei
				
				sta GO.EXIT.SaveA+1
				stx GO.EXIT.SaveX+1
				sty GO.EXIT.SaveY+1
				
				pla						Restore P in A for later
				
				plx						Get PC and add 1 for return
				ply
				inx
				bne .1
				iny
				
.1				stx GO.EXIT.JMP+1
				sty GO.EXIT.JMP+2

				bcs GO.A2osX.BNK		if CS, go AUXLC
				
				bit RRAMWRAMBNK1		Go MAINLC (ProDOS), always BNK1
				bit RRAMWRAMBNK1

				tsx
				stx A2osX.SaveSX
				ldx	A2osX.SaveSM
				txs
				sta CLRALTZP
				bra GO.EXIT

GO.A2osX.BNK	ldx #RRAMWRAMBNK1		Self Modified, initialized to BNK1 for INIT3

				bit $C000,x
				bit $C000,x
				
				sta SETALTZP
				tsx
				stx A2osX.SaveSM
				ldx	A2osX.SaveSX
				txs
*--------------------------------------
GO.EXIT			pha						push P on stack
GO.EXIT.SaveY	ldy #$ff
GO.EXIT.SaveX	ldx #$ff
GO.EXIT.SaveA	lda #$ff
				plp
GO.EXIT.JMP		jmp $FFFF				SELF MODIFIED
*--------------------------------------
* Called from ProDOS IRQ Manager (LCBNK1)
* A,X,Y, $FA->$FF Already Saved
* Main RAM,ZP/LC selected
* must begin with CLD
* must exit with RTS
* - CC if IRQ cleared, CS if NOT
*--------------------------------------
GP.IrqH			cld

				bit IRQ.SkipA2osX		After A2osX IRQ.H ?	
				bmi GP.IrqH.Exit
				
				sta SETALTZP			switch to aux LC
				tsx
				stx A2osX.SaveSM
				ldx	A2osX.SaveSX
				txs

GP.IrqH.JSR		jsr K.IrqH.DEV			SELF MODIFIED
				
				tsx						go back to Main
				stx A2osX.SaveSX
				ldx	A2osX.SaveSM
				txs
				sta CLRALTZP
				
				rts				
				
GP.IrqH.Exit	stz IRQ.SkipA2osX		reset flag
				sec
				rts
*--------------------------------------
CORE.VBLState	.BS 1
CORE.IRQMode	.BS 1
CORE.TickPerSec	.BS 1
CORE.TickPer10t	.BS 1
CORE.TickSec	.BS 1
CORE.Tick10t	.BS 1
CORE.CPUStatCnt	.DA #100
CORE.LastPSID	.DA #0
*--------------------------------------
DevMgr.Stat		.DA DevMgr.FreeMem
DevMgr.Free		.DA DevMgr.FreeMem
				.DA DevMgr.HiMem
DevMgr.DevIdx	.DA #1
*--------------------------------------
IRQ.InKernel	.BS 1
IRQ.InLib		.BS 1
IRQ.SkipA2osX	.BS 1

IRQ.IntNum		.BS 1
IRQ.VBL.n0		.BS 1
IRQ.VBL.0n		.BS 1
IRQ.Mode		.BS 1
IRQ.Tick		.BS 1
*--------------------------------------
IRQ.Vectors		.BS K.IRQDEV.MAX*2
*--------------------------------------
*GO.Reset		jsr GO.A2osX
*				jmp CORE.Run
*--------------------------------------
*BrkHandler		bra *
*--------------------------------------
GP.CodeEnd		.BS $BEE0-*
*--------------------------------------
*  $BEE0->$BEEF : Public Variables
*--------------------------------------
				.BS 16
*--------------------------------------
*  $BEF0->$BEFF : Kernel Config Block
*--------------------------------------
				.DA #6					A2osX.HZ=60hz
				.DA #2					A2osX.TTYDEVS=2
				.HS 000000000000
				.DA #0					ChRoot/Preemptive Disabled
				.HS 00000000000000		All Slots marked as "Free"
*--------------------------------------
GP.End			.EQ *
MAN
SAVE USR/SRC/SYS/KERNEL.S.GP
LOAD USR/SRC/SYS/KERNEL.S
ASM
