PR#3
PREFIX /A2OSX.SRC
NEW
INC 1
AUTO 6
				.LIST OFF
*--------------------------------------
* BIN.LoadExeYA
*  in :
*   A = hMem of FilePath (PSTRING)
* out :
*   Y,A = MEMPTR	
*   X = hMem of Code Segment
*--------------------------------------
BIN.LoadEXEYA	>STYA BIN.LoadExe.Filename
				jsr K.PStrUprYA			Y,A unmodified
				jsr K.GetMemByNameYA
				bcs BIN.LoadEXEYA.1		not already loaded

				>STYA ZPQuickPtr1		Save base address
				ldy #S.MEM.REFCNT
				lda (ZPQuickPtr1),y
				inc
				sta (ZPQuickPtr1),y
				
				txa
				jmp K.GetMemPtrA		X=hMem from K.GetMemByNameA
*--------------------------------------				
BIN.LoadEXEYA.1	>PUSHWI KrnBuf256
				>PUSHW BIN.LoadExe.Filename
				jsr K.STAT				Look for AUXTYPE
				bcs .9
				
				>LDYA KrnBuf256+S.STAT.AUXTYPE
				>STYA BIN.Relocate.Start

				>PUSHYA					Push AUXTYPE
				>PUSHBI 6				S.FILEINFO.TYPE.BIN
				>PUSHBI	SYS.FOPEN.R
				>PUSHW BIN.LoadExe.Filename
				jsr K.LoadFile
.9				bcs .99					Error Loading file
				
				>STYA BIN.Relocate.SegLen
				stx BIN.LoadExe.hMem		save hMem
				txa
				jsr K.GetMemPtrA
				>STYA ZPQuickPtr1
				
				ldy #H.BIN.CODE.LEN+1		get Code Len
				lda (ZPQuickPtr1),y
				tax
				dey
				lda (ZPQuickPtr1),y
				jsr BIN.Relocate.SetCodeLenAX
			
				lda BIN.Relocate.Start			Get AUXTYPE for actual Base Address
				clc
				adc BIN.Relocate.SegLen
				sta BIN.Relocate.End				compute Range End=AUXTYPE+FILELEN

				lda BIN.Relocate.Start+1
				adc BIN.Relocate.SegLen+1
				sta BIN.Relocate.End+1
				
				lda ZPQuickPtr1
				sec
				sbc BIN.Relocate.Start
				sta BIN.Relocate.Offset			Offset=ZPQuickPtr1-AUXTYPE
				
				lda ZPQuickPtr1+1
				sbc BIN.Relocate.Start+1
				sta BIN.Relocate.Offset+1
				
				jsr Bin.RelocateEXE
				bcs .98					relocation error, dicard Code segment
				
				>LDYA BIN.LoadExe.Filename	get back bin path
				jsr K.NewPStrYA			make a copy of this string
				bcs .98
				phx						save copy 
				
				lda BIN.LoadExe.hMem			
				jsr K.GetMemByIDA
				>STYA ZPQuickPtr1
				
				lda (ZPQuickPtr1) 
				ora #S.MEM.F.CODE		This is a code segment
				sta (ZPQuickPtr1)

				pla
				ldy #S.MEM.BIN
				sta (ZPQuickPtr1),y
							
				lda BIN.LoadExe.hMem		
				tax						return hMEM to Caller...
				jsr K.GetMemPtrA
				clc						...and Y,A=PTR to CS
				rts
				
.98				pha
				lda BIN.LoadExe.hMem	
				jsr K.FreeMemA			Discard Loaded Code
				pla
				
				sec
.99				rts
*--------------------------------------
BIN.LoadExe.Filename	.BS 2
BIN.LoadExe.hMem		.BS 1
*--------------------------------------
* BIN.InstallDRV
* pDrv = .DRV File Loaded Address
*--------------------------------------
BIN.InstallDRV	ldy #H.BIN.DRV.CODE.LEN+1
				lda (pDrv),y
				tax
				dey
				lda (pDrv),y
				jsr BIN.Relocate.SetCodeLenAX
				
				ldy #H.BIN.DRV.CODE.O
				lda (pDrv),y
				clc
				adc BIN.Relocate.Start		Advance start From Bin code to DRV code
				sta BIN.Relocate.Start
				iny
				lda (pDrv),y
				adc BIN.Relocate.Start+1
				sta BIN.Relocate.Start+1
				
				ldy #H.BIN.DRV.CODE.O
				lda	BIN.Relocate.SegLen
				sec
				sbc (pDrv),y
				sta K.InsDrv.DRVLen
				iny
				lda	BIN.Relocate.SegLen+1
				sbc (pDrv),y
				sta K.InsDrv.DRVLen+1	Compute DRV Len
				
				lda DevMgr.Free
				clc
				adc K.InsDrv.DRVLen
				sta K.InsDrv.DRVEnd
				lda DevMgr.Free+1
				adc K.InsDrv.DRVLen+1
				sta K.InsDrv.DRVEnd+1

				bcs .98					we crossed $FFFF, out of mem
				
				lda K.InsDrv.DRVEnd
				cmp #DevMgr.HiMem
				lda K.InsDrv.DRVEnd+1
				sbc /DevMgr.HiMem
				bcs .98					No More Room to load Driver....

				lda DevMgr.LastDevID
				inc
				cmp #K.DEV.MAX
				beq .99					No Device Handle Left
				
				sta DevMgr.LastDevID
				
				ldy	#H.BIN.DEV.HEADER.O
				lda (pDrv),y
				clc
				adc pDrv
				sta ZPQuickPtr1
				iny
				lda (pDrv),y
				adc pDrv+1
				sta ZPQuickPtr1+1

				ldy #S.DEV.JMP
				
				lda DevMgr.Free
				sec
				sbc (ZPQuickPtr1),y
				sta BIN.Relocate.Offset
				lda DevMgr.Free+1
				iny
				sbc (ZPQuickPtr1),y
				sta BIN.Relocate.Offset+1

				ldy #H.BIN.DRV.CODE.O
				lda (pDrv),y
				clc
				adc pDrv
				sta ZPQuickPtr1
				
				iny
				lda (pDrv),y
				adc pDrv+1
				sta ZPQuickPtr1+1
				
				jsr BIN.RelocateDRV
				
				jsr BIN.MoveDRV
				
				>LDYA K.InsDrv.DrvEnd
				>STYA DevMgr.Free
				clc
				rts
				
.98				lda #DEVMGR.ERROOM
				sec
				rts
				
.99				lda #DEVMGR.ERROOH
				sec
				rts
*--------------------------------------
BIN.MoveDRV		ldy	#H.BIN.DEV.HEADER.O
				lda (pDrv),y
				clc
				adc pDrv
				sta ZPQuickPtr1
				iny
				lda (pDrv),y
				adc pDrv+1
				sta ZPQuickPtr1+1

				ldy #S.DEV.JMP			Relocate Main JMP
				lda (ZPQuickPtr1),y
				clc
				adc BIN.Relocate.Offset
				sta (ZPQuickPtr1),y
				iny
				lda (ZPQuickPtr1),y
				adc BIN.Relocate.Offset+1
				sta (ZPQuickPtr1),y
				
				lda DevMgr.LastDevID
				jsr K.GetDevByIDA
				>STYA pDev
				
				ldy #S.DEV.SIZE			Make sure DevMgr.Table Ends with 0
				lda #0
				sta (pDev),y
				
				dey
				
.1				lda (ZPQuickPtr1),y		Copy DRV.Header
				sta (pDev),y
				dey
				bpl .1
				
				lda DevMgr.LastDevID	Save Dev.ID in the driver for SELECT
				ldy #S.DEV.ID
				sta (pDev),y
				
				ldy #H.BIN.DRV.CODE.O
				lda (pDrv),y
				clc
				adc pDrv
				sta ZPQuickPtr1
				iny 
				lda (pDrv),y
				adc pDrv+1
				sta ZPQuickPtr1+1		Make ZPQuickPtr1=DRV.CODE
				
				lda DevMgr.Free
				sta ZPQuickPtr2
				lda DevMgr.Free+1
				sta ZPQuickPtr2+1		Make ZPQuickPtr2=Dest Ram Location
				
				lda K.InsDrv.DrvLen+1
				eor #$ff
				pha
				lda K.InsDrv.DrvLen
				eor #$ff
				tax
				
				ldy #0
				
.2				inx
				bne .3
				pla
				inc
				beq .8
				pha
				
.3				lda (ZPQuickPtr1),y
				sta (ZPQuickPtr2),y
				iny
				bne .2
				
				inc ZPQuickPtr1+1
				inc ZPQuickPtr2+1
				bra .2
				
.8				rts						CC from last ADC
*--------------------------------------
K.InsDrv.DrvLen	.BS 2
K.InsDrv.DrvEnd	.BS 2
*--------------------------------------
BIN.Relocate.SetCodeLenAX
				eor #$ff
				sta BIN.Relocate.nCodeLen
				txa
				eor #$ff
				sta BIN.Relocate.nCodeLen+1
				rts
*--------------------------------------
* BIN.Relocate___ :
*  In :
*  ZPQuickPtr1 = Ptr to Code
*--------------------------------------
BIN.Relocate.SegLen		.BS 2			Code+Data Len
BIN.Relocate.Start		.BS 2
BIN.Relocate.End		.BS 2
BIN.Relocate.Offset		.BS 2
BIN.Relocate.nCodeLen	.BS 2			!Code length
*--------------------------------------
BIN.RelocateEXE	ldy #H.BIN.JMP			relocate Main JMP
				lda (ZPQuickPtr1),y
				clc
				adc BIN.Relocate.Offset
				sta (ZPQuickPtr1),y

				iny
				lda (ZPQuickPtr1),y
				adc BIN.Relocate.Offset+1
				sta (ZPQuickPtr1),y

				ldy #H.BIN.RELOC.TABLE	skip Header, CS.SIZE & DS.SIZE... (16 bytes)
				
				.HS 2C					bit abs
*--------------------------------------					
BIN.RelocateDRV	ldy #0
				
.1				lda (ZPQuickPtr1),y		Start Relocate JMP table
				tax						LO in X
				iny
				ora (ZPQuickPtr1),y		ORA with HI
				beq .2					$0000 = end of table
				
				dey
				txa						get back LO
				clc
				adc BIN.Relocate.Offset
				sta (ZPQuickPtr1),y

				iny
				lda (ZPQuickPtr1),y
				adc BIN.Relocate.Offset+1
				sta (ZPQuickPtr1),y

				iny

				bra .1
*--------------------------------------				
.2				tya						add current offset in Y to Ptr
				
				sec						+ 1 to skip last 00 from beq .2
				
				adc ZPQuickPtr1
				sta ZPQuickPtr1
				bcc .3	
				inc ZPQuickPtr1+1		ZPQuickPtr1=Current Code PTR
				
.3				inc BIN.Relocate.nCodeLen
				bne .4					nCodeLen reached 0 ?
				inc BIN.Relocate.nCodeLen+1
				beq .8					no, continue relocating
				
.4				lda (ZPQuickPtr1)		get OPCODE
				lsr						/2
				tax
				lda BIN.OPCODES,x		get OPCODE definition
				bcs .5					go get LO nibble
				lsr
				lsr						move HI -> LO
				lsr
				lsr
.5				and #$0f				
				
				bit #$8					abs addressing? 
				beq .7					no....
				
				and #7					save Opcode length...
				pha
				
				ldy #1
				lda (ZPQuickPtr1),y		Get LO
				tax						save LO in X
				
				iny						make Y point to HI

				cpx BIN.Relocate.Start
				lda (ZPQuickPtr1),y		Get HI
				sbc BIN.Relocate.Start+1
				bcc .6					addr < BIN.Relocate.Start, out of range
				
				txa						Get back LO
				cpx BIN.Relocate.End
				lda (ZPQuickPtr1),y		Get HI
				sbc BIN.Relocate.End+1
				bcs .6					addr > BIN.Relocate.End, out of range
				
				txa						Get back LO
*				clc						CC from bcs .6
				adc BIN.Relocate.Offset	add Offset to abs address
				dey
				sta (ZPQuickPtr1),y		store relocated addr LO
				iny
				lda (ZPQuickPtr1),y		Get HI
				adc BIN.Relocate.Offset+1
				sta (ZPQuickPtr1),y		store relocated addr HI
				
.6				pla						get back Opcode length...

.7				clc						A = OPCODE length
				adc ZPQuickPtr1
				sta ZPQuickPtr1
				bcc .3
				inc ZPQuickPtr1+1
				bra .3					next opcode....
				
.8				clc
				rts
*--------------------------------------
* 65C02 OPCODES
* Bit 3 	: 1 = absolute addressing
* Bit 2-1-0 : opcode + @ length
*--------------------------------------
*					0.1.2.3.4.5.6.7.8.9.A.B.C.D.E.F
BIN.OPCODES		.HS 1.2.2.1.2.2.2.2.1.2.1.1.B.B.B.3
				.HS 2.2.2.1.2.2.2.2.1.B.1.1.B.B.B.3
				.HS B.2.2.1.2.2.2.2.1.2.1.1.B.B.B.3
				.HS 2.2.2.1.2.2.2.2.1.B.1.1.B.B.B.3
				.HS 1.2.2.1.2.2.2.2.1.2.1.1.B.B.B.3
				.HS 2.2.2.1.2.2.2.2.1.B.1.1.1.B.B.3
				.HS 1.2.2.1.2.2.2.2.1.2.1.1.B.B.B.3
				.HS 2.2.2.1.2.2.2.2.1.B.1.1.B.B.B.3
				.HS 2.2.2.1.2.2.2.2.1.2.1.1.B.B.B.3
				.HS 2.2.2.1.2.2.2.2.1.B.1.1.B.B.B.3
				.HS 2.2.2.1.2.2.2.2.1.2.1.1.B.B.B.3
				.HS 2.2.2.1.2.2.2.2.1.B.1.1.B.B.B.3
				.HS 2.2.2.1.2.2.2.2.1.2.1.1.B.B.B.3
				.HS 2.2.2.1.2.2.2.2.1.B.1.1.1.B.B.3
				.HS 2.2.2.1.2.2.2.2.1.2.1.1.B.B.B.3
				.HS 2.2.2.1.2.2.2.2.1.B.1.1.1.B.B.3
*--------------------------------------
MAN
SAVE SYS/KERNEL.S.BIN
LOAD SYS/KERNEL.S
ASM
