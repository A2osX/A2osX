NEW
PREFIX
AUTO 4,1
*--------------------------------------
* LoadLib
*  in :
*   Y,A = PTR To "LibName.o" C-String
* out :
*   A = hMem To loaded LIB
*--------------------------------------
K.LoadLib		jsr BIN.FindLIB
				bcs .9

				jsr BIN.Load			Y,A = "/PATH/BIN"
				bcs .9
				
				stx .8+1
				>STYA .1+1

				txa						Pass hLib to LibLoad
				ldx #LIBMGR.LOAD
.1				jsr $ffff				Self Modified, Call LIB.LOAD function
				
				bcs .99

.8				lda #$ff				hLib
				clc
.9				rts
				
.99				pha
				lda .8+1
				jsr K.FreeMem
				pla
				
				sec
				rts
*--------------------------------------
* UnloadLib
*  in :
*   A = hMem To Lib
* out :
*--------------------------------------
K.UnloadLib		pha
				jsr K.GetMemByID
				>STYA ZPPtr1
				ldy #S.MEM.REFCNT
				lda (ZPPtr1),y			Get count of those referencing this lib
				dec						only one left ?	
				beq .1
				sta (ZPPtr1),y
				pla
				clc
				rts
				
.1				ldy #S.MEM.PTR
				lda (ZPPtr1),y
				sta .2+1
				
				iny
				lda (ZPPtr1),y
				sta .2+2
				
				ldx #LIBMGR.UNLOAD
.2				jsr $ffff				Self Modified, Call LIB.UNLOAD function
				pla
				jmp K.FreeMem
*/--------------------------------------
* # LoadDrv
* ## ASM
* **In:**
*  Y,A = PTR to "NAME.DRV [PARAM]" C-String
* ## RETURN VALUE
* none
*\--------------------------------------
K.LoadDrv		>STYA .2+1				Save "BIN\0ARGS\0\0"

				jsr BIN.FindDRV
				bcs .9

				jsr BIN.Load			Y,A = "/PATH/BIN"
				bcs .9
				
				>STYA .3+1
				stx .97+1

				ldx #$ff
			
.1				inx						Skip "BIN"
.2				lda $ffff,x
				bne .1
				
				txa
				sec
				adc .2+1
				tay
				lda #0
				adc .2+2				Y,A = ARGS
				
.3				jsr $ffff				SELF MODIFIED, call Dev.Detect
				bcs .96
				
				jsr .96					Cleanup...
				
				lda #0					Make sure RC = 0 if success
				clc
.9				rts
				
.96				pha
				
.97				lda #$ff
				jsr K.FreeMem
				pla
				sec
				rts	
*--------------------------------------
BIN.FindLIB		clc
				.HS B0					bcs			
BIN.FindDRV		sec

				>STYA BIN.CmdLine
				
				>LDYAI BIN.Find.ENV.LIB
				bcc .1
				>LDYAI BIN.Find.ENV.DRV
				
.1				jsr K.GetEnv			get value for Search Path
				bcs .9
				
				>STYA K.FileSearch.SearchPath

				>LDYA BIN.CmdLine
				
				jsr K.FileSearch.YA		find LIB/DRV in Search
				bcs .9
				
				>LDYAI K.Buf256
				clc
.9				rts
*--------------------------------------
BIN.Find.ENV.DRV	.AZ "DRV"
BIN.Find.ENV.LIB	.AZ "LIB"
*--------------------------------------
* BIN.Load
*  in :
*   Y,A = /BIN/PATH (CSTR)
* out :
*   Y,A = MEMPTR	
*   X = hMem of Code Segment
*--------------------------------------
BIN.Load		>STYA BIN.CmdLine
				>STYA .2+1
				
				>LDYAI Mem.Table
				>STYA ZPPtr1		

				ldx #0					we will skip Slot 0...
				
.1				cpx Mem.LastSlot
				beq BIN.Load.1

				inx
				
				lda ZPPtr1
				clc
				adc #S.MEM
				sta ZPPtr1
				bcc .11
				inc ZPPtr1+1
				
.11				lda (ZPPtr1)
				bpl .1					In Use?
				
				ldy #S.MEM.BIN			any BIN PATH in this slot?	
				lda (ZPPtr1),y
				beq .1
				
				jsr K.GetMemPtr			X unmodified, get pathname
				>STYA .3+1

				ldy #0
				
.2				lda $ffff,y				SELF MODIFIED
.3				cmp $ffff,y				SELF MODIFIED
				bne .1
				iny
				ora #0
				bne .2
				
				ldy #S.MEM.REFCNT
				lda (ZPPtr1),y
				inc
				sta (ZPPtr1),y			

				ldy #S.MEM.PTR
				lda (ZPPtr1),y
				pha
				iny
				lda (ZPPtr1),y
				ply

				clc
				rts						X=hMem, Y,A=Ptr
*--------------------------------------				
BIN.Load.1		>PUSHWI K.S.STAT
				>LDYA BIN.CmdLine
				>SYSCALL STAT			BANK1!!! Look for AUXTYPE
				bcs .9
				
				>LDYA K.S.STAT+S.STAT.P.AUXTYPE
				>STYA BIN.R.CS.Start

				>PUSHYA					Push AUXTYPE
				>PUSHBI S.FI.T.BIN
				>PUSHBI	O.RDONLY
				>LDYA BIN.CmdLine

				>SYSCALL LoadFile		BANK1!!! 
.9				bcs .99					Error Loading file

				stx BIN.hMem			save hMem
				
				pha						YA=CODE+DATA size
				tya
*				clc						CC from bcs .99				

				adc BIN.R.CS.Start		Get AUXTYPE for actual Base Address
				sta BIN.R.End			compute Range End=AUXTYPE+FILELEN
				pla
				adc BIN.R.CS.Start+1
				sta BIN.R.End+1

				txa
				jsr K.GetMemPtr
				>STYA ZPPtr1			set ZPPtr1 -> Code start

				pha						YA = actual load address
				tya
				sec
				sbc BIN.R.CS.Start
				sta BIN.R.Offset		Offset=ZPPtr1-AUXTYPE
				pla
				sbc BIN.R.CS.Start+1
				sta BIN.R.Offset+1
				
				ldy #H.BIN.CS.SIZE		get Code Len
				lda (ZPPtr1),y
				clc
				adc BIN.R.CS.Start
				sta BIN.R.CS.End		ZPPtr1 + CodeLen
				iny
				lda (ZPPtr1),y
				adc BIN.R.CS.Start+1
				sta BIN.R.CS.End+1
				
				jsr BIN.RelExe
				
				>LDYA BIN.CmdLine		get back bin path
				jsr K.NewStr			make a copy of this string
				bcs .98
				
				lda BIN.hMem			Keep X=hMem		
				jsr K.GetMemByID		X unmodified
				>STYA ZPPtr1
				
				lda (ZPPtr1) 
				ora #S.MEM.F.CODE		This is a code segment
				sta (ZPPtr1)

				txa						Get Back hMem
				ldy #S.MEM.BIN
				sta (ZPPtr1),y
							
				lda BIN.hMem		
				tax						return hMEM to Caller...
				jmp K.GetMemPtr			...and Y,A=PTR to CS
				
.98				pha
				lda BIN.hMem	
				jsr K.FreeMem			Discard Loaded Code
				pla
				
				sec
.99				rts
*--------------------------------------
BIN.CmdLine		.BS 2
BIN.hMem		.BS 1
*/--------------------------------------
* # InsDrv
* ## C
* `void * insdrv (void * src, void * crvcsstart, void * drvcsend, void * drvend);`
* ## ASM
* **In:**
* `>PUSHW DRV.END`
* `>PUSHW DRV.CS.END`
* `>PUSHW DRV.CS.START`
* `>LDYA L.SRC`
* `SYSCALL insdrv`
* ## RETURN VALUE
* Y,A = Ptr to installed driver
*\--------------------------------------
K.InsDrv		>STYA ZPPtr1

				>PULLW BIN.R.CS.Start
				>PULLW BIN.R.CS.End
				>PULLW BIN.R.End

				lda	BIN.R.End			Compute DRVLen=End-start
				sec
				sbc BIN.R.CS.Start
				sta BIN.Move.Len
				
				lda BIN.R.End+1
				sbc BIN.R.CS.Start+1
				sta BIN.Move.Len+1
				
				lda DevMgr.Free			Compute new DevMgr.Free
				clc
				adc BIN.Move.Len
				tay						Save DRVEnd LO
				lda DevMgr.Free+1
				adc BIN.Move.Len+1		A = DRVEnd HI
				
				bcs .9					we crossed $FFFF, out of mem
				
				cpy #DevMgr.HiMem
				sbc /DevMgr.HiMem
				bcs .9					No More Room to load Driver....

				>LDYA DevMgr.Free
				jsr BIN.MoveToYA
				
				lda DevMgr.Free
				sta ZPPtr1
				sec
				sbc BIN.R.CS.Start
				sta BIN.R.Offset
				
				lda DevMgr.Free+1
				sta ZPPtr1+1
				sbc BIN.R.CS.Start+1
				sta BIN.R.Offset+1

				jsr BIN.RelDrv
				
				lda DevMgr.Free
				tay
				clc
				adc BIN.Move.Len
				sta DevMgr.Free
				lda DevMgr.Free+1
				pha
				adc BIN.Move.Len+1
				sta DevMgr.Free+1
				pla
				
				clc
				rts

.9				lda #E.OOM
				sec
				rts				
*--------------------------------------
BIN.Move.Len	.BS 2
*--------------------------------------
BIN.MoveToYA	>STYA ZPPtr2

				lda BIN.Move.Len+1
				eor #$ff
				pha
				lda BIN.Move.Len
				eor #$ff
				tax
				
				ldy #0
				
.1				inx
				bne .2
				pla
				inc
				beq .3
				pha
				
.2				lda (ZPPtr1),y
				sta (ZPPtr2),y
				iny
				bne .1
				
				inc ZPPtr1+1
				inc ZPPtr2+1
				bra .1
				
.3				rts
*--------------------------------------
* BIN.Rel___ :
*--------------------------------------
BIN.R.CS.Start	.BS 2
BIN.R.CS.End	.BS 2
BIN.R.End		.BS 2
BIN.R.Offset	.BS 2
*--------------------------------------
BIN.RelExe		ldy #H.BIN.T+1
				lda (ZPPtr1),y
				cmp /H.BIN.T.BIN65
				beq .1
				cmp /H.BIN.T.DRV65
				beq .1
				
				lda #E.IBIN
				sec
				rts
				
.1				ldy #H.BIN.JMP			relocate Main JMP
				lda (ZPPtr1),y
				clc
				adc BIN.R.Offset
				sta (ZPPtr1),y

				iny
				lda (ZPPtr1),y
				adc BIN.R.Offset+1
				sta (ZPPtr1),y

				ldy #H.BIN.EXE.REL.TABLE	skip Header, CS.SIZE & DS.SIZE... (16 bytes)
		
				.HS 2C					bit abs
*--------------------------------------					
BIN.RelDrv		ldy #H.BIN.DRV.REL.TABLE

.1				lda (ZPPtr1),y			Start Relocate JMP table
				tax						LO in X
				iny
				lda (ZPPtr1),y			HI in A
				beq .2					$00xx = end of table
				
				cpx BIN.R.CS.Start
				sbc BIN.R.CS.Start+1
				bcc .11					addr < BIN.R.CS.Start, out of range
				
				txa						Get back LO
				cpx BIN.R.End
				lda (ZPPtr1),y			Get HI
				sbc BIN.R.End+1
				bcs .11					addr > BIN.R.End, out of range

				dey
				txa						get back LO
				clc
				adc BIN.R.Offset
				sta (ZPPtr1),y

				iny
				lda (ZPPtr1),y
				adc BIN.R.Offset+1
				sta (ZPPtr1),y

.11				iny

				bra .1
*--------------------------------------				
.2				tya						add current offset in Y to Ptr
				
				sec						+ 1 to skip last 00 from beq .2
				
				adc ZPPtr1
				sta ZPPtr1
				bcc .3	
				inc ZPPtr1+1			ZPPtr1=Current Code PTR

.3				lda BIN.R.CS.End		compute new CS.END to stop relocating
				clc
				adc BIN.R.Offset
				sta .7+1

				lda BIN.R.CS.End+1
				adc BIN.R.Offset+1
				sta .71+1
				
				lda (ZPPtr1)			get OPCODE
				lsr						/2
				tax
				lda BIN.65816,x			get OPCODE definition
				bcs .4					go get LO nibble
				lsr
				lsr						move HI -> LO
				lsr
				lsr
.4				and #$0f				
				
				bit #$8					abs addressing? 
				beq .6					no....
				
				and #7					save Opcode length...
				pha
				
				ldy #1
				lda (ZPPtr1),y			Get LO
				tax						save LO in X
				
				iny						make Y point to HI
				lda (ZPPtr1),y			Get HI

				cpx BIN.R.CS.Start
				sbc BIN.R.CS.Start+1
				bcc .5					addr < BIN.R.CS.Start, out of range
				
				txa						Get back LO
				cpx BIN.R.End
				lda (ZPPtr1),y			Get HI
				sbc BIN.R.End+1
				bcs .5					addr > BIN.R.End, out of range
				
				txa						Get back LO
*				clc						CC from bcs .6
				adc BIN.R.Offset		add Offset to abs address
				dey
				sta (ZPPtr1),y			store relocated addr LO
				iny
				lda (ZPPtr1),y			Get HI
				adc BIN.R.Offset+1
				sta (ZPPtr1),y			store relocated addr HI
				
.5				pla						get back Opcode length...

.6				clc						A = OPCODE length
				adc ZPPtr1
				sta ZPPtr1
				bcc .7
				inc ZPPtr1+1
				
.7				eor #$ff				SELF MODIFIED	A = ZPPtr1
				bne .3
				lda ZPPtr1+1
.71				eor #$ff				SELF MODIFIED
				bne .3					next opcode....
				
.8				rts
*--------------------------------------
* 6502/65C02/65816 OPCODES
* Bit 3 	: 1 = absolute addressing
* Bit 2-1-0 : opcode + @ length
*--------------------------------------
*					0.1.2.3.4.5.6.7.8.9.A.B.C.D.E.F
BIN.65816		
*	TO DO : Make 2 different tables
* http://axis.llx.com/~nparker/a2/opcodes.html
*--------------------------------------
* 65R02 OPCODES
*--------------------------------------
*					0.1.2.3.4.5.6.7.8.9.A.B.C.D.E.F
BIN.65R02		.HS 1.2.2.1.2.2.2.2.1.2.1.1.B.B.B.3
				.HS 2.2.2.1.2.2.2.2.1.B.1.1.B.B.B.3
				.HS B.2.2.1.2.2.2.2.1.2.1.1.B.B.B.3
				.HS 2.2.2.1.2.2.2.2.1.B.1.1.B.B.B.3
				.HS 1.2.2.1.2.2.2.2.1.2.1.1.B.B.B.3
				.HS 2.2.2.1.2.2.2.2.1.B.1.1.1.B.B.3
				.HS 1.2.2.1.2.2.2.2.1.2.1.1.B.B.B.3
				.HS 2.2.2.1.2.2.2.2.1.B.1.1.B.B.B.3
				.HS 2.2.2.1.2.2.2.2.1.2.1.1.B.B.B.3
				.HS 2.2.2.1.2.2.2.2.1.B.1.1.B.B.B.3
				.HS 2.2.2.1.2.2.2.2.1.2.1.1.B.B.B.3
				.HS 2.2.2.1.2.2.2.2.1.B.1.1.B.B.B.3
				.HS 2.2.2.1.2.2.2.2.1.2.1.1.B.B.B.3
				.HS 2.2.2.1.2.2.2.2.1.B.1.1.1.B.B.3
				.HS 2.2.2.1.2.2.2.2.1.2.1.1.B.B.B.3
				.HS 2.2.2.1.2.2.2.2.1.B.1.1.1.B.B.3
*--------------------------------------
MAN
SAVE USR/SRC/SYS/KERNEL.S.BIN
LOAD USR/SRC/SYS/KERNEL.S
ASM
