NEW
  AUTO 3,1
*/--------------------------------------
* # open
* ## C
* `hFD open(const char *pathname, short int flags);`
* ## ASM
* **In:**
* `>PUSHB flags`
* `>LDYA pathname`
* `>SYSCALL open`
* ## RETURN VALUE
* A = hFD
* REG File created on ProDOS : T=TXT,X=$0000
*\--------------------------------------
				.DUMMY
				.OR ZPTMP+20			7 Bytes
IO.Open.FLAGS	.BS 1
IO.Open.TYPE	.BS 1
IO.Open.AUXTYPE	.BS 2
IO.hFD			.BS 1
				.ED
*--------------------------------------		
K.Open			jsr PFT.YAToMLIPATH
				>PULLB IO.Open.FLAGS

				lda #S.FI.T.TXT
				sta IO.Open.TYPE
				stz IO.Open.AUXTYPE
				stz IO.Open.AUXTYPE+1
*--------------------------------------
UNISTD.Open		ldx #5					/DEV/ 
				cpx K.MLI.PATH
				bcs IO.OPEN.REG

.1				lda K.MLI.PATH,x
				cmp DEV.FIFO-1,x
				bne IO.OPEN.REG
				dex
				bne .1
*--------------------------------------		
* /DEV/xxxxxx (CDEV,BDEV,LNK,DSOCK,SSOCK,PIPE)
*--------------------------------------		
				>LDYAI K.MLI.PATH+6		skip $/DEV/

				jsr K.GetDevByName
				bcc .7
				
				ldx #2
.10				lda Nod.Table.hPath-2,x
				beq .3

				jsr K.GetMemPtr
				>STYA ZPPtr1
				
				ldy #0

.2				lda (ZPPtr1),y
				iny
				cmp K.MLI.PATH,y
				bne .3
				
				cmp #0					end of string ?

				bne .2

				lda Nod.Table.hFD-2,x		return hFD
				jsr UNISTD.GetPFD
				bra .71
				
.3				inx
				cpx #K.NOD.MAX+2
				bne .10
				
				lda #MLI.E.NODEV
*				sec
				rts						no OF found
*--------------------------------------		
.7				stx IO.hFD
				>STYA pFD

.71				lda (pFD)				#S.FD.T
				tax
				jmp (.8-4,x)
.8
*				.DA STDIO.IOERR			REG
*				.DA STDIO.IOERR			DIR
				.DA IO.OPEN.CDEV
				.DA IO.OPEN.BDEV
				.DA STDIO.IOERR			LNK
				.DA IO.OPEN.DSOCK
				.DA IO.OPEN.SSOCK
				.DA IO.OPEN.PIPE
*--------------------------------------
IO.OPEN.REG		>MLICALL MLIGETFILEINFO
				bcc IO.OPEN.REG.E		Already Exists

				bit IO.Open.FLAGS		Create if not exists ?
				bpl IO.OPEN.RTS			No, return MLI error

				ldx #2					Yes, Create...

.1				lda IO.Open.TYPE,x
				sta K.MLI.PARAMS+4,x	File type,Aux type
				dex
				bpl .1

				lda #S.FI.ST.STD
				jsr IO.MLI.CREATE
				bcs IO.OPEN.RTS

IO.OPEN.REG.E	ldx #0
				jsr IO.MkFD
				bcs IO.OPEN.RTS

				jsr IO.MLI.OPEN
				bcs UNISTD.Open.ERR

				lda IO.Open.FLAGS
				bit #O.WRONLY
				beq .20					Write mode ?

				and #O.APPEND			Append ?
				bne .11					yes, go to end of file

				stz K.MLI.PARAMS+2
				stz K.MLI.PARAMS+3
				stz K.MLI.PARAMS+4
				>MLICALL MLISETEOF		no, reset size to 0
				bra .21

.11				>MLICALL MLIGETEOF
				bcs UNISTD.Open.ERR

				>MLICALL MLISETMARK
.21				bcs UNISTD.Open.ERR

.20				lda IO.Open.FLAGS
				and #O.TEXT				Text Mode ?
				beq .8

				lda #$FF
				sta K.MLI.PARAMS+2
				lda #C.CR
				sta K.MLI.PARAMS+3
				>MLICALL MLINEWLINE
				bcs UNISTD.Open.ERR

.8				lda IO.hFD
IO.OPEN.RTS		rts

UNISTD.Open.ERR	pha						Save Error Code
				lda IO.hFD
				jsr K.Close
				pla
				sec
				rts
*/--------------------------------------
* # close
* ## C
* `int close(hFD fd);`
* ## ASM
* **In:**
* `lda fd`
* `>SYSCALL close`
*\--------------------------------------
K.Close			jsr UNISTD.GetPFD

UNISTD.Close	lda (pFD)				#S.FD.T
				tax
				jmp (.1,x)
.1				.DA IO.CLOSE.REG
				.DA IO.CLOSE.DIR
				.DA IO.CLOSE.CDEV
				.DA IO.CLOSE.BDEV
				.DA STDIO.IOERR			LNK
				.DA IO.CLOSE.DSOCK
				.DA IO.CLOSE.SSOCK
				.DA IO.CLOSE.PIPE
*/--------------------------------------
* # read
* ## C
* `int read(hFD fd, void *buf, int count);`
* ## ASM
* **In:**
* `>PUSHWI count`
* `>PUSHW buf`
* `lda fd`
* `>SYSCALL read`
* ## RETURN VALUE
* CC: Y,A = bytes read
* CS: A = EC
*\--------------------------------------
K.Read			jsr UNISTD.GetPFD

UNISTD.Read		lda (pFD)				#S.FD.T
				tax
				jmp (.1,x)
.1				.DA IO.READ.REG
				.DA STDIO.IOERR			DIR
				.DA IO.READ.CDEV
				.DA STDIO.IOERR			BDEV
				.DA STDIO.IOERR			LNK
				.DA STDIO.IOERR			DSOCK
				.DA IO.READ.SSOCK
				.DA IO.READ.PIPE
*/--------------------------------------
* # write
* ## C
* `int write(hFD fd, const void *buf, int count);`
* ## ASM
* **In:**
* `>PUSHWI count`
* `>PUSHW buf`
* `lda fd`
* `>SYSCALL write`
* ## RETURN VALUE
* CC: Y,A = bytes written
* CS: A = EC
*\--------------------------------------
K.Write			jsr UNISTD.GetPFD

UNISTD.Write	lda (pFD)				#S.FD.T
				tax
				jmp (.1,x)
.1				.DA IO.WRITE.REG
				.DA STDIO.IOERR			DIR
				.DA IO.WRITE.CDEV
				.DA STDIO.IOERR			BDEV
				.DA STDIO.IOERR			LNK
				.DA STDIO.IOERR			DSOCK
				.DA IO.WRITE.SSOCK
				.DA IO.WRITE.PIPE
*--------------------------------------
UNISTD.GetPFD	sta IO.hFD
				jsr K.GetMemPtr
				>STYA pFD
				rts
*--------------------------------------
DEV.FIFO		.AS "/dev/fifo"			STAT,UNISTD
*/--------------------------------------
* # ChOwn
* ## C
*  `short int chown(const char *pathname, short int owner, short int group);`
* ## ASM
* **In:**
* `>PUSHW pathname`
* `>PUSHB owner`
* `>PUSHB group`
* `>SYSCALL chown`
* ## RETURN VALUE
*\--------------------------------------
K.ChOwn			clc
				rts
*--------------------------------------
MAN
SAVE USR/SRC/SYS/KERNEL.S.UNISTD
LOAD USR/SRC/SYS/KERNEL.S
ASM
