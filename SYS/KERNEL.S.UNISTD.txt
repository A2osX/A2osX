NEW
  AUTO 3,1
*/--------------------------------------
* # open
* ## C
* `hFD open(const char *pathname, short int flags);`
* ## ASM
* **In:**
* `>PUSHB flags`
* `>LDYA pathname`
* `>SYSCALL open`
* ## RETURN VALUE
* A = hFD
* REG File created on ProDOS : T=TXT,X=$0000
*\--------------------------------------
K.Open			jsr PFT.YAToMLIPATH
				>PULLB IO.Open.FLAGS

				lda #S.FI.T.TXT
				sta IO.Open.TYPE
				stz IO.Open.AUXTYPE
				stz IO.Open.AUXTYPE+1
*--------------------------------------
IO.Open			ldx #5					/dev/
				cpx K.MLI.PATH
				bcs .8

.1				lda K.MLI.PATH,x
				cmp IO.DEV-1,x
				bne .8
				dex
				bne .1
*--------------------------------------
* /DEV/xxxxxx (CDEV,BDEV,DSOCK,SSOCK,PIPE)
*--------------------------------------
				>LDYAI K.MLI.PATH+6		skip $/dev/

				jsr K.GetDevByName
				bcs .9
*--------------------------------------
				stx IO.hDevNod			pFD set by GetDevByName

				lda (pFD)				#S.FD.T
				tax

				jmp (.2-2,x)
.2
*				.DA STDIO.IOERR			REG
				.DA STDIO.IOERR			DIR
				.DA IO.OPEN.DEV
				.DA IO.OPEN.DEV
				.DA STDIO.IOERR			LNK
				.DA IO.OPEN.SOCK
				.DA IO.OPEN.SOCK
				.DA IO.OPEN.PIPE

.8				jmp FS.OPEN.REG

.9				rts
*/--------------------------------------
* # close
* ## C
* `int close(hFD fd);`
* ## ASM
* **In:**
* `lda fd`
* `>SYSCALL close`
*\--------------------------------------
K.Close			jsr DEV.GetPFD

IO.Close		lda (pFD)				#S.FD.T
				tax
				jmp (.1,x)
.1				.DA FS.CLOSE.REG
				.DA FS.CLOSE.DIR
				.DA IO.CLOSE.DEV
				.DA IO.CLOSE.DEV
				.DA STDIO.IOERR			LNK
				.DA IO.CLOSE.SOCK
				.DA IO.CLOSE.SOCK
				.DA IO.CLOSE.PIPE
*/--------------------------------------
* # read
* ## C
* `int read(hFD fd, void *buf, int count);`
* ## ASM
* **In:**
* `>PUSHWI count`
* `>PUSHW buf`
* `lda fd`
* `>SYSCALL read`
* ## RETURN VALUE
* CC: Y,A = bytes read
* CS: A = EC
*\--------------------------------------
K.Read			jsr DEV.GetPFD

IO.Read			lda (pFD)				#S.FD.T
				tax
				jmp (.1,x)
.1				.DA FS.READ.REG
				.DA STDIO.IOERR			DIR
				.DA IO.READ.CDEV
				.DA STDIO.IOERR			BDEV
				.DA STDIO.IOERR			LNK
				.DA STDIO.IOERR			DSOCK
				.DA IO.READ.SSOCK
				.DA IO.READ.PIPE
*/--------------------------------------
* # write
* ## C
* `int write(hFD fd, const void *buf, int count);`
* ## ASM
* **In:**
* `>PUSHWI count`
* `>PUSHW buf`
* `lda fd`
* `>SYSCALL write`
* ## RETURN VALUE
* CC: Y,A = bytes written
* CS: A = EC
*\--------------------------------------
K.Write			jsr DEV.GetPFD

IO.Write		lda (pFD)				#S.FD.T
				tax
				jmp (.1,x)
.1				.DA FS.WRITE.REG
				.DA STDIO.IOERR			DIR
				.DA IO.WRITE.CDEV
				.DA STDIO.IOERR			BDEV
				.DA STDIO.IOERR			LNK
				.DA STDIO.IOERR			DSOCK
				.DA IO.WRITE.SSOCK
				.DA IO.WRITE.PIPE
*--------------------------------------
IO.OPEN.DEV		ldx #IOCTL.OPEN
				lda IO.hDevNod
				jsr DEV.pDrvJmp
				bcs IO.RTS
*--------------------------------------
IO.OPEN.SOCK	lda IO.hDevNod
				clc
				rts
*--------------------------------------
IO.CLOSE.DEV	ldx #IOCTL.CLOSE
				lda IO.hDevNod
				jmp DEV.pDrvJmp
*--------------------------------------
IO.READ.CDEV	ldx #IOCTL.READ
				.HS 2C					BIT ABS
*--------------------------------------
IO.WRITE.CDEV	ldx #IOCTL.WRITE

				>PULLW K.S.IOCTL+S.IOCTL.BUFPTR
				>PULLW K.S.IOCTL+S.IOCTL.BYTECNT
				
				>LDYAI K.S.IOCTL
				jsr DEV.pDrvJmp
				bcs IO.RTS

				>LDYA K.S.IOCTL+S.IOCTL.BYTECNT

IO.RTS			rts
*--------------------------------------
IO.CLOSE.SOCK	ldy #S.FD.SSOCK.CLOSE
				.HS 2C					BIT ABS
*--------------------------------------
IO.EOF.SSOCK	ldy #S.FD.SSOCK.EOF
				.HS 2C					BIT ABS
*--------------------------------------
IO.READ.SSOCK	ldy #S.FD.SSOCK.READ
				.HS 2C					BIT ABS
*--------------------------------------
IO.WRITE.SSOCK	ldy #S.FD.SSOCK.WRITE

				lda (pFD),y
				tax						Function Offset in LIB

				ldy #S.FD.SSOCK.IOH
				lda (pFD),y
				jsr K.GetMemPtr
				>STYA .1+1
				lda	IO.hFD
.1				jmp $FFFF				SELF MODIFIED
*--------------------------------------
IO.EOF.CDEV		lda #S.IOCTL.S.EOF
				jmp DEV.GetDevStatus
*/--------------------------------------
* # ChOwn
* ## C
*  `short int chown(const char *pathname, short int owner, short int group);`
* ## ASM
* **In:**
* `>PUSHW pathname`
* `>PUSHB owner`
* `>PUSHB group`
* `>SYSCALL chown`
* ## RETURN VALUE
*\--------------------------------------
K.ChOwn			jsr PFT.CheckPath2
				bcs	.9
				
				stz K.MLI.PARAMS+3+S.FIEX.ACL		read mode
				
				>MLICALL MLIACL
				bcs .9
				
				lda (pStack)
				bmi .1

				sta K.MLI.PARAMS+3+S.FIEX.ACL.GID

.1				ldy #1
				lda (pStack),y
				bmi .2

				sta K.MLI.PARAMS+3+S.FIEX.ACL.UID
	
.2				lda #$57							write mode
				sta K.MLI.PARAMS+3+S.FIEX.ACL

				>MLICALL MLIACL
				
.9				>RET 4				
*--------------------------------------
IO.DEV			.AS "/dev/"
*--------------------------------------
MAN
SAVE usr/src/sys/kernel.s.unistd
LOAD usr/src/sys/kernel.s
ASM
