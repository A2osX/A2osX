NEW
PREFIX /A2OSX.BUILD
AUTO 4,1
*/--------------------------------------
* # StrLen
* Returns Length of C-String
* ## C
* `int strlen ( char * str);`
* ## ASM
* `>LDYAI str`
* `>SYSCALL strlen`
* ## RETURN VALUE 
* Y,A = String length
*\--------------------------------------
K.StrLen		>STYA .1+1

				ldy #0
				tya
				
.1				ldx $ffff,y				SELF MODIFIED
				beq .8
				iny
				bne .1
				inc
				inc .1+2
				bra .1
				
.8				rts
*/--------------------------------------
* # StrCat
* Concatenate strings
* ## C
* `char * strcat ( char * destination, const char * source );`
* ## ASM
* **In:** 
* `>PUSHWI source`
* `>LDYAI destination`
* `>SYSCALL strcat`
* ## RETURN VALUE 
* Y,A = destination
*\--------------------------------------
K.StrCat		sec
				.HS 90					BCC
*/--------------------------------------
* # StrCpy
* Copy string
* ## C
* `char * strcpy ( char * destination, const char * source );`
* ## ASM
* **In:** 
* `>PUSHWI source`
* `>LDYAI destination`
* `>SYSCALL strcpy`
* ## RETURN VALUE 
* Y,A = destination
*\--------------------------------------
K.StrCpy		clc
				jsr MEM.SPtr1PPtr2
		
				bcc .2
		
.1				lda (ZPPtr1)
				beq .2
				
				inc ZPPtr1
				bne .1
				inc ZPPtr1+1
				bra .1
				
.2				ldy #0
				
.3				lda (ZPPtr2),y
				sta (ZPPtr1),y
				beq .8
				iny
				bne .3
				inc ZPPtr2+1
				inc ZPPtr1+1
				bra .3
				
.8				rts
*/--------------------------------------
* # StrMatch
* Compare a String against pattern (e.g. '*test?.txt')
* ## C
* `int * strmatch ( char * s, const char * pattern );`
* ## ASM
* **In:** 
* `>PUSHWI pattern`
* `>LDYAI s`
* `>SYSCALL strmatch`
* ## RETURN VALUE 
* CC : match
* CS : no match
*\--------------------------------------
K.StrMatch		jsr MEM.SPtr1PPtr2

				lda (ZPPtr2)			Get pattern 1st byte
                beq .8                  Match always if empty
				
				ldy #0

				bra .21
				
.1				inc ZPPtr2				Make PTR2 (pattern) advance to next char 
                bne .2 
				inc ZPPtr2+1 

.2				lda (ZPPtr2)       		get pattern char 
				beq .41					end of pattern...
				
.21				cmp #'*' 
				beq .5
                                        
.3				lda (ZPPtr1)			we must match ? or regular char, check if at end of string 
                beq .9                  no char left, exit with error 
                                        
				lda (ZPPtr2)       		get back pattern char 
				cmp #'?' 
				beq .4                  no need to compare, any char will match 
				cmp (ZPPtr1),y     		Regular Char, compare with string at Y 
				bne .9                  no match, exit 

.4				iny                     advance to next char to compare                                               				
				bra .1					continue if remaining char in pattern 

.41				lda (ZPPtr1),y 			end of pattern, but end of string ? 
				
				beq .8					yes, string matched entirely 
*										no, remaining char in string, no match 
.9              sec 
                rts 

.5				inc ZPPtr2				Make PTR2 advance to next char 
				bne .6 
				inc ZPPtr2+1
				
.6				lda (ZPPtr2)			we have '*', last char of pattern ? 
				beq .8					yes, match everything, including empty string 
                                        
				lda (ZPPtr2)       		get next char of pattern 
				cmp #'*'				another '*' ? 
				beq .5					yes, '**' = '*', go next char 
				cmp #'?'				'*?' ? we must match a least one char 
				beq .3 
                                        
.7				lda (ZPPtr1),y			we need at least one remaining char in string, check if at end of string 
				beq .9					no chance to match ? or regular char 
                                        
				iny 
				lda (ZPPtr2)       		get again char in pattern 
				cmp (ZPPtr1),y 			compare with char in string 
                bne .7  	            not equal to next non wildcard in pattern 

				iny
				bra .1                  go check remaining char in pattern... 
                                        
.8				clc 
                rts 
*/--------------------------------------
* # StrUpr/StrLwr
* Convert string to UPPERCASE/lowercase
* ## C
* `int strupr ( char * str);`
* `int strlwr ( char * str);`
* ## ASM
* **In:** 
* `>LDYAI str`
* `>SYSCALL strupr`
* `>SYSCALL strlwr`
* ## RETURN VALUE 
* Uppercased/lowercased String in Buffer
* Y,A = str
*\--------------------------------------
K.StrUpr		ldx #0
				.HS 2C					bit abs
K.StrLwr		ldx #2
				>STYA ZPPtr1
				
				pha						save Y,A to restore them at exit
				phy
				
				ldy #0
				
.1				lda (ZPPtr1),y
				beq .8
				
				cmp .9,x
				bcc .2
				cmp .9+1,x
				bcs .2
				eor #$20
				sta (ZPPtr1),y
.2				iny
				bne .1
				inc ZPPtr1+1
				bra .1
				
.8				ply
				pla
				rts
*--------------------------------------
.9				.AS "azAZ"
*/--------------------------------------
* # StrCmp
* Compare 2 strings
* ## C
* `int strcmp(const char *s1, const char *s2);`
* ## ASM
* **In:** 
* `>PUSHWI s2`
* `>LDYAI s1`
* `>SYSCALL strcmp`
* ## RETURN VALUE 
* CC : match
* CS : no match
*  CC, Y,A=0
*  CS, Y,A > 0 or < 0
*\--------------------------------------
K.StrCmp		sec
				.HS 90					BCC
*/--------------------------------------
* # StrCaseCmp
* Compare 2 strings, ignoring case
* ## C
* `int strcasecmp(const char *s1, const char *s2);`
* ## ASM
* **In:** 
* `>PUSHWI s2`
* `>LDYAI s1`
* `>SYSCALL strcasecmp`
* ## RETURN VALUE 
* CC : match
* CS : no match
*  CC, Y,A=0
*  CS, Y,A > 0 or < 0
*\--------------------------------------
K.StrCaseCmp	clc
				jsr MEM.SPtr1PPtr2

				ldy #0
				
.1				lda (ZPPtr1),y
				beq .7
				jsr K.StrCaseCmp.toUpper
				sta .2+1
				
				lda (ZPPtr2),y
				beq .9
				jsr K.StrCaseCmp.toUpper
				
.2				eor #$ff				SELF MODIFIED
				bne .9
				iny
				bne .1
				inc ZPPtr1+1
				inc ZPPtr2+1
				bra .1
 
.7				lda (ZPPtr2),y
				bne .9
				tay
				
.8				clc
				rts
				
.9				sec

				lda (ZPPtr1),y
				sbc (ZPPtr2),y
				
				ldy #0
				
				sec				
				rts
*--------------------------------------
K.StrCaseCmp.toUpper
				bcs .9
				
				cmp #'a'
				bcc .9
				cmp #'z'+1
				bcs .1
				eor #$20

.1				clc

.9				rts				
*--------------------------------------
MAN
SAVE /A2OSX.SRC/SYS/KERNEL.S.STRING
LOAD /A2OSX.SRC/SYS/KERNEL.S
ASM
