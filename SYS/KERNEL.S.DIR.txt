PR#3
PREFIX /A2OSX.SRC
NEW
INC 1
AUTO 6
				.LIST OFF
*/--------------------------------------
* #OpenDirYA
* ##In:
*  Y,A = PATH (PSTR)
* ##Out: 
*  CC : success
*   A = hDIR
*  CS : error
*   A = EC
*\--------------------------------------
K.OpenDirYA		jsr PFT.CheckPathYA
				>STYA ZPQuickPtr2
				>STYA MLICALL.PARAMS+1	For GETFILEINFO,MLIOPEN
				
				>PUSHWI S.DIR.PRODOS
				>PUSHBI S.MEM.F.INIT0
				jsr K.GetMem
				bcs .9
				
				>STYA ZPQuickPtr1
				stx K.ReadDirA.hDir
						
				lda (ZPQuickPtr2)
				cmp #1					One char ?
				bne .7					No, Go open dir....
				tay						Y=1
				lda (ZPQuickPtr2),y
				cmp #'/'				Root required ?
				beq .8					Yes, Go for ONLINE Call (S.DIR.PRODOS.REF=0)
				
				lda #SYSMGR.ERRSYN
				sec
.9				rts
				
.7				>MLICALL MLIGETFILEINFO
				bcs .98					file/dir does not exists....quit
				lda MLICALL.PARAMS+4
				cmp #$0F				Directory ?
				bne .98
				
				>PUSHWI 1024			get a ProDOS IOBUF
				>PUSHBI S.MEM.F.ALIGN+S.MEM.F.NOMOVE
				jsr K.GetMem
				bcs .98
				
				>STYA MLICALL.PARAMS+3	Save Ptr to IOBUF for MLIOPEN call
				txa
				ldy #S.DIR.PRODOS.IOBUF
				sta (ZPQuickPtr1),y
				
				>MLICALL MLIOPEN
				bcs .98
				
				lda MLICALL.PARAMS+5	get ref_num
				ldy #S.DIR.PRODOS.REF
				sta (ZPQuickPtr1),y				

.8				lda K.ReadDirA.hDir
				clc
				rts
				
.98				pha						save MLI error
				jsr K.CloseDirA.1
				pla						get back MLI error				
				sec
.99				rts
*/--------------------------------------				
* #ReadDirA
* ##In: 
*  A = hDIR
* ##Out: 
*  CC : success
*   X = hDIRENT
*   Y,A = PTR to S.DIRENT
*  CS : error
*   A = EC
*   note : A = 0 means no more entry
*\--------------------------------------
K.ReadDirA.hDir		.BS 1
K.ReadDirA.hMem		.BS 1
K.ReadDirA.hDIRENT	.BS 1
K.ReadDirA.BufSize	.BS 2
K.ReadDirA.ECIB		.BS 1
*--S.DIR Cache ------------------------
K.ReadDirA.EL		.BS 1
K.ReadDirA.EPB		.BS 1
K.ReadDirA.EC		.BS 2
*--------------------------------------
K.ReadDirA		jsr PFT.CheckDirA
				sta K.ReadDirA.hDir
				jsr K.GetMemPtrA
				>STYA ZPQuickPtr1
				
				ldy #S.DIR.F
				lda (ZPQuickPtr1),y
				and #S.DIR.F.NOMORE
				bne .9
				
				ldy #S.DIR.PRODOS.REF
				lda (ZPQuickPtr1),y
				beq K.ReadDirA.ROOT
				jmp K.ReadDirA.DIR
				
.9				lda #0
				sec						CS,A=0 no more entry
				rts
*--------------------------------------
K.ReadDirA.ROOT	stz MLICALL.PARAMS+1	All Volumes
				
				>LDYAI KrnBuf256
				>STYA MLICALL.PARAMS+2
				>STYA ZPQuickPtr2
				>MLICALL MLIONLINE
				bcc .10
				
			
				sec
.99				rts					
* pass #1 compute BufSize.....				
.10				lda #1					+1 for Ending 0
				sta	K.ReadDirA.BufSize
				stz K.ReadDirA.BufSize+1
				
				stz K.ReadDirA.EC
				
				ldy #0
				
.1				lda (ZPQuickPtr2),y
				and #$0F
				beq .2
				
				inc K.ReadDirA.EC		increase entry count
				
				sec						Add Filelen +1
				adc #S.STAT				will ends with CC
				adc K.ReadDirA.BufSize
				sta K.ReadDirA.BufSize
				bcc .2
				inc K.ReadDirA.BufSize+1
								
.2				tya
				clc
				adc #16
				tay
				bcc .1					loop until 256 bytes scanned
				
* pass #2 Fill Buffer...
				jsr K.ReadDirA.GetBuf
				bcs .99
				
.3				lda (ZPQuickPtr2)
				and #$0F
				beq .88

				tax
				jsr K.ReadDirA.AddToBuf
				inc
				sta KrnOut256
				lda #'/'
				sta KrnOut256+1
				ldy #1
				
.4				lda (ZPQuickPtr2),y
				sta KrnOut256+1,y
				jsr K.ReadDirA.AddToBuf
				iny
				dex
				bne .4
				
				jsr K.ReadDirA.ClrStat
				
				lda (ZPQuickPtr2)

				asl					DRIVE in Carry
				pha
				lda #0
				rol
				inc
				sta KrnSTAT+S.STAT.PRODOS.DRIVE
				pla
				lsr						CC
				lsr
				lsr
				lsr
				lsr
				sta KrnSTAT+S.STAT.PRODOS.SLOT

				>LDYAI KrnOut256
				>STYA MLICALL.PARAMS+1
				
				>MLICALL MLIGETFILEINFO
				sta KrnSTAT+S.STAT.PRODOS.DEVSTATUS

				bcs .80
				>LDYA MLICALL.PARAMS+5		AUXTYPE=TOTAL BLOCKS
				>STYA KrnSTAT+S.STAT.PRODOS.DEVBLOCKS
				>LDYA MLICALL.PARAMS+8
				>STYA KrnSTAT+S.STAT.BLOCKS
				
.80				jsr K.ReadDirA.ADDSTAT
				
.88				lda ZPQuickPtr2
				clc
				adc #16
				sta ZPQuickPtr2
				bcc .89
				inc ZPQuickPtr2+1
.89				dec K.ReadDirA.EC
				bne .3

*				lda #0						done by S.MEM.F.INIT0
*				sta (ZPQuickPtr4)			Ending 0
				
				ldy #S.DIR.F
				lda #S.DIR.F.NOMORE
				sta (ZPQuickPtr1),y
								
				lda K.ReadDirA.hDIRENT
				tax
				jmp K.GetMemPtrA
*--------------------------------------
K.ReadDirA.DIR  sta MLICALL.PARAMS+1	A=#S.DIR.PRODOS.REF

				>PUSHWI 512				Get a 512 bytes buffer for reading dir...
				>PUSHBI 0
				jsr K.GetMem
				bcs .99
				stx K.ReadDirA.hMem
				
				>STYA MLICALL.PARAMS+2	For reading
				
				pha
				tya
*				clc						CC from  K.GetMem
				adc #4					Skip 4 bytes linked list		
				sta ZPQuickPtr2			PTR to Buffer for PASS #1
				sta ZPQuickPtr3			PTR to Buffer for PASS #2
				
				pla
				adc #0
				sta ZPQuickPtr2+1		PTR to Buffer for PASS #1
				sta ZPQuickPtr3+1		PTR to Buffer for PASS #2
				
				>LDYAI 512
				>STYA MLICALL.PARAMS+4
				>MLICALL MLIREAD		Read A block from directory
				bcs .98
				
				ldy #S.DIR.PRODOS.EL	Check if first run....
				lda (ZPQuickPtr1),y
				bne .2					no, we have all we need....
				
				ldy #$1f+3
				ldx #3
				
.1				lda (ZPQuickPtr2),y		Get K.ReadDirA.EL....	From Block
				sta K.ReadDirA.EL,x
				dey
				dex
				bpl .1
				
				inc K.ReadDirA.EC		Add one to EC because we include VOL/DIR Header
				bne .4
				inc K.ReadDirA.EC+1		...and ProDOS does NOT include header entry in EC
				bra .4

.98				jsr K.ReadDirA.CLN
				sec
.99				rts
				
.2				ldy #S.DIR.PRODOS.EL+3
				ldx #3

.3				lda (ZPQuickPtr1),y		get this session parameters from S.DIR
				sta K.ReadDirA.EL,x
				dey
				dex
				bpl .3
				
.4				ldx K.ReadDirA.EC
				cpx K.ReadDirA.EPB

				lda K.ReadDirA.EC+1
				sbc #0
				bcc	.5					We have less than EPB to read
				ldx K.ReadDirA.EPB
				
.5				stx K.ReadDirA.ECIB

* pass #1 compute BufSize...

				lda #1					For Ending 0
				sta K.ReadDirA.BufSize
				stz K.ReadDirA.BufSize+1
				
K.ReadDirA.DIR1	lda (ZPQuickPtr2)		X = EntryCount In This Block
				beq .7					Free slot....goto next
				
				tay						save LEN
				
				and #$F0				get storage_type
				cmp #$F0				Volume header ?
				beq .1
				
				cmp #$E0				directory header ?
				beq .2
				
				tya						regular DIR or File, get back LEN
				
				and #$F					compute filename len
				sec						add "#<filename>" + S.STAT
				
				adc #S.STAT
				.HS 2C					bit abs
				
.1				lda #2+S.STAT			add "1." string + S.STAT
				.HS 2C					bit abs
				
.2				lda #2+S.STAT+3+S.STAT	add "1." + S.STAT + "2.." + S.STAT...

				clc
				adc K.ReadDirA.BufSize
				sta K.ReadDirA.BufSize
				bcc .7
				inc K.ReadDirA.BufSize+1
				
.7				lda ZPQuickPtr2
				clc
				adc K.ReadDirA.EL
				sta ZPQuickPtr2
				bcc .8
				inc ZPQuickPtr2+1
				
.8				dex
				bne K.ReadDirA.DIR1
				
* pass #2 Fill Buffer...(ZPQuickPtr1 & Ptr2 can now be trashed)
K.ReadDirA.DIR2	jsr K.ReadDirA.GetBuf
				bcs .98
				
.71				lda (ZPQuickPtr3)
				beq .78					Empty slot, skip

				and #$F0
				cmp #$F0				Vol Header ?
				bne .72
				jsr K.ReadDirA.ADD.
				bra .78
				
.72				cmp #$E0				Dir Header ?
				bne .73
				jsr K.ReadDirA.ADD.
				jsr K.ReadDirA.ADD..
				bra .78
				
.73				lda K.ReadDirA.EC		Regular FILE/DIR
				sec
				sbc #1
				sta K.ReadDirA.EC
				
				lda K.ReadDirA.EC+1
				sbc #0
				sta K.ReadDirA.EC+1		CC, we reached $ffff
				bcc .80					no more file to list...
				
				jsr K.ReadDirA.AddFNToBuf
				jsr K.ReadDirA.ClrStat

				lda (ZPQuickPtr3)
				and #$F0
				cmp #$D0					Directory ?
				bne .75
				jsr K.ReadDirA.ADDD
				bra .78
				
.75				jsr K.ReadDirA.ADDF

.78				lda ZPQuickPtr3
				clc
				adc K.ReadDirA.EL
				sta ZPQuickPtr3
				bcc .79
				inc ZPQuickPtr3+1	

.79				dec K.ReadDirA.ECIB
				bne .71
				
.80				
*				lda #0					S.MEM.F.INIT0 already did this
*				sta (ZPQuickPtr4)		Ending 0

				lda K.ReadDirA.hDir		Restore ZPQuickPtr1 trashed by STR API calls
				jsr K.GetMemPtrA
				>STYA ZPQuickPtr1
				
				ldx #3
				ldy #S.DIR.PRODOS.EL+3
				
.8				lda K.ReadDirA.EL,x		Store back this session prameters to S.DIR
				sta (ZPQuickPtr1),y
				dey
				dex
				bpl .8
				
				jsr K.ReadDirA.CLN		Discard READBUFFER
				
				lda K.ReadDirA.hDIRENT
				tax
				jmp K.GetMemPtrA
				
.98				jsr K.ReadDirA.CLN
				sec
				rts
*--------------------------------------
K.ReadDirA.CLN	pha
				lda K.ReadDirA.hMem
				jsr K.FreeMemA
				pla
				rts			
*--------------------------------------
K.ReadDirA.GetBuf
				>PUSHW K.ReadDirA.BufSize			Get a BufSize bytes buffer for storing results
				>PUSHBI S.MEM.F.INIT0	make sure 0 filled
				jsr K.GetMem
				bcs .9
				stx K.ReadDirA.hDIRENT
				>STYA ZPQuickPtr4
.9				rts
*--------------------------------------
K.ReadDirA.ADD. ldx #1					filename="1."
				.HS 2C					bit abs
K.ReadDirA.ADD..
				ldx #2					filename="2.."
				txa
				jsr K.ReadDirA.AddToBuf	Add LEN
				lda #'.'
				
.1				jsr K.ReadDirA.AddToBuf		Add X dot(s)
				dex
				bne .1
				
				jsr K.ReadDirA.ClrStat
				
*				ldy #$25				total_blocks
*				lda (ZPQuickPtr3),y
*				sta KrnSTAT+S.STAT.BLOCKS
*				iny
*				lda (ZPQuickPtr3),y
*				sta KrnSTAT+S.STAT.BLOCKS+1
*--------------------------------------
K.ReadDirA.ADDD	lda #$0F
				sta KrnSTAT+S.STAT.PRODOS.TYPE

				lda /S.STAT.MODE.DIR
				sta KrnSTAT+S.STAT.MODE+1
				bra K.ReadDirA.AddAccess
*--------------------------------------
K.ReadDirA.ADDF	lda /S.STAT.MODE.REG
				sta KrnSTAT+S.STAT.MODE+1
				
				ldx #ADDF.DST-ADDF.SRC

.1				ldy ADDF.SRC-1,x
				lda (ZPQuickPtr3),y
				ldy ADDF.DST-1,x
				sta KrnSTAT,y
				dex
				bpl .1
*--------------------------------------
K.ReadDirA.AddAccess
				ldy #$1E				ProDOS Access
				lda (ZPQuickPtr3),y
				
				ldx #0
				bit #$01				ProDOS R
				beq .2
				ldx #S.STAT.MODE.RO
				
.2				bit #$C2				ProDOS D,Rn,W
				beq .3
				txa
				ora #S.STAT.MODE.XO+S.STAT.MODE.WO
				.HS 89					bit imm to skip txa
				
.3				txa
				sta KrnSTAT+S.STAT.MODE			
*--------------------------------------
K.ReadDirA.AddTime
				>PUSHWI KrnSTAT+S.STAT.CTIME
				lda #$18				creation Date/time
				jsr K.ReadDirA.ConvertTime

				>PUSHWI KrnSTAT+S.STAT.MTIME
				lda #$21				mod Date/time
				jsr K.ReadDirA.ConvertTime
*--------------------------------------
K.ReadDirA.AddStat
				ldy #S.STAT-1
				
.1				lda KrnSTAT,y
				sta (ZPQuickPtr4),y
				dey
				bpl .1
				
				lda ZPQuickPtr4
				clc
				adc #S.STAT
				sta ZPQuickPtr4
				bcc .8
				inc ZPQuickPtr4+1
.8				rts
*--------------------------------------
K.ReadDirA.ClrStat
				ldx #S.STAT-1
				
.1				stz KrnSTAT,x
				dex
				bpl .1
				rts
*--------------------------------------
K.ReadDirA.AddFNToBuf
				lda (ZPQuickPtr3)
				and #$0F				get filename len
				tax
				jsr K.ReadDirA.AddToBuf
				
				ldy #1
				
.1				lda (ZPQuickPtr3),y			
				jsr K.ReadDirA.AddToBuf
				iny
				dex
				bne .1
				rts
*--------------------------------------
K.ReadDirA.AddToBuf
				sta (ZPQuickPtr4)
				inc ZPQuickPtr4
				bne .8
				inc ZPQuickPtr4+1
.8				rts
*--------------------------------------
K.ReadDirA.ConvertTime
				clc
				adc ZPQuickPtr3
				tay
				lda ZPQuickPtr3+1
				adc #0
				>PUSHYA
				jmp K.PTime2Time		Will destroy Ptr1 & Ptr2 !!!!
*--------------------------------------
ADDF.SRC		.HS 1013141516171f20
ADDF.DST		.DA #S.STAT.PRODOS.TYPE,#S.STAT.BLOCKS,#S.STAT.BLOCKS+1
				.DA #S.STAT.SIZE,#S.STAT.SIZE+1,#S.STAT.SIZE+2
				.DA #S.STAT.PRODOS.AUXTYPE,#S.STAT.PRODOS.AUXTYPE+1
*/-------------------------------------
* #CloseDirA
* ##In: 
*  A = hDIR
* ##Out:
*  none, always succeed. 
*\-------------------------------------
K.CloseDirA		jsr PFT.CheckDirA
				sta K.ReadDirA.hDir	
				jsr K.GetMemPtrA
				>STYA ZPQuickPtr1

K.CloseDirA.1	ldy #S.DIR.PRODOS.REF
				lda (ZPQuickPtr1),y
				beq .1
				sta MLICALL.PARAMS+1
				>MLICALL MLICLOSE
				
.1				ldy #S.DIR.PRODOS.IOBUF
				lda (ZPQuickPtr1),y
				beq .2
				jsr K.FreeMemA
				
.2				ldaK.ReadDirA.hDir
				jmp K.FreeMemA
*/-------------------------------------
* #MKDirYA
* ##In: 
*  Y,A = DIR name
* ##Out:
*  CC : success
*  CS : error
*   A = EC
*\-------------------------------------
K.MKDirYA		jsr PFT.CheckPathYA
				>STYA MLICALL.PARAMS+1
				lda #S.FILEINFO.ACCESS.FULL
				sta MLICALL.PARAMS+S.FILEINFO.ACCESS
				lda #S.FILEINFO.TYPE.DIR
				sta MLICALL.PARAMS+S.FILEINFO.TYPE
				lda #S.FILEINFO.STORETYPE.DIR
				sta MLICALL.PARAMS+S.FILEINFO.STORETYPE	
				>MLICALL MLICREATE
				rts
*--------------------------------------
MAN
SAVE SYS/KERNEL.S.DIR
LOAD SYS/KERNEL.S
ASM
