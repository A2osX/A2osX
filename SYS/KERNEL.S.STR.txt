PR#3
PREFIX /DATA/A2OSX
NEW
INC 1
AUTO 6
				.LIST OFF
				.OP	65C02
*--------------------------------------
* S.NewPStr
*  IN:
*	PULLW = PTR to buffer
*  OUT:
*   A = hMem to S (PSTRING)
*--------------------------------------
S.NewPStr		>PULLW ZPQuickPtr1
				bra S.PStrCpy2
*--------------------------------------
* S.PStrCpyA
*  In:
*   A = hMem of Src String
*  Out:
*   A = hMem of Dest String
*--------------------------------------
S.PStrCpyA		jsr S.GetMemPtrA
				>STYA ZPQuickPtr1
S.PStrCpy2		lda (ZPQuickPtr1)
				inc
				tay
				lda #0					Y,A = len of new string
				>PUSHYA
				>PUSHA					0 = no option
				jsr S.GetMem
				bcs .9
				phx
				>STYA ZPQuickPtr2
				lda (ZPQuickPtr1)
				sta (ZPQuickPtr2)
				tay
				beq .2
.1				lda (ZPQuickPtr1),y
				sta (ZPQuickPtr2),y
				dey
				bne .1
.2				pla
				clc
				rts
.9				sec
				rts
*--------------------------------------
* S.PStrCat
* IN: 
*  PULLB = hMem to S1 (PSTRING)
*  PULLB = hMem to S2 (PSTRING)
* OUT: 
*  A = hMem to S1+S2 (PSTRING)
*--------------------------------------
S.PStrCat		>PULLA
				jsr S.GetMemPtrA
				>STYA ZPQuickPtr1		save S1
				>PULLA
				jsr S.GetMemPtrA
				>STYA ZPQuickPtr2		save S2
				lda (ZPQuickPtr1)		Compute length of new path = S1 + S2 + 1
				sec
				adc	(ZPQuickPtr2)
				tay
				lda #0					Y,A = len of new string
				>PUSHYA
				>PUSHA					0 = no option
				jsr S.GetMem
				bcs .9					OOM error
				>STYA ZPQuickPtr3
				phx						save New hMem
				lda (ZPQuickPtr1)
				tax
				ldy #0
.2				iny
				lda (ZPQuickPtr1),y
				sta (ZPQuickPtr3),y
				dex
				bne .2
				lda (ZPQuickPtr2)
				tax
.3				inc ZPQuickPtr2
				bne .4
				inc ZPQuickPtr2+1
.4				iny
				lda (ZPQuickPtr2)
				sta (ZPQuickPtr3),y
				dex
				bne .3
				tya
				sta	(ZPQuickPtr3)
				pla						returns A = new hMem
				clc
				rts	
.9				sec
				rts
*--------------------------------------
* S.PStrCmp
*  IN: 
*   PULLB = hMem to S1 (PSTRING)
*   PULLB = hMem to S2 (PSTRING)
*  OUT: 
*   cc or cs
*--------------------------------------
S.PStrCmp		>PULLA
				jsr S.GetMemPtrA
				>STYA ZPQuickPtr1		save S1
				>PULLA
				jsr S.GetMemPtrA
				>STYA ZPQuickPtr2		save S2
				lda (ZPQuickPtr1)
				tay
				cmp (ZPQuickPtr2)
				bne .9
.1				lda (ZPQuickPtr1),y
				cmp (ZPQuickPtr2),y
				bne .9
				dey
				bne .1
				clc
				rts
.9				sec
				rts	
*--------------------------------------
* S.PStrMatch
*  IN: 
*   PULLB = hMem to String (PSTRING)
*   PULLB = hMem to Pattern (PSTRING)
*  OUT: 
*   cc = match
*	cs = no match
*--------------------------------------
S.PStrMatch		>PULLA
				jsr S.GetMemPtrA
				>STYA ZPQuickPtr2		save String
				>PULLA
				jsr S.GetMemPtrA
				>STYA ZPQuickPtr1		save Pattern
				bra S.PStrMatch1
				
S.PStrMatchP	>PULLW ZPQuickPtr2		pull String
				>PULLW ZPQuickPtr1		pull Pattern
				
S.PStrMatch1	lda (ZPQuickPTR1)		Keep Pattern Length in X 
                tax 
                beq .8                  Match always if empty 
				ldy #0

.1				inc ZPQuickPTR1			Make PTR1 advance to next char 
                bne .2 
				inc ZPQuickPTR1+1 

.2				lda (ZPQuickPTR1)       get pattern char 
				cmp #'*' 
				beq .5
                                        
.3				tya						we must match ? or regular char 
                cmp (ZPQuickPTR2)       check if at end of string 
                beq .9                  yes, no char left, exit with error 
                                        
				iny                     advance to next char to compare 
                                                
				lda (ZPQuickPTR1)       get back pattern char 
				cmp #'?' 
				beq .4                  no need to compare, any char will match 
				cmp (ZPQuickPTR2),y     Regular Char, compare with string at Y 
				bne .9                  no match, exit 
                                        
.4				dex 					char matched, check if end of pattern 
				bne .1					continue if remaining char in pattern 

				tya						end of pattern, but end of string ? 
				cmp (ZPQuickPTR2)       end of string ? 
				beq .8					yes, string matched entirely 
				bra .9					no, remaining char in string, no match 

.5				dex						we have '*', last char of pattern ? 
				beq .8					yes, match everything, including empty string 
                                        
				inc ZPQuickPTR1			Make PTR1 advance to next char 
				bne .6 
				inc ZPQuickPTR1+1 
                                        
.6				lda (ZPQuickPTR1)       get next char of pattern 
				cmp #'*'				another '*' ? 
				beq .5					yes, '**' = '*', go next char 
				cmp #'?'				'*?' ??? we must match a least one char 
				beq .3 
                                        
.7				tya						we need at least one remaining char in string, 
				cmp (ZPQuickPTR2)       check if at end of string 
				beq .9					no chance to match ? or regular char 
                                        
				iny 
				lda (ZPQuickPTR1)       get again char in pattern 
				cmp (ZPQuickPTR2),y 	compare with char in string 
                bne .7  	            not equal to next non wildcard in pattern 

				bra .4                  go check remaining char in pattern... 
                                        
.8				clc 
                rts 
                                        
.9              sec 
                rts 
*--------------------------------------
* S.PStrGetTkn
* IN: 
*  PULLB = Token IDX
*   0: "Split mode": first token + remaining
*   !0: "Std Mode": Return token # 
*  PULLB = SEP char
*  PULLB = hMem to PSTRING
* OUT: 
*  A = hMem to Token (PSTRING)
*  X = hMem to Remaining String After Token "Split Mode"
*--------------------------------------
S.PStrGetTkn	>PULLA					Get IDX
				sta ZPQuickPtr2+1
				>PULLA					Get SEP
				sta ZPQuickPtr2
				>PULLA					Get PStr
				jsr S.GetMemPtrA
				>STYA ZPQuickPtr1
				ldx #0					init token count to 0
				ldy #0
				stz ZPQuickPtr3			init INTOKEN start to 0
.1				iny
				lda (ZPQuickPtr1),y
				and #$7F
				cmp ZPQuickPtr2			char=SEP ?
				bne .3					no, start a new token if not alredy in
				lda ZPQuickPtr3			SEP:in INTOKEN ?
				beq .4					no, skip this SEP
				inx						yes, increase token count
				lda ZPQuickPtr2+1		requested token=0 ?
				beq .71					yes, we are in "split mode"
				cpx ZPQuickPtr2+1		no,is current X=requested IDX?
				beq .71
				stz ZPQuickPtr3			reset in INTOKEN start
				bra .4
.3				lda ZPQuickPtr3			char:already INTOKEN ?
				bne .4					yes, keep existing start index
				sty ZPQuickPtr3			mark begining of token
.4				tya
				cmp (ZPQuickPtr1)		end of string ?
				bne .1					no, get next one
				lda ZPQuickPtr3			INTOKEN?
				beq .6			
				inx						yes, last one is ending with string
.6				lda ZPQuickPtr2+1		split mode ?
				beq .7
				cpx ZPQuickPtr2+1		is token = requested?		
				beq .7
				sec						End of String reached, no matching token
.61				rts
.71				dey						move back yo end of token before this SEP	
.7				sty ZPQuickPtr3+1		we have matching token (or 1st one in split mode) at [ZPQuickPtr3,ZPQuickPtr3+1]
				tya						compute token len=Y-ZPQuickPtr3+1
				sec
				sbc ZPQuickPtr3
				inc						+1 
				inc						+1 for string len
				tay
				lda #0
				>PUSHYA					Get a hMem for this token
				>PUSHA					0 = no option
				jsr S.GetMem
				bcs .61
				phx						save hMem
				>STYA ZPQuickPtr4
				lda ZPQuickPtr3+1
				sec
				sbc ZPQuickPtr3
				inc
				sta (ZPQuickPtr4)		set this string length
				ldy ZPQuickPtr3
				dey
.8				iny
				inc ZPQuickPtr4
				bne .9
				inc ZPQuickPtr4+1
.9				lda (ZPQuickPtr1),y
				sta (ZPQuickPtr4)
				cpy ZPQuickPtr3+1
				bne .8
				lda ZPQuickPtr2+1		requested token=0 ?
				bne .87					
				tya						yes, we are in "split mode"
				cmp (ZPQuickPtr1)		Remaining chars ?
				beq .87
.10				iny						move to next char
				lda (ZPQuickPtr1),y
				cmp ZPQuickPtr2			char=SEP?
				bne .11
				tya
				cmp (ZPQuickPtr1)		last one ?
				bne .10
				bra .87					yes, nothing to return
.11				sty ZPQuickPtr3+1		ZPQuickPtr3+1=1st non SEP char
				lda (ZPQuickPtr1)		compute reamining len=Y-ZPQuickPtr3+1
				sec
				sbc ZPQuickPtr3+1
				inc
				inc						+1 for string len
				tay
				lda #0
				>PUSHYA					Get a hMem for remaining string
				>PUSHA					0 = no option
				jsr S.GetMem
				bcs .98	
				phx						save hMem
				>STYA ZPQuickPtr4
				lda (ZPQuickPtr1)
				sec
				sbc ZPQuickPtr3+1
				inc
				sta (ZPQuickPtr4)
				ldy ZPQuickPtr3+1
				dey
.12				iny
				inc ZPQuickPtr4
				bne .13
				inc ZPQuickPtr4+1
.13				lda (ZPQuickPtr1),y
				sta (ZPQuickPtr4)
				tya
				cmp (ZPQuickPtr1)
				bne .12
				plx						get back remaining string hMem
				pla						get back token hMem
				clc
				rts
.87				ldx #0 					Splitmode but no remaining string to return
				pla						get back token hMem
				clc
				rts
.98				pla						get back Token hMem
				jsr S.FreeMemA			discard Token
.99				sec
				rts
*--------------------------------------
* S.GetPStrIndex
*  in :
*   PULLW = String Table (Array Of PSTR)
*   PULLW = String To Search (PSTR)
* out :
*   CC: A = String Index In Table
*--------------------------------------
S.GetPStrIndex	>PULLW ZPQuickPtr1
				>PULLW ZPQuickPtr2
				ldx #0
.1				lda (ZPQuickPtr1)
				beq .99
				cmp (ZPQuickPtr2)
				bne .3
				tay
.2				lda (ZPQuickPtr1),y
				eor (ZPQuickPtr2),y
				and #$7F
				bne .3
				dey
				bne .2
				txa
				clc
				rts
.3				inx
				lda (ZPQuickPtr1)
				sec
				adc ZPQuickPtr1
				sta ZPQuickPtr1
				bcc .1
				inc ZPQuickPtr1+1
				bra .1
.99				lda #SYSMGR.ERRSYN
				sec
				rts
*--------------------------------------
MAN
SAVE SYS/KERNEL.S.STR
LOAD SYS/KERNEL.S
ASM
