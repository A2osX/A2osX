PR#3
PREFIX /A2OSX.BUILD
LOMEM $A00
INC 1
AUTO 6
*/--------------------------------------
* # NewPStrYA
* Create a new copy of PSTR
* ## In:
*  Y,A = PTR to buffer
* ## Out:
*  CC : success 
*   Y,A = PTR to String
*   X = hMem (PSTR)
*  CS : error
*   A = SYS error code
*\--------------------------------------
K.NewPStrYA		>STYA ZPPtr2
				lda (ZPPtr2)
				inc
				tay
				lda #0					Y,A = len of new string
				jsr K.GetMemYA
				bcs .9

				>STYA ZPPtr1

				jsr K.PStrCpyPtr2Ptr1
				
				>LDYA ZPPtr1

				clc
.9				rts
*/--------------------------------------
* # PStrCpy
* Copy string
* ## In: 
*  PUSHW = Ptr to SRC (PSTR)
*  PUSHW = Ptr to DST (PSTR)
* ## Out: 
*  DST = SRC (PSTR)
*\--------------------------------------
K.PStrCpy		jsr PullPtr1Ptr2

K.PStrCpyPtr2Ptr1
				lda (ZPPtr2)
				sta (ZPPtr1)
				tay
				beq .2
				
.1				lda (ZPPtr2),y
				sta (ZPPtr1),y
				dey
				bne .1
				
.2				clc
				rts
*/--------------------------------------
* # PStrCat
* Append SRC to DST
* ## In: 
*  PUSHW = Ptr to SRC (PSTR)
*  PUSHW = Ptr to DST (PSTR)
* ## Out: 
*  DST = DST+SRC (PSTR)
*\--------------------------------------
K.PStrCat		jsr PullPtr1Ptr2
				
				lda (ZPPtr2)
				tax
				
				lda (ZPPtr1)
				tay
				
.1				cpy #255
				beq .8

				iny
				
				inc ZPPtr2
				bne .2
				inc ZPPtr2+1
				
.2				lda (ZPPtr2)
				sta (ZPPtr1),y
				dex
				bne .1
				
.8				tya
				sta	(ZPPtr1)
				clc
				rts	
*/--------------------------------------
* # PStrMatch
* Compare a String against pattern
* ## In: 
*   PUSHW = PTR to Pattern (e.g. '*test?.txt')
*   PUSHW = PTR to Src String 
* ## Out: 
*   CC : match
*   CS : no match
*\--------------------------------------
K.PStrMatch		jsr PullPtr1Ptr2

				lda (ZPPtr2)			Keep Pattern Length in X 
                tax 
                beq .8                  Match always if empty 
				ldy #0

.1				inc ZPPtr2				Make PTR1 advance to next char 
                bne .2 
				inc ZPPtr2+1 

.2				lda (ZPPtr2)       		get pattern char 
				cmp #'*' 
				beq .5
                                        
.3				tya						we must match ? or regular char 
                cmp (ZPPtr1)       		check if at end of string 
                beq .9                  yes, no char left, exit with error 
                                        
				iny                     advance to next char to compare 
                                                
				lda (ZPPtr2)       		get back pattern char 
				cmp #'?' 
				beq .4                  no need to compare, any char will match 
				cmp (ZPPtr1),y     		Regular Char, compare with string at Y 
				bne .9                  no match, exit 
                                        
.4				dex 					char matched, check if end of pattern 
				bne .1					continue if remaining char in pattern 

				tya						end of pattern, but end of string ? 
				cmp (ZPPtr1)       		end of string ? 
				beq .8					yes, string matched entirely 
				bra .9					no, remaining char in string, no match 

.5				dex						we have '*', last char of pattern ? 
				beq .8					yes, match everything, including empty string 
                                        
				inc ZPPtr2				Make PTR1 advance to next char 
				bne .6 
				inc ZPPtr2+1 
                                        
.6				lda (ZPPtr2)       		get next char of pattern 
				cmp #'*'				another '*' ? 
				beq .5					yes, '**' = '*', go next char 
				cmp #'?'				'*?' ??? we must match a least one char 
				beq .3 
                                        
.7				tya						we need at least one remaining char in string, 
				cmp (ZPPtr1)       		check if at end of string 
				beq .9					no chance to match ? or regular char 
                                        
				iny 
				lda (ZPPtr2)       		get again char in pattern 
				cmp (ZPPtr1),y 			compare with char in string 
                bne .7  	            not equal to next non wildcard in pattern 

				bra .4                  go check remaining char in pattern... 
                                        
.8				clc 
                rts 
                                        
.9              sec 
                rts 
*/--------------------------------------
* # PStrUprYA/PStrLwrYA
* Convert string to UPPERCASE/lowercase
* ## In:
*   Y,A = PTR to String (PSTR)
* ## Out:
*   Uppercased/lowercased String in Buffer
*\--------------------------------------
K.PStrUprYA		ldx #0
				.HS 2C					bit abs
K.PStrLwrYA		ldx #2
				>STYA ZPPtr1
				
				pha						save Y,A to restore them at exit
				phy
				
				lda (ZPPtr1)
				tay
				
.1				lda (ZPPtr1),y
				cmp K.PStrUprLwr,x
				bcc .2
				cmp K.PStrUprLwr+1,x
				bcs .2
				eor #$20
				sta (ZPPtr1),y
.2				dey
				bne .1
				
				ply
				pla
				clc
				rts
*--------------------------------------
K.PStrUprLwr	.AS "azAZ"
*--------------------------------------
K.PStr2CStrYA	>STYA ZPPtr1
				lda (ZPPtr1)
				beq .8
				pha
				
				tay
				
.1				lda (ZPPtr1),y
				dey
				sta (ZPPtr1),y
				tya
				bne .1
				ply
				sta (ZPPtr1),y			Ending 0
				
.8				rts
*--------------------------------------
K.CStr2PStrYA	>STYA ZPPtr1

				ldy #0
				
.1				lda (ZPPtr1),y
				beq .9
				
.2				pha				
				iny
				lda (ZPPtr1),y
				tax
				pla
				sta (ZPPtr1),y
				txa
				bne .2
				
.8				tya
				sta (ZPPtr1)
.9				rts
*--------------------------------------
MAN
SAVE /A2OSX.SRC/SYS/KERNEL.S.STR
LOAD /A2OSX.SRC/SYS/KERNEL.S
ASM
