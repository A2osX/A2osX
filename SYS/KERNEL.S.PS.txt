NEW
PREFIX
AUTO 4,1
*--------------------------------------
PS.Flags		.BS 1
PS.ArgV			.BS 2
*/--------------------------------------
* # ExecL
* ## C
* `int execl(const char* cmdline, short int flags);`
* ## ASM
* `>PUSHB flags`
* `>LDYA cmdline`
* `>SYSCALL execl`
* ## RETURN VALUE
* A = Child PSID
*\--------------------------------------
K.ExecL			sty .1+1
				sta .2+1
				>PULLB PS.Flags

				>LDYAI 256
				jsr K.GetMem
				bcs .99
				
				stx .90+1
				>STYA PS.ArgV
				>PUSHYA
.1				ldy #$ff				SELF MODIFIED
.2				lda #$ff				SELF MODIFIED

				jsr K.Args2ArgV

				bcs .9
				
				jsr PS.Exec
				
.9				php				
				pha
.90				lda #$ff				SELF MODIFIED
				jsr K.FreeMem
				pla
				plp
				
.99				rts				
*/--------------------------------------
* # ExecV
* ## C
* `int exec(const char* argv[], short int flags);`
* ## ASM
* `>PUSHB flags`
* `>LDYA argv`
* `>SYSCALL execv`
* ## RETURN VALUE
* A = Child PSID
*\--------------------------------------
K.ExecV			>STYA PS.ArgV
				>PULLB PS.Flags
				
PS.Exec			jsr PS.CreateChild		Child S.PS at ZPPtr3
				bcs .9

				sta .8+1

				>LDYA PS.ArgV
				jsr PS.DupArgs
				bcs .9
				ldy #S.PS.hARGV
				sta (ZPPtr3),y
				pha
				dey						S.PS.ARGC
				txa
				sta (ZPPtr3),y

				pla
				>SYSCALL GetMemPtr

				jsr PS.Load
				bcc .8
				
				pha						save error code
				lda .8+1
				jsr CORE.PSFree
				pla						get back error code
				sec
				rts

.8				lda #$ff				self modified
.9				rts
*--------------------------------------
* PS.CreateChild
*  in :
*  out :
*   A = PSID
* we cannot use ZPPtrs1 & 2
* because of calling K.NewStr.YA & PS.Dup
*--------------------------------------
PS.CreateChild	ldx CORE.PSCount
				beq .3
				
				ldx #0
				
.1				lda PS.Table.PID,x
				beq .4					Found an empty slot
				
				inx
				cpx CORE.PSCount
				bne .1
				
				cpx #K.PS.MAX
				bne .3
				
				lda #E.OOH
				sec
				rts

.99				plx				
				rts
				
.3				inc CORE.PSCount				
				
.4				inc CORE.LastPSID		Get a PSID not already running
				beq .4					not = 0
				lda CORE.LastPSID
				jsr CORE.GetPS			Y=PS Index, X,A unmodified
				bcc .4					running...loop

				lda CORE.LastPSID
				sta PS.Table.PID,x
				phx						save PS Index
				
				>LDYAI S.PS
				jsr K.GetMem0			Blank Everything in this S.PS
				bcs .99
				
				>STYA ZPPtr3
				txa
				plx
				sta PS.Table.hPS,x
				
				jsr PS.SetMemOwner		Set Ownership

				ldy #S.PS.PID
				lda CORE.LastPSID
				sta (ZPPtr3),y

				lda #S.PS.F.DUPENV
				bit PS.Flags			need to create ENV & Prefix ?	
				beq .6					no...
				
				sta (ZPPtr3)			Mark this PS with DUPENV flag
				
				ldy #S.PS.hPREFIX		copy hPREFIX...
				lda (pPs),y
				jsr K.GetMemPtr
				jsr K.NewStr
				bcs .9
				
				jsr PS.SetMemOwner	Set Ownership

				txa
				ldy #S.PS.hPREFIX
				sta (ZPPtr3),y
				
				ldy #S.PS.hENV			...and hENV from parent PS
				lda (pPs),y
				jsr PS.DupEnv
				bcs .9
				
				ldy #S.PS.hENV
				sta (ZPPtr3),y
				bra .8
				
.6				ldy #S.PS.hPREFIX		reuse same hPREFIX...
				lda (pPs),y
				sta (ZPPtr3),y
				
				ldy #S.PS.hENV			...and hENV from parent PS
				lda (pPs),y
				sta (ZPPtr3),y
				
.8				ldy #S.PS.hStdIn

.81				lda (pPs),y
				sta (ZPPtr3),y
				iny
				cpy #S.PS.hStdErr+1
				bne .81
				
				ldy #S.PS.PID
				lda (pPs),y
				
				ldy #S.PS.PPID
				sta (ZPPtr3),y

				lda #S.PS.F.HOLD
				bit PS.Flags
				beq .82
				
				ora (pPs)
				sta (pPs)				HOLD parent PS
				
.82				lda #S.PS.F.INIT
				ora (ZPPtr3)
				sta (ZPPtr3)			Make this PS Init....

				ldy #S.PS.CPID
				lda CORE.LastPSID
				sta (pPs),y

				clc						Exit with A=PSID
.9				rts
*--------------------------------------
PS.Load			jsr BIN.Load			Y,A=filename full path
				bcs .9
				>STYA ZPPtr4			save PTR to Code Segment
				
				phy
				ldy #S.PS.ZP.CODE+1
				sta (ZPPtr3),y			save pCode HI...
				dey
				pla
				sta (ZPPtr3),y			save pCode LO...
				
				txa
				ldy #S.PS.hCS
				sta (ZPPtr3),y			save CS hMem in S.PS

*				jsr K.GetMemByID
*				jsr PS.SetMemOwner		Set Ownership

				ldy #H.BIN.F			Get Bin S.PS.F
				lda (ZPPtr4),y
				beq .1
				
				ldy #S.PS.F				update PS S.PS.F
				ora (ZPPtr3),y
				sta (ZPPtr3),y

.1				ldy #H.BIN.DS.SIZE+1
				lda (ZPPtr4),y			Load DS.SIZE HI
				tax
				dey	
				ora (ZPPtr4),y

				beq .2					DS.SIZE=0...

				lda (ZPPtr4),y
				tay
				txa						Y,A = DS.SIZE
				ldx #S.MEM.F.INIT0+S.MEM.F.DATA
				jsr MEM.GetMem.YAX
				bcs .9

				phy
				ldy #S.PS.ZP.DATA+1
				sta (ZPPtr3),y			save pData HI...
				dey
				pla
				sta (ZPPtr3),y			save pData LO...

				txa
				ldy #S.PS.hDS
				sta (ZPPtr3),y			save DS hMem in S.PS

				jsr PS.SetMemOwner		Set Ownership

.2				ldy #H.BIN.SS.SIZE
				lda (ZPPtr4),y			Load SS.SIZE

				ldy #S.PS.ZP.STACK
				sta (ZPPtr3),y			save pStack LO...
				
				tay						

				bne .3					SS.SIZE.LO=0, set as default $100
				lda #1					SS.SIZE.HI
				.HS 2C					bit abs
.3				lda #0

				ldx #S.MEM.F.ALIGN+S.MEM.F.STACK
				jsr MEM.GetMem.YAX
				bcs .9

				ldy #S.PS.ZP.STACK+1
				sta (ZPPtr3),y			save pStack HI...(LO alredy set to Stack TOP)

				txa
				ldy #S.PS.hSS
				sta (ZPPtr3),y			save SS hMem in S.PS

				jsr PS.SetMemOwner		Set Ownership
				
				ldy #H.BIN.ZP.SIZE
				lda (ZPPtr4),y
				clc
				adc #8					Add room for 4 saved PTR
				ldy #S.PS.ZP.SIZE
				sta (ZPPtr3),y

				clc
.9				rts
*--------------------------------------
* PS.DupArgs
*  In:
*   Y,A = Ptr To Args[]
*  Out:
*   A = hMem
*   X = Count
*--------------------------------------
PS.DupArgs		>STYA ZPPtr1
				
				>STYA ZPPtr2

				lda #1
				sta .7+1
				lda #0
				sta .8+1			len = 1 for array ending 0
			
.1				lda (ZPPtr2)
				beq .7
				
				ldy #0
				
.2				iny
				lda (ZPPtr2),y
				bne .2
				
				tya
				sec
				adc .7+1
				sta .7+1
				bcc .3
				
				inc .8+1
				
.3				tya
				sec
				adc ZPPtr2
				sta ZPPtr2
				bcc .1
				inc ZPPtr2+1
				bra .1

.7				ldy #$ff				SELF MODIFIED
.8				lda #$ff				SELF MODIFIED

				bra PS.DupStrV
*--------------------------------------
* PS.DupEnv
*  In:
*   A = ENV hMem To Duplicate
*  Out:
*   A = hMem to new ENV
*   X = Count
*--------------------------------------
PS.DupEnv		jsr K.GetMemPtr
				>STYA ZPPtr1
				
				>LDYAI K.ENV.SIZE
				
PS.DupStrV		jsr K.GetMem
				bcs .9
				
				>STYA ZPPtr2
				phx						save hMem
				
				jsr PS.SetMemOwner		Set Ownership
				
				ldx #0					Count
				
.1				lda (ZPPtr1)
				sta (ZPPtr2)
				beq .8					Ending \0
				
				inx
				
				ldy #0
				
.2				iny
				lda (ZPPtr1),y
				sta (ZPPtr2),y
				bne .2
				
				tya
				sec
				adc ZPPtr1
				sta ZPPtr1
				bcc .3
				
				inc ZPPtr1+1
				
.3				tya
				sec
				adc ZPPtr2
				sta ZPPtr2
				bcc .1
				inc ZPPtr2+1
				bra .1
				
.8				pla						hMem
				
				clc
.9				rts
*--------------------------------------
PS.SetMemOwner	lda CORE.LastPSID
				ldy #S.MEM.OWNERPID
				sta (ZPMEMMGR),y
				rts
*/--------------------------------------
* # GetPSStatus
* **In:**
*  A = PID
* ## RETURN VALUE
*  A = Status Byte
*\--------------------------------------
K.GetPSStatus	jsr CORE.GetPSByID
				bcs .9
				>STYA ZPPtr1
				lda (ZPPtr1)
.9				rts
*/--------------------------------------
* # GetPSStat
* **In:**
*  Y,A = Ptr to K.PS.MAX*2+1 bytes buffer
* ## RETURN VALUE
*  Buffer filled with PS stats
*\--------------------------------------
K.GetPSStat		>STYA ZPPtr1

				ldx #0
				
				ldy #1
				lda CORE.InKernelStats
				sta (ZPPtr1),y
				
				iny
				
.1				lda PS.Table.PID,x
				beq .2
				
				lda PS.Table.hPS,x
				sta (ZPPtr1),y
				iny

				lda PS.Table.Stats,x
				sta (ZPPtr1),y
				iny
				
.2				inx
				cpx #K.PS.MAX
				bne .1
				
.9				tya
				lsr
				dec
				sta (ZPPtr1)
				rts
*--------------------------------------
MAN
SAVE USR/SRC/SYS/KERNEL.S.PS
LOAD USR/SRC/SYS/KERNEL.S
ASM
