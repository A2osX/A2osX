NEW
  AUTO 3,1
*--------------------------------------
RAMSW.LIBC		dec IRQ.InKernel		Back To KERNEL

				sec						data in AUX RAM
				ror A2osX.IOOpt

				sta IO.CLRREADAUX
				sta IO.CLRWRITEAUX

				bit JMP.F,x
				bmi .1

				pha
				phy
				ldy #S.PS.A
				sta (pPS),y
				txa
				iny						#S.PS.X
				sta (pPS),y
				pla
				iny						#S.PS.Y
				sta (pPS),y
				tay
				pla

				jsr JMP.LIBCX

				inc IRQ.InKernel

				bcc RAMSW.2AUXRTS		no error from API ...

				tax						CS,A=0 ?
				bne RAMSW.2AUXRTS

				pla						get PC LO
				plx						get PC HI
				sec
				sbc #2
				bcs RAMSW.Sleep2

				dex

				bra RAMSW.Sleep2

.1				jsr JMP.LIBCX

				inc IRQ.InKernel
*--------------------------------------
RAMSW.2AUXRTS	sta IO.SETREADAUX
				sta IO.SETWRITEAUX

RAMSW.RTS		rts						Unmodified Carry
*--------------------------------------
RAMSW.LibCall	dec IRQ.InLib

				>STYA .1+1

				pha
				phy
				ldy #S.PS.A
				sta (pPS),y
				txa
				iny						#S.PS.X
				sta (pPS),y
				pla
				iny						#S.PS.Y
				sta (pPS),y
				pla

.1				jsr $FFFF				SELF MODIFIED

				inc IRQ.InLib

				bcc RAMSW.RTS

				tax						CS,A=0 ?
				bne RAMSW.RTS

				sta IO.CLRREADAUX
				sta IO.CLRWRITEAUX

				pla						get PC LO
				plx						get PC HI
				sec
				sbc #2
				bcs RAMSW.Sleep2

				dex

				bra RAMSW.Sleep2
*--------------------------------------
RAMSW.Sleep		sta IO.CLRREADAUX
				sta IO.CLRWRITEAUX

				php
				sei

				phy
				ldy #S.PS.A
				sta (pPS),y

				txa
				iny						#S.PS.X
				sta (pPS),y

				pla
				iny						#S.PS.Y
				sta (pPS),y

				pla
				iny						#S.PS.P
				sta (pPS),y

				pla						get PC LO
				plx						get PC HI

				inc						Advance one byte because of return by RTI
				bne RAMSW.Sleep2

				inx
*--------------------------------------
RAMSW.Sleep2	ldy #S.PS.PC
				sta (pPS),y

				txa
				iny						#S.PS.PC+1
				sta (pPS),y

				tsx

				inx						Stack Ptr is $1ff if empty

				inx
				inx

				inx						keep PC HI,LO from KERNEL
				inx						jsr to PSExecX/PSResume

				sta IO.SETWRITEAUX

				txa
				beq .3

				tay						Save !Byte count for later

.2				pla
				>PUSHA
				inx
				bne .2

				tya

.3				>PUSHA					push CPU Stack BC to restore on top of Soft Stack

				sta IO.CLRWRITEAUX

				>INCW $1fc				PC=PC+1 because of RTI

				lda (pPS)
				ora #S.PS.F.SLEEP
				sta (pPS)

				lda #0					cld,clc,cli
				pha
				rti						exit to kernel with CC
*--------------------------------------
RAMSW.JMPX		sta IO.SETREADAUX
				sta IO.SETWRITEAUX

				lda #0
				sta (pRWReg)

				jsr JMPX

				lda A2osX.ActBnk
				sta (pRWReg)

				bra RAMSW.2MAINRTS
*--------------------------------------
RAMSW.2AUXJSR	sta IO.SETREADAUX
				sta IO.SETWRITEAUX

RAMSW.2AUX		.EQ *+1
				jsr $ffff				SELF MODIFIED

RAMSW.2MAINRTS	sta IO.CLRREADAUX
				sta IO.CLRWRITEAUX
				rts
*--------------------------------------
RAMSW.FPU		dec IRQ.InKernel

				cpx #FPU.fMUL
				bcs .1

				jsr INT					int16 & int32

				inc IRQ.InKernel

				rts

.1				sta IO.CLRREADAUX
				sta IO.CLRWRITEAUX

				jsr FPU

				bra RAMSW.KAPIRTS
*--------------------------------------
RAMSW.KAPI		dec IRQ.InKernel

				sta IO.CLRWRITEAUX
				sta IO.CLRREADAUX

				jsr JMP.APIX

RAMSW.KAPIRTS	sta IO.SETREADAUX
				sta IO.SETWRITEAUX

				inc IRQ.InKernel

				rts
*--------------------------------------
RAMSW.PSExec	ldy #S.PS.S
				lda (pPS),y
				tax

RAMSW.PSExecX	jsr .8

				sta IO.CLRREADAUX
				sta IO.CLRWRITEAUX
				dec IRQ.InKernel		Back to KERNEL

				rts

.8				lda pCode+1
				pha
				lda pCode
				pha

				php
				bra RAMSW.2AUXRTI
*--------------------------------------
RAMSW.PSResume	jsr .1

				sta IO.CLRREADAUX
				sta IO.CLRWRITEAUX
				dec IRQ.InKernel		Back To KERNEL
				cli
				rts

.1				sta IO.SETREADAUX

				lda (pStack)			Get 6502 stack !ByteCount
				inc pStack
				tax
				beq .3

.2				lda (pStack)
				inc pStack
				pha

				inx
				bne .2

.3				sta IO.CLRREADAUX

				ldy #S.PS.PC+1
				lda (pPS),y
				pha
				dey						#S.PS.PC
				lda (pPS),y
				pha
				dey						#S.PS.P
				lda (pPS),y
				pha
				dey						#S.PS.Y
				lda (pPS),y
				pha
				dey						#S.PS.X
				lda (pPS),y
				tax
				dey						#S.PS.A
				lda (pPS),y

				ply

RAMSW.2AUXRTI	sei

				inc IRQ.InKernel		Out of KERNEL

				sta IO.SETREADAUX
				sta IO.SETWRITEAUX

				rti						will do CLI
*--------------------------------------
RAMSW.StkY2TXTPTR
				sta IO.SETREADAUX
				lda (pStack),y
				sta TXTPTR
				iny
				lda (pStack),y
				sta TXTPTR+1
				sta IO.CLRREADAUX
				rts
*--------------------------------------
RAMSW.xTXTPTRng	>INCW TXTPTR
*--------------------------------------
RAMSW.xTXTPTRg	sta IO.SETREADAUX
				lda (TXTPTR)
				sta IO.CLRREADAUX
				rts
*--------------------------------------
RAMSW.xTXTPTRc	sta IO.SETREADAUX
				cmp (TXTPTR)
				sta IO.CLRREADAUX
				rts
*--------------------------------------
RAMSW.xTXTPTRgY	sta IO.SETREADAUX
				lda (TXTPTR),y
				sta IO.CLRREADAUX
				rts
*--------------------------------------
RAMSW.xTXTPTRgn	sta IO.SETREADAUX
				lda (TXTPTR)
				sta IO.CLRREADAUX
				beq .9

				>INCW TXTPTR

.9				rts
*--------------------------------------
RAMSW.StkY2FORPNT
				sta IO.SETREADAUX
				lda (pStack),y
				sta FORPNT
				iny
				lda (pStack),y
				sta FORPNT+1
				sta IO.CLRREADAUX
				rts
*--------------------------------------
RAMSW.xTXTPTRl	sta IO.SETREADAUX

				lda TXTPTR+1
				pha

				ldx #0
				ldy #0

.1				lda (TXTPTR),y
				beq .8

				iny
				bne .1

				inc TXTPTR+1
				inx
				bra .1

.8				pla
				sta TXTPTR+1

				txa

				sta IO.CLRREADAUX
				rts
*--------------------------------------
RAMSW.xFORPNTgY	sta IO.SETREADAUX
				lda (FORPNT),y
				sta IO.CLRREADAUX
				rts
*--------------------------------------
RAMSW.xFORPNTgn	sta IO.SETREADAUX
				lda (FORPNT)
				sta IO.CLRREADAUX
				beq .9

				>INCW FORPNT

.9				rts
*--------------------------------------
RAMSW.xA1LgY	sta IO.SETREADAUX
				lda (A1L),y
				sta IO.CLRREADAUX
				rts
*--------------------------------------
RAMSW.xP1g		sta IO.SETREADAUX
				lda (ZPPtr1)
				sta IO.CLRREADAUX
				rts
*--------------------------------------
RAMSW.xP1gY		sta IO.SETREADAUX
				lda (ZPPtr1),y
				sta IO.CLRREADAUX
				rts
*--------------------------------------
RAMSW.xP2gY		sta IO.SETREADAUX
				lda (ZPPtr2),y
				sta IO.CLRREADAUX
				rts
*--------------------------------------
RAMSW.xP3g		sta IO.SETREADAUX
				lda (ZPPtr3)
				sta IO.CLRREADAUX
				rts
*--------------------------------------
RAMSW.xP3gY		sta IO.SETREADAUX
				lda (ZPPtr3),y
				sta IO.CLRREADAUX
				rts
*--------------------------------------
RAMSW.xP3cY		sta IO.SETREADAUX
				cmp (ZPPtr3),y
				sta IO.CLRREADAUX
				rts
*--------------------------------------
RAMSW.pBufgY	sta IO.SETREADAUX
				lda (PS.pBuf),y
				sta IO.CLRREADAUX
				rts
*--------------------------------------
RAMSW.GetStk	sta IO.SETREADAUX
				lda (pStack)
				sta IO.CLRREADAUX
				rts
*--------------------------------------
RAMSW.GetStkY	sta IO.SETREADAUX
				lda (pStack),y
				sta IO.CLRREADAUX
				rts
*--------------------------------------
RAMSW.GetStkYW	sta IO.SETREADAUX
				lda (pStack),y
				pha
				iny
				lda (pStack),y
				ply
				sta IO.CLRREADAUX
				rts
*--------------------------------------
RAMSW.YA2PathBuf
				sta IO.SETREADAUX

				>STYA .2+1

				ldx #$ff

.1				inx

.2				lda $ffff,x				SELF MODIFIED
				sta K.PathBuf,x
				bne .1

				sta IO.CLRREADAUX
				rts
*--------------------------------------
RAMSW.GetPSy	lda IO.RDREADAUX
				bpl .1

				sta IO.CLRREADAUX
				lda (pPS),y
				sta IO.SETREADAUX
				rts

.1				lda (pPS),y
				rts
*--------------------------------------
*RAMSW.GetPSyW	lda IO.RDREADAUX
*				bpl .1
*
*				sta IO.CLRREADAUX
*
*				lda (pPS),y
*				pha
*				iny
*				lda (pPS),y
*				ply
*
*				sta IO.SETREADAUX
*				rts
*
*.1				lda (pPS),y
*				pha
*				iny
*				lda (pPS),y
*				ply
*				rts
*--------------------------------------
RAMSW.SetPSy	bit IO.RDWRITEAUX
				bpl .1

				sta IO.CLRWRITEAUX
				sta (pPS),y
				sta IO.SETWRITEAUX
				rts

.1				sta (pPS),y
				rts
*--------------------------------------
* From BLIST
*--------------------------------------
BLIST.GetDBlkY	sta IO.SETREADAUX
				lda (pDBlk),y
				sta IO.CLRREADAUX
				rts
*--------------------------------------
BLIST.GetDBlkYB	lda SLIST.Bnk
				sta (pRWReg)

				sta IO.SETREADAUX
				lda (pDBlk),y
				sta IO.CLRREADAUX

				pha
				lda A2osX.ActBnk
				sta (pRWReg)
				pla

				rts
*--------------------------------------
* From DRV
*--------------------------------------
RAMSW.GetZPpBuf	bit A2osX.IOOpt
				bpl .1

				sta IO.SETREADAUX
				lda (ZPpBuf)
				sta IO.CLRREADAUX
				rts

.1				lda (ZPpBuf)
				rts
*--------------------------------------
RAMSW.GetBnkStat
				sta IO.SETREADAUX

				ldx #7

.1				lda MEM.LoMem,x
				sta STAT.BnkStat,x
				dex
				bpl .1

				sta IO.CLRREADAUX
				rts
*--------------------------------------
RAMSW.AY2FAC	sta ZPPtr1				printf
				sty ZPPtr1+1

				sta IO.SETREADAUX

				ldy #4

.1				lda (ZPPtr1),y
				sta FAC,y
				dey
				cpy #1
				bne .1

				lda (ZPPtr1),y
				sta FACSGN
				ora #$80
				sta FAC+1

				lda (ZPPtr1)
				sta FAC
				stz FAC.EXT

				sta IO.CLRREADAUX
				rts
*--------------------------------------
RAMSW.AY2ARG	sta ZPPtr1
				sty ZPPtr1+1

				sta IO.SETREADAUX

				ldy #4

.1				lda (ZPPtr1),y
				sta ARG,y
				dey
				cpy #1
				bne .1

				lda (ZPPtr1),y
				sta ARGSGN
				eor FACSGN
				sta SGNCPR

				lda ARGSGN
				ora #$80
				sta ARG+1

				lda (ZPPtr1)
				sta ARG

				sta IO.CLRREADAUX
				rts
*--------------------------------------
MAN
SAVE usr/src/sys/kernel.s.ramsw
LOAD usr/src/sys/kernel.s
ASM
