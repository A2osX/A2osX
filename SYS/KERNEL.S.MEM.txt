PR#3
PREFIX /A2OSX.SRC
NEW
INC 1
AUTO 6
				.LIST OFF
				.OP	65C02
*--------------------------------------
* !!!!!!!! DO NOT USE VCPU16 !!!!!!!!
* !!!!!! DO NOT USE ZPQuickPTRs !!!!!
*--------------------------------------
ZPMemMgrSPtr 	.EQ ZPMemMgr			Pointer To Slot selected
ZPMemMgrTmp1	.EQ ZPMemMgr+2
ZPMemMgrTmp2	.EQ ZPMemMgr+4
ZPMemMgrTmp3	.EQ ZPMemMgr+6
*--------------------------------------
* TODO :
*  - Create a 256 bytes table
*    mapping hMem's to real memory blocks to help 
*    Garbage collector move blocks
*  - mem.ID=0 always used! useful to test if hMem=0
*--------------------------------------
S.MemMgrInit	>LDYAI MemMgr.MHiMem
				>STYA MemMgr.HiMem
				>STYA MemMgr.Free
				
				>LDYAI MemMgr.MLoMem
				>STYA MemMgr.LoMem

				stz MemMgr.LastSlot		Reserve Slot #0

				sta SETREADAUX
				sta SETWRITEAUX
				
				>LDYAI MemMgr.XHiMem
				>STYA MemMgr.HiMem
				>STYA MemMgr.Free
				
				>LDYAI MemMgr.XLoMem
				>STYA MemMgr.LoMem

				stz MemMgr.LastSlot		Reserve Slot #0
				
				sta CLRREADAUX
				sta CLRWRITEAUX
								
				clc
				rts
*--------------------------------------
*               PUBLIC
*--------------------------------------
* S.GetMem
*  In: 
*	PULLB = FLAGS 
*   PULLW = Size Requested
*  Out:
*   YA = PTR to Mem
*	X = S.MEM.ID
*   CS on err
*--------------------------------------
S.GetMem		>PULLB MemMgr.ReqFlags	store requested flags
				and #S.MEM.F.AUX
				beq .11

				sta SETREADAUX			Aux Mem requested,switch to AUX
				sta SETWRITEAUX				
				
.11				>PULLW MemMgr.ReqSize	Store requested size
				lda MemMgr.ReqSize		align REQS to 16 bytes
				and #$0F
				beq .10
				
				lda MemMgr.ReqSize
				and #$F0
				clc
				adc #$10
				sta MemMgr.ReqSize
				bcc .10
				inc MemMgr.ReqSize+1
				
.10				>LDYAI MemMgr.Table
				>STYA ZPMemMgrSPtr
				
				ldx #0					Current slot=0

				lda MemMgr.LastSlot		Check if some free slot to reuse first
				beq .41
				
				sta MemMgr.SlotCnt
				
.1				inx						move to next slot
				jsr MemMgr.NextSlot
				lda (ZPMemMgrSPtr)		Get Flags
				bmi .4					in use ?
				
.2				lda MemMgr.ReqFlags		Found an empty slot
				and #S.MEM.F.ALIGN		is request needs a page align ?
				beq .3
				
				ldy #S.MEM.PTR
				lda (ZPMemMgrSPtr),y	get LO of PTR
				bne .4					not page-aligned
				
.3				ldy #S.MEM.LEN
				lda (ZPMemMgrSPtr),y	get LEN of this block
				cmp MemMgr.ReqSize		compare with requested size
				bne .4
				
				iny
				lda (ZPMemMgrSPtr),y
				cmp MemMgr.ReqSize+1
				beq .7					requested size matches slot size !!!
				
.4				dec MemMgr.SlotCnt		any other slot to check?
				bne .1					last one, create a new slot
*-------------- Create a New SLOT
.41				lda MemMgr.ReqFlags
				and #S.MEM.F.ALIGN		is request needs a page align ?
				beq .6
				
				lda MemMgr.Free			target PTR will be page aligned ?
				sec
				sbc MemMgr.ReqSize
				beq .6					yes, allocate
				
				tay						no, reserve a free slot to fill gap
				lda #0
				jsr MemMgr.AddSlot		X = new slot
				bcs .9
				
.6				>LDYA MemMgr.ReqSize
				jsr MemMgr.AddSlot		X = new slot
				bcs .9
*-------------- Reuse this SLOT
.7				lda MemMgr.ReqFlags		get requested flags
				ora #S.MEM.F.INUSE		mark as in use
				sta (ZPMemMgrSPtr)
				
				and #S.MEM.F.INIT0
				beq .8

				jsr MemMgr.Init0
				
.8				lda #0
				ldy #S.MEM.BIN
				sta (ZPMemMgrSPtr),y
				
				inc						Mark this slot used by one process
				ldy #S.MEM.REFCNT
				sta (ZPMemMgrSPtr),y
				
				ldy #S.PS.ID
				lda (pPs),y
				ldy #S.MEM.OWNERPID
				sta (ZPMemMgrSPtr),y
				
				ldy #S.MEM.PTR
				lda (ZPMemMgrSPtr),y
				pha
				iny
				lda (ZPMemMgrSPtr),y	A = HI PTR
				ply						Y = LO PTR	
				clc						X = Current hMem
				
.9				bit MemMgr.ReqFlags		
				bpl .99
				
				sta CLRREADAUX
				sta CLRWRITEAUX
				
.99				rts						
*--------------------------------------
* MemMgr.AddSlot
*  In:
*   Y,A = Requested size
*  Out: 
*--------------------------------------
MemMgr.AddSlot  >STYA ZPMemMgrTmp1		save req size
				ldx MemMgr.LastSlot		
				inx
				beq .99					> 255 ERR:OUT OF SLOT
				
				lda MemMgr.Free			Compute base PTR=FREE-REQ size
				sec
				sbc ZPMemMgrTmp1
				sta ZPMemMgrTmp2		store new MemMgr.Free in ZPMemMgrTmp2
				lda MemMgr.Free+1
				sbc ZPMemMgrTmp1+1
				sta ZPMemMgrTmp2+1

				lda ZPMemMgrTmp2		ensure new MemMgr.Free is not lower
				sec						than LoMem
				sbc MemMgr.LoMem
				lda ZPMemMgrTmp2+1
				sbc MemMgr.LoMem+1
				bcc .98					ERR out of mem

				jsr MemMgr.NextSlot
				
				ldy #S.MEM.PTR
				lda ZPMemMgrTmp2		get new MemMgr.Free
				sta MemMgr.Free			set as system MemMgr.Free value
				sta (ZPMemMgrSPtr),y	store is as base address of new slot
				iny
				lda ZPMemMgrTmp2+1
				sta MemMgr.Free+1
				sta (ZPMemMgrSPtr),y

				iny
				lda ZPMemMgrTmp1		get requested size
				sta (ZPMemMgrSPtr),y	setup slot LEN
				iny	
				lda ZPMemMgrTmp1+1
				sta (ZPMemMgrSPtr),y

				stx MemMgr.LastSlot		mark this slot allocated
				clc
				rts
				
.98				lda #MemMgr.ERROOM
				sec
				rts
				
.99				lda #MemMgr.ERROOH
				sec
				rts	
*--------------------------------------
MemMgr.NextSlot	lda ZPMemMgrSPtr
				clc
				adc #S.MEM.SIZE
				sta ZPMemMgrSPtr
				bcc .8
				inc ZPMemMgrSPtr+1
.8				rts								
*--------------------------------------
MemMgr.Init0	ldy #S.MEM.PTR
				lda (ZPMemMgrSPtr),y	ZPMemMgrSPtr already set
				sta ZPMemMgrTmp1		set ZPMemMgrTmp1 to Mem Ptr
				iny
				lda (ZPMemMgrSPtr),y
				sta ZPMemMgrTmp1+1
				
				ldy #S.MEM.LEN			
				lda (ZPMemMgrSPtr),y
				sta ZPMemMgrTmp2		set ZPMemMgrTmp2 to mem size
				iny
				lda (ZPMemMgrSPtr),y
				sta ZPMemMgrTmp2+1
				
				lda #0
				
.1				ldy ZPMemMgrTmp2
				bne .2
				ldy ZPMemMgrTmp2+1
				beq .3
				dec ZPMemMgrTmp2+1
.2				dec ZPMemMgrTmp2

				sta (ZPMemMgrTmp1)
				inc ZPMemMgrTmp1
				bne .1
				inc ZPMemMgrTmp1+1
				bra .1
				
.3				rts
*--------------------------------------
MemMgr.SlotCnt	.BS 1
MemMgr.ReqFlags	.BS 1					store requested Flags
MemMgr.ReqSize 	.BS 2					store requested Size
*--------------------------------------
* S.FreeMemA
* In:
*  A = hMem To Free
* Out:
*  X,Y unmodified
*--------------------------------------
S.FreeMemA	    phy
				phx
				tax
				beq .8					Slot=0, reserved by Kernel
				
				jsr S.GetMemByIDA
				lda (ZPMemMgrSPtr)
				bpl *					In use ?
				
				ldy #S.MEM.REFCNT
				lda (ZPMemMgrSPtr),y	Get count of those referencing this hMem
				dec						only one left ?	
				sta (ZPMemMgrSPtr),y
				bne .8					no, must be a code segment loaded several times
				
				ldy #S.MEM.BIN
				lda (ZPMemMgrSPtr),y	Any BINPATH to discard ?		
				beq .1
				
				pha						save hMem
				>PUSHW ZPMemMgrSPtr
				pla
				jsr S.GetMemByIDA
				lda (ZPMemMgrSPtr)
				bpl *					***MUST BE ALLOCATED***
				
				lda #0					mark BINPATH slot as free
				sta (ZPMemMgrSPtr)
				>PULLW ZPMemMgrSPtr
				
.1				lda #0					mark this slot as free
				sta (ZPMemMgrSPtr)

.2				lda MemMgr.LastSlot
				beq .8
				
				jsr S.GetMemByIDA
				lda (ZPMemMgrSPtr)
				bmi .8
				
				ldy #S.MEM.LEN
				lda (ZPMemMgrSPtr),y	give back LEN bytes
				clc
				adc MemMgr.Free			to MemMgr.Free
				sta MemMgr.Free
				iny
				lda (ZPMemMgrSPtr),y
				adc MemMgr.Free+1
				sta MemMgr.Free+1
				
				dec	MemMgr.LastSlot		discard last slot	
				bne .2					no slot left, exit

.8				plx
				ply
				clc
				rts
*--------------------------------------
* S.GetMemPtrA
* In:
*   A = hMem
* Out:
*	Y,A = PTR to MemBlock
*   X unmodified
*--------------------------------------
S.GetMemPtrA	jsr S.GetMemByIDA
				ldy #S.MEM.PTR
				lda (ZPMemMgrSPtr),y
				pha
				iny
				lda (ZPMemMgrSPtr),y
				ply
				rts
*--------------------------------------
* S.GetMemByIDA
* In:
*   A = hMem
* Out:
*	Y,A = ZPMemMgrSPtr = PTR to S.MEM
*   X unmodified
*--------------------------------------
S.GetMemByIDA	stz ZPMemMgrSPtr+1
				
				asl
				rol ZPMemMgrSPtr+1
				asl
				rol ZPMemMgrSPtr+1
				asl
				rol ZPMemMgrSPtr+1
				
				clc
				adc #MemMgr.Table
				sta ZPMemMgrSPtr
				tay
				lda ZPMemMgrSPtr+1
				adc /MemMgr.Table
				sta ZPMemMgrSPtr+1
				rts
*--------------------------------------
* In:
*	A = hMem to BINPATH (PSTR)
* Out:
*	Y,A = ZPMemMgrSPtr = PTR to S.MEM
*   X = hMem
*--------------------------------------
S.GetMemByNameA	jsr S.GetMemPtrA
				bcs *
S.GetMemByNameYA
				>STYA ZPMemMgrTmp1		save BINPATH
				>LDYAI MemMgr.Table+S.MEM.SIZE
				>STYA ZPMemMgrSPtr		
				ldx #0
				
.1				cpx MemMgr.LastSlot
				beq .9
				inx
				lda (ZPMemMgrSPtr)
				bpl .6					In Use?
				
				ldy #S.MEM.BIN			any BIN PATH in this slot?	
				lda (ZPMemMgrSPtr),y
				beq .6
				
				jsr S.GetMemPtrA		get pathname
				>STYA ZPMemMgrTmp2
				
				ldy #0
				
.2				lda (ZPMemMgrTmp1),y
				cmp (ZPMemMgrTmp2),y
				bne .6
				
				tya
				iny
				cmp (ZPMemMgrTmp1)
				bne .2
				
				>LDYA ZPMemMgrSPtr
				
				bra *
				
				clc
				rts
				
.6				lda ZPMemMgrSPtr
				clc
				adc #S.MEM.SIZE
				sta ZPMemMgrSPtr
				bcc .1
				inc ZPMemMgrSPtr+1
				bra .1
				
.9				sec
				rts
*--------------------------------------
S.SetLoMem
				clc
				rts
*--------------------------------------
S.GarbageCollector
				clc
				rts
*--------------------------------------
MAN
SAVE SYS/KERNEL.S.MEM
LOAD SYS/KERNEL.S
ASM
