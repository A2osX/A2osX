NEW
  AUTO 3,1
*/--------------------------------------
* # Realloc
* ## C / CSH
* `#include <stdlib.h>`
* `void *realloc(void *ptr, size_t size);`
* ## ASM
* `>SS`
* `>PUSHW ptr`
* `>PUSHW size`
* `>LIBC realloc`
* `>SR`
* ## RETURN VALUE
*  YA = ptr
*  X = hMem
*\--------------------------------------
K.Realloc		sta IO.SETREADAUX
				sta IO.SETWRITEAUX

				ldy #2					ptr
				lda (pStack),y
				pha
				iny
				lda (pStack),y
				ply

				jsr MEM.GetPtrYA
				bcs .99

				stx .8+1

				ldy #S.MEM.LEN
				lda (MEM.SPtr),y
				sta A4
				iny
				lda (MEM.SPtr),y
				sta A4+1

				lda (MEM.SPtr)
				and #$7F
				tax

				lda (pStack)			size
				pha
				ldy #1
				lda (pStack),y
				ply

				jsr MEM.Malloc.YAX
				bcs .99

				>STYA A2

				jsr MEM.Cpy

.8				lda #$FF				SELF MODIFIED
				jsr MEM.FreeA

				>LDYA A2

*				clc

.99				jmp RAMSW.2MAINRTS
*/--------------------------------------
* # Malloc
* ## C / CSH
* `#include <stdlib.h>`
* `void *malloc(size_t size);`
* ## ASM
* `>LDYAI size`
* `>LIBC malloc`
* ## RETURN VALUE
*  CC : success
*   YA = PTR to Mem (Uninitialised)
*	X = hMem
*  CS :
*   A = EC
*\--------------------------------------
K.Malloc		ldx #0

MEM.MallocX.YAX	sta IO.SETREADAUX
				sta IO.SETWRITEAUX
				jsr MEM.Malloc.YAX
				jmp RAMSW.2MAINRTS
*--------------------------------------
MEM.Malloc		ldx #0

MEM.Malloc.YAX	stx MEM.ReqF
				sta MEM.ReqS+1

				tya
				bit #K.MEM.ALIGN-1		aligned ?
				beq .10					yes, request it

				and #K.MEM.nALIGNm1		align on boundary
				clc
				adc #K.MEM.ALIGN
				bcc .10

				inc MEM.ReqS+1

.10				sta MEM.ReqS

				>LDYAI MEM.LoMem
				>STYA MEM.SPtr
				stz MEM.Best
				ldx #$ff
				stx MEM.Tmp
				stx MEM.Tmp+1
				ldx #0					Current slot=0
				bra .4					skip slot 0, Check if some free slot to reuse first

.1				inx						move to next slot
				jsr MEM.NextSlot
				lda (MEM.SPtr)			Get Flags
				bmi .4					in use ?

.2				lda MEM.ReqF			Found an empty slot
				bit #S.MEM.F.NOCROSS
				beq .21

				ldy MEM.ReqS+1			> 255, not applicable
				bne .22					Align to page if $100

				ldy #S.MEM.PTR
				lda (MEM.SPtr),y		get LO of PTR
				clc
				adc MEM.ReqS
				bcs .4					cross page boundary....

				lda MEM.ReqF			get back flags to test if match

.21				bit #S.MEM.F.ALIGN		is request needs a page align ?
				beq .3

.22				ldy #S.MEM.PTR
				lda (MEM.SPtr),y		get LO of PTR
				bne .4					not page-aligned

.3				ldy #S.MEM.LEN
				sec
				lda (MEM.SPtr),y		get LEN of this block
				sbc MEM.ReqS			compare with requested size
				pha
				iny
				lda (MEM.SPtr),y
				sbc MEM.ReqS+1
				ply						Y,A = SlotLen - ReqSize
				bcc .4					req size > slot size

				cpy MEM.Tmp
				pha
				sbc MEM.Tmp+1
				pla
				bcs	.4					Delta is >= BestScore
				bne .4					Delta is > 255...

				sty MEM.Tmp
				sta MEM.Tmp+1
				stx MEM.Best

.4				cpx MEM.LastSlot		any other slot to check?
				bne .1					last one, create a new slot

				lda MEM.Best
				beq .5

				tax
				jsr MEM.GetA
				bra .7

*-------------- Create a New SLOT

.5				lda MEM.ReqF
				bit #S.MEM.F.NOCROSS
				beq .51

				lda MEM.ReqS+1			> 255, not applicable
				bne .52					Align to page if $100

				lda MEM.Free			target PTR will be in same page ?
				beq .6					Memfree is xx00, will be in same page

				cmp MEM.ReqS
				bcs .6					yes, allocate

				tay						no, reserve a free slot to fill gap
				lda #0
				jsr MEM.AddSlot			X = new slot
				bcs .9

				lda #S.MEM.F.NOCROSS	Make sure marked FREE
				sta (MEM.SPtr)
				bra .6

.51				bit #S.MEM.F.ALIGN		is request needs a page align ?
				beq .6

.52				lda MEM.Free			target PTR will be page aligned ?
				sec
				sbc MEM.ReqS
				beq .6					yes, allocate

				tay						no, reserve a free slot to fill gap
				lda #0
				jsr MEM.AddSlot			X = new slot
				bcs .9

				lda #S.MEM.F.ALIGN		Make sure marked FREE
				sta (MEM.SPtr)

.6				>LDYA MEM.ReqS
				jsr MEM.AddSlot			X = new slot
				bcs .9

*-------------- Reuse this SLOT

.7				phx

				lda MEM.ReqF			get requested flags
				ora #S.MEM.F.INUSE		mark as in use
				sta (MEM.SPtr)
				and #S.MEM.F.INIT0
				beq .8

				jsr MEM.Init0

.8				lda #1
				ldy #S.MEM.REFCNT
				sta (MEM.SPtr),y

				lda MEM.ReqF
				and #S.MEM.F.CODE
				bne .88

				bit IO.RDREADAUX
				php

				sta IO.CLRREADAUX

				ldy #S.PS.PID
				lda (pPS),y
				tax
				iny
				lda (pPS),y

				plp
				bpl .80

				sta IO.SETREADAUX

.80				ldy #S.MEM.OWNER+1
				sta (MEM.SPtr),y
				txa
				dey
				sta (MEM.SPtr),y

.88				plx

				clc

				jmp MEM.GetPtr
* A = HI PTR,Y = LO PTR,X = Current hMem
.9				rts
*--------------------------------------
* Mem.AddSlot
*  In:
*   Y,A = Requested size
*  Out:
*--------------------------------------
MEM.AddSlot  	>STYA MEM.Tmp			save req size
				ldx MEM.LastSlot
				cpx MEM.LastSlot+1
				beq .99					ERR:OUT OF handles

				inx

				lda MEM.Free			Compute base PTR=FREE-REQ size
				sec
				sbc MEM.Tmp
				tay						save new MEM.Free LO
				lda MEM.Free+1
				sbc MEM.Tmp+1
				bcc .99					crossed $0000

				pha						save new MEM.Free HI
				cpy MEM.LoMem
				sbc MEM.LoMem+1
				bcc .98					ERR out of mem

				jsr MEM.NextSlot		X,Y unmodified
				tya						get back MEM.Free LO
				ldy #S.MEM.PTR
				sta MEM.Free			set as system MEM.Free value
				sta (MEM.SPtr),y		store it as base address of new slot
				iny
				pla						get back MEM.Free HI
				sta MEM.Free+1
				sta (MEM.SPtr),y

				iny
				lda MEM.Tmp				get requested size
				sta (MEM.SPtr),y		setup slot LEN
				iny
				lda MEM.Tmp+1
				sta (MEM.SPtr),y

				stx MEM.LastSlot		mark this slot allocated

				clc
				rts

.98				pla						discard new Mem.Free HI

.99				lda #E.OOM
				sec
				rts
*--------------------------------------
MEM.NextSlot	lda MEM.SPtr
				clc
				adc #S.MEM
				sta MEM.SPtr
				bcc .8

				inc MEM.SPtr+1

.8				rts
*--------------------------------------
MEM.Init0		ldy #S.MEM.PTR
				lda (MEM.SPtr),y		MEM.SPtr already set
				sta .12+1
				iny
				lda (MEM.SPtr),y
				sta .12+2
				lda MEM.ReqS
				eor #$ff
				tay						y=not lo count
				lda MEM.ReqS+1
				eor #$ff				a=not hi count

				ldx #0

.11				iny
				bne .12

				inc
				beq .13

.12				stz $ffff,x
				inx
				bne .11

				inc .12+2
				bra .11

.13				rts
*/--------------------------------------
* # Free
* ## C / CSH
* `#include <stdlib.h>`
* `void free(void *ptr);`
* ## ASM
* `>LDYA ptr`
* `>LIBC free`
* ## RETURN VALUE
*  none.
*\--------------------------------------
K.Free			sta IO.SETREADAUX
				sta IO.SETWRITEAUX
				jsr MEM.FreeYA
				jmp RAMSW.2MAINRTS
*--------------------------------------
MEM.FreeYA		jsr MEM.GetPtrYA
				bcc MEM.FreeH

MEM.Err			>DEBUG
				lda #E.BADPTR
				sec
				rts
*--------------------------------------
MEM.FreeAX		sta IO.SETREADAUX
				sta IO.SETWRITEAUX
				jsr MEM.FreeA
				jmp RAMSW.2MAINRTS
*--------------------------------------
MEM.FreeA		jsr MEM.GetA
*--------------------------------------
MEM.FreeH		lda (MEM.SPtr)			In use ?
				bpl MEM.Err

				ldy #S.MEM.REFCNT
				lda (MEM.SPtr),y
				dec						only one left ?
				sta (MEM.SPtr),y
				bne .8					no, must be a code segment loaded several times

				lda (MEM.SPtr)
				and #$7f				keep flags for memdump
				sta (MEM.SPtr)			Mark as FREE
				and #S.MEM.F.CODE		CS: Any BINPATH to discard ?
				beq .1

				ldy #S.MEM.OWNER
				lda (MEM.SPtr),y
				pha
				iny
				lda (MEM.SPtr),y
				ply
				phx
				jsr MEM.GetPtrYA
				plx
			bcs *						***MUST BE ALLOCATED***
				lda (MEM.SPtr)
			bpl *						***MUST BE ALLOCATED***
				and #$7f				keep flags for memdump
				sta (MEM.SPtr)			mark BINPATH slot as free

.1				lda MEM.LastSlot
				beq .8

				jsr MEM.GetA			X unmodified
				lda (MEM.SPtr)
				bmi .8					used, exit

.2				dec	MEM.LastSlot		free! get previous....
				beq .80					empty list: go set MEM.Free=MEM.HiMem

				lda MEM.LastSlot
				jsr MEM.GetA			X unmodified
				lda (MEM.SPtr)
				bpl .2					free again! loop

				ldy #S.MEM.PTR
				lda (MEM.SPtr),y		set MEM.Free...
				sta MEM.Free
				iny
				lda (MEM.SPtr),y
				sta MEM.Free+1

.8				clc
				rts

.80				>LDYA MEM.HiMem
				>STYA MEM.Free
				clc
				rts
*--------------------------------------
* Optimized for :
* Mem.LoMem is page aligned at $B800
* S.MEM is 8 bytes
*--------------------------------------
				.DO MEM.LoMem=$B800
				.ELSE
				!!!!!WARNING!!!!!
				.FIN
				.DO S.MEM=8
				.ELSE
				!!!!!WARNING!!!!!
				.FIN
*--------------------------------------
MEM.AddBIN		sta IO.SETREADAUX
				sta IO.SETWRITEAUX

				pha
				txa
				jsr MEM.GetA

				tya
				ldy #S.MEM.OWNER
				sta (MEM.SPtr),y
				pla
				iny
				sta (MEM.SPtr),y

				lda (MEM.SPtr)
				ora #S.MEM.F.CODE
				sta (MEM.SPtr)

				jmp RAMSW.2MAINRTS
*--------------------------------------
MEM.FindByBIN	sta IO.SETREADAUX

				lda MEM.LastSlot

				tax

				jsr MEM.GetA

.1				lda (MEM.SPtr)
				bpl .7

				and #S.MEM.F.CODE
				beq .7

				ldy #S.MEM.OWNER
				lda (MEM.SPtr),y
				sta A1
				iny
				lda (MEM.SPtr),y
				sta A1+1

				ldy #$ff

.2				iny
				sta IO.CLRREADAUX
				lda K.PathBuf,y
				sta IO.SETREADAUX
				cmp (A1),y
				bne .7

				eor #0
				bne .2

				ldy #S.MEM.REFCNT
				lda (MEM.SPtr),y
				inc
				sta IO.SETWRITEAUX
				sta (MEM.SPtr),y
				sta IO.CLRWRITEAUX

				jsr MEM.GetPtr

				sta IO.CLRREADAUX
				clc
				rts

.7				lda MEM.SPtr
				sec
				sbc #S.MEM
				sta MEM.SPtr
				bcs .8

				dec MEM.SPtr+1

.8				dex
				bne .1

				sta IO.CLRREADAUX
				sec
				rts
*--------------------------------------
MEM.GetPtrX		sta IO.SETREADAUX
				jsr MEM.GetA
				jsr MEM.GetPtr
				sta IO.CLRREADAUX
				rts
*--------------------------------------
MEM.GetA		sta MEM.SPtr
				lda /MEM.LoMem/8
				asl MEM.SPtr
				rol
				asl MEM.SPtr
				rol
				asl MEM.SPtr
				rol
				sta MEM.SPtr+1
				rts
*--------------------------------------
MEM.GetPtr		ldy #S.MEM.PTR
				lda (MEM.SPtr),y
				pha
				iny
				lda (MEM.SPtr),y
				ply
				rts
*--------------------------------------
*MEM.IncRefCnt	ldy #S.MEM.REFCNT
*				lda (MEM.SPtr),y
*				inc
*				sta (MEM.SPtr),y
*				rts
*--------------------------------------
MEM.GetRefCntX	sta IO.SETREADAUX

				jsr MEM.GetPtrYA
				bcs .9

				ldy #S.MEM.REFCNT
				lda (MEM.SPtr),y

				sta IO.CLRREADAUX

*				clc

.9				rts
*--------------------------------------
MEM.GetPtrYA	>STYA A1

				lda MEM.LastSlot

				tax

				jsr MEM.GetA

.1				ldy #S.MEM.PTR
				lda (MEM.SPtr),y
				cmp A1
				bne .2

				iny
				lda (MEM.SPtr),y
				cmp A1+1
				beq .8

.2				lda MEM.SPtr
				sec
				sbc #S.MEM
				sta MEM.SPtr
				bcs .3

				dec MEM.SPtr+1

.3				dex
				bne .1

				lda #E.BADPTR
				sec
				rts

.8				clc
				rts
*--------------------------------------
MEM.GetBestBnk	lda A2osX.MaxBnk
				beq .9					Only 1 ...

				ldx A2osX.ActBnk
				phx
				stx MEM.Best

				ldx /U.LoMem
				stx MEM.Tmp+1

				sta IO.SETREADAUX

.1				sta (pRWReg)

				ldx /U.HiMem
				cpx MEM.Free+1
				bne .2

				sta MEM.Best

				bra .8					free bank

.2				cpx MEM.Tmp+1
				bcs .7

				sta MEM.Best

.7				dec
				cmp #$ff
				bne .1

.8				sta IO.CLRREADAUX

				pla
				sta (pRWReg)

				lda MEM.Best

.9				rts
*--------------------------------------
* Copy A4 bytes from A1 to A2
*--------------------------------------
MEM.CpyX2X		sta IO.SETWRITEAUX
MEM.CpyX2M		sta IO.SETREADAUX

				jsr MEM.Cpy

				jmp RAMSW.2MAINRTS
*--------------------------------------
* A1 srcPtr
* A2 dstPtr
* A4 cnt
*--------------------------------------
MEM.Cpy			lda A1+1
				pha
				lda A2+1
				pha

				lda A4
				eor #$ff
				tax

				lda A4+1
				eor #$ff
				pha

				ldy #0

.1				inx
				bne .2

				pla
				inc
				beq .8

				pha

.2				lda (A1),y
				sta (A2),y
				iny
				bne .1

				inc A1+1
				inc A2+1
				bra .1

.8				pla
				sta A2+1
				pla
				sta A1+1
				
				rts
*--------------------------------------
* Inputs
*  Y,A = Src Ptr
*  A3 srcBnk
*  A3+1 dstBnk
*--------------------------------------
* Uses
*  A1 srcPtr
*  A2 dstPtr
*  A4 cnt
*--------------------------------------
MEM.MBDupYA		sta IO.SETREADAUX
				sta IO.SETWRITEAUX

				pha
				lda A3
				sta (pRWReg)
				pla

				jsr MEM.GetPtrYA		set A1
				bcs .9

				ldy #S.MEM.LEN+1
				lda (MEM.SPtr),y
				pha
				dey
				lda (MEM.SPtr),y
				tay

				lda (MEM.SPtr)
				and #$7F
				tax

				lda A3+1
				sta (pRWReg)

				pla

				>STYA A4

				jsr MEM.Malloc.YAX
				bcs .9

				>STYA A2
				pha

				jsr MEM.MBCpy

.8				pla
				ldy A2

*				clc

.9				jmp RAMSW.2MAINRTS
*--------------------------------------
MEM.MBCpy		lda A2osX.ActBnk
				pha

				lda A4
				eor #$ff
				tax

				lda A4+1
				eor #$ff
				pha

				ldy #0

.1				inx
				bne .2

				pla
				inc
				beq .8

				pha

.2				lda A3
				sta (pRWReg)

				lda (A1),y

				pha

				lda A3+1
				sta (pRWReg)

				pla

				sta (A2),y
				iny
				bne .1

				inc A1+1
				inc A2+1
				bra .1

.8				pla
				sta (pRWReg)

				rts
*--------------------------------------
MAN
SAVE usr/src/sys/kernel.s.mem
LOAD usr/src/sys/kernel.s
ASM
