NEW
  AUTO 3,1
*--------------------------------------
M16.ADD			lda #$72				ADC (zp)
				.HS 2C					BIT ABS
M16.SUB			lda #$F2				SBC (zp)

				sta .3

				asl						CS if SBC, CC if ADC

				ldy #2
				ldx #2

.2				lda (pStack),y
.3				adc (pStack)			SELF MODIFIED
				sta (pStack),y
				
				inc pStack
				dex
				bne .2

				rts
*--------------------------------------
* Returns:
*  ff X < Y
*   0 X = Y
*   1 X > Y
*--------------------------------------
*M16.UCMP
*M16.ICMP
M16.CMP			jsr M16.SUB
				
				tay						A = HI byte
				bmi .2

.1				ora (pStack)			LO byte
				beq .8

				lda #1
				.HS 2C					BIT ABS

.2				lda #$ff

.8				inc pStack
				inc pStack

				rts			
*--------------------------------------
M16.UMUL		clc
				.HS B0					BCS
M16.IMUL		sec

				php
				jsr M16.MULDIVMOD
				jsr M16.MUL

				plp
				bcc M16.PutTMP32

M16.ITMP		lda ACC32.Sign
				eor ARG32.Sign
				bpl M16.PutTMP32
*--------------------------------------
* M16.PutnTMP32
*--------------------------------------
				lda #TMP32
				.HS 2C					BIT ABS
*--------------------------------------
M16.PutnARG32
				lda #ARG32
				sta .1+1
				ldy #0
				ldx #3
				sec

.1				lda $ff,y				SELF MODIFIED
				eor #$ff				two's complement of X bytes
				adc #0
				sta (pStack),y
				iny
				dex
				bpl .1

				rts
*--------------------------------------
M16.UDIV		clc
				.HS B0					BCS
M16.IDIV		sec
				clv
				bra M16.MOD
				
M16.UMOD		clc
				.HS B0					BCS
M16.IMOD		sec
				bit M16.RTS			$60

M16.MOD			php
				jsr M16.MULDIVMOD
				jsr M16.DIVMOD

				plp
				bcc .3					unsigned

				bvs M16.ITMP			return ITMP

				lda ACC32.Sign			IDIV
				eor ARG32.Sign
				bpl M16.PutARG32
				bra M16.PutnARG32

.3				bvc M16.PutARG32		DIV
*--------------------------------------
M16.PutTMP32	ldy #TMP32				MOD
				.HS 2C					BIT ABS
*--------------------------------------
M16.PutARG32	ldy #ARG32

				lda $0,y
				sta (pStack)
				
				lda $1,y
				ldy #1
				sta (pStack),y

M16.RTS			rts
*--------------------------------------
M16.MULDIVMOD	>PULLW ACC32
				sta ACC32.Sign
				
				lda (pStack)
				sta ARG32
				
				ldy #1
				lda (pStack),y
				sta ARG32+1
				
				sta ARG32.Sign
				
				bcc M16.RTS
				jsr .1
*--------------------------------------
* M16.ARG32ABS
*--------------------------------------
				lda ARG32.Sign
				bmi .2
				rts
*--------------------------------------
* M16.ACC32ABS
*--------------------------------------
.1				lda ACC32.Sign
				bpl M16.RTS
*--------------------------------------
* M16.nACC32
*--------------------------------------
				ldy #ACC32
				.HS 2C					BIT ABS
*--------------------------------------
* M16.nARG32
*--------------------------------------
.2				ldy #ARG32

				sec

				lda $0,y
				eor #$ff
				adc #0
				sta $0,y

				lda $1,y
				eor #$ff
				adc #0
				sta $1,y

				rts
*--------------------------------------
M16.MUL			stz TMP32
				stz TMP32+1
				
				ldx #16
.1				lsr ARG32+1
				ror ARG32
				bcc .3

				clc

.2				lda TMP32
				adc ACC32
				sta TMP32

				lda TMP32+1
				adc ACC32+1
				sta TMP32+1

.3				asl ACC32
				rol ACC32+1

				dex
				bne  .1

				clc
				rts
*--------------------------------------
M16.DIVMOD		stz TMP32
				stz TMP32+1
				
				ldx #16
				
.1				asl ARG32
				rol ARG32+1

				rol TMP32
				rol TMP32+1

				sec 
				lda TMP32
				sbc ACC32
				tay
				lda TMP32+1
				sbc ACC32+1
				bcc .2

				sty TMP32
				sta TMP32+1
				inc ARG32				bit0 always 0 because of .1 asl
				
.2				dex
				bne .1

				rts
*--------------------------------------
MAN
SAVE usr/src/sys/kernel.s.math16
LOAD usr/src/sys/kernel.s
ASM
