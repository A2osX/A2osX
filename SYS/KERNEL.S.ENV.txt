NEW
  AUTO 3,1
*/--------------------------------------
* # ExpandStr
* **In:**
*  Y,A = PTR to String to Expand (C-String)
* ## RETURN VALUE
*  X = hMem to Expanded String (C-String)
*  Y,A = PTR to Expanded String 
*\--------------------------------------
				.DUMMY
				.OR ZPDRV
ENV.SearchPath	.BS 2
ENV.BufLen		.BS 1
ENV.VarEndChar	.BS 1
ENV.bNoExp		.BS 1
ENV.hMem		.BS 1
ENV.bExp		.BS 1
				.ED
*--------------------------------------
K.ExpandStr		jsr K.strdup
				bcc .1

				rts
				
.1				stx ENV.hMem			Intermediate string...
				>STYA TXTPTR

				stz	ENV.BufLen			init Expanded String len=0
				stz ENV.bExp			No var found yet
				stz ENV.bNoExp			Reset no expand flag

.10				lda (TXTPTR)			End of CSTR?
				beq .80

				jsr SHARED.TXTPTR.Next
				
.11				cmp #'''
				bne .21

				lda ENV.bNoExp
				eor #$ff
				sta ENV.bNoExp			toggle flag
				bra	.10

.21				bit ENV.bNoExp
				bpl .23

.22				jsr ENV.AddAToBuf
				bra .10

.23				cmp #'$'				no, found one ?
				bne .22					no, store...

				ror ENV.bExp			Toggle Expanded flag
				lda (TXTPTR)
				bne .30

				lda #'$'				End of string, output $
				bra .22
				
.30				stz ENV.VarEndChar
				cmp #'{'				 "${VAR]"?
				bne .31

				dec ENV.VarEndChar		"}" expected

				jsr SHARED.TXTPTR.Next	skip "{"
				bra .40

.31				jsr ZP.IsDigit			$0 ... $9 ?
				bcs .32

				and #$0f

				jsr K.ArgV
				bcs .35					Arg# is undefined, do not append anything

				jsr ENV.AddYAToBuf
				bra .35

.32				ldx #ENV.SysVars.Cnt-1

.33				cmp ENV.SysVars,x
				beq .34
				dex
				bpl .33

				bra .40
.34				jsr ENV.SysVar

.35				jsr SHARED.TXTPTR.Next	skip $x
				bra .10
				
.40				jsr ENV.ExpandStrVar
				bcc .70

.50				jsr ENV.FindVarTXTPTR
				bcs .70

				jsr ENV.NextEnvP3Y		Skip NAME=
				jsr ENV.AddP3ToBuf		Add VALUE

.70				lda (TXTPTR)
				beq .72

				jsr SHARED.IsIDValid
				bcs .72
				jsr SHARED.TXTPTR.Next
				bra .70

.72				lda ENV.VarEndChar			
				beq .10

				bra .35					skip "}" and loop

.80				ldx ENV.BufLen
				stz K.Buf256,x

				lda ENV.hMem
				jsr K.FreeMem

				>LDYAI K.Buf256			dup in case of '' processing
				jsr K.strdup
				bcs .9
				
				bit ENV.bExp			Did we expand something ?
				bpl .9
				
				jmp .1
				
*				clc
.9				rts
*/--------------------------------------
* # FileSearch
* Search a file in the provided PATH list
* And return, if found, the full path to it.
* ## C
* `int filesearch ( char * filename, char * searchpath, char * fullpath, stat * filestat);`
* ## ASM
* **In:**
* `>PUSHWI filestat`
* `>PUSHWI fullpath`
* `>PUSHWI searchpath`
* `>LDYAI filename`
* ## RETURN VALUE
* CC : success
* DstBuf = FilePath
* DstStat = S.STAT
* CS : not found
*\--------------------------------------
K.FileSearch	pha
				>PULLW ENV.SearchPath
				>PULLW .2+1				DstBuf
				>PULLW .4+1				DstStat
				pla						Y,A = filename
				jsr ENV.Search.YA
				bcs K.FileSearch.RTS

				ldx #$ff
.1				inx
				lda K.Buf256,x
.2				sta $ffff,x				Self Modified
				bne .1
				ldx #S.STAT-1
.3				lda K.S.STAT,x
.4				sta $ffff,x				Self Modified
				dex
				bpl .3
*				clc
K.FileSearch.RTS
				rts
*--------------------------------------
ENV.Search.CWD	>STYA ZPPtr2			filename to find
				ldy #S.PS.hCWD
				lda (PS.NewPSPtr),y
				jsr K.GetMemPtr
				>STYA ENV.SearchPath
				bra ENV.Search.Ptr2
				
ENV.Search.LIB	ldx #0
				.HS 2C					BIT ABS
ENV.Search.DRV	ldx #2
				.HS 2C					BIT ABS
ENV.Search.PATH	ldx #4

				>STYA ZPPtr2			filename to find
				>PUSHW ENV.VARS,x

				>LDYA ENV.VARS,x
				>PUSHWI 0				allocate...
				jsr K.GetEnv			get value for Search Path
				bcs K.FileSearch.RTS

				>STYA ENV.SearchPath
				stx ENV.Search.98+1

ENV.Search.Ptr2	>LDYA ZPPtr2
ENV.Search.YA	>STYA .4+1

				stz .1+1
			
.1				ldy #0					Self Modified Index in Search list string

				ldx #0

.2				lda (ENV.SearchPath),y

				beq .3					end of string, try it....

				iny
				cmp #':'
				beq .3

				sta K.Buf256,x
				inx
				bra .2

.3				txa
				beq ENV.Search.98		String is empty....nothing to try

				sty .1+1				save current index

				ldy #0

.4				lda $ffff,y				Self Modified, Append Filename...
				sta K.Buf256,x
				beq .5

				iny
				inx
				bra .4

.5				>PUSHWI K.S.STAT
				>LDYAI K.Buf256
				>SYSCALL2 stat
				bcs .1						Failed...retry next path...

				lda K.S.STAT+S.STAT.P.TYPE
				cmp #S.FI.T.DIR				Dir ?
				beq .1
				jsr ENV.Search.98			Discard Expanded hSrch list

				clc
				rts

ENV.Search.98	lda #$ff					SELF MODIFIED : Discard  Search list
				jsr K.FreeMem

				lda #MLI.E.FNOTFND
				sec
				rts
*/--------------------------------------
* # PutEnv
* Change or add an environment variable, string is 'NAME=VALUE'
* ## C
* `int putenv(char *string);`
* ## ASM
* **In:**
* `>LDYA string`
* `>SYSCALL putenv`
* ## RETURN VALUE
*\--------------------------------------
K.PutEnv		>STYA FORPNT		NAME=VALUE

				ldy #0

.1				lda (FORPNT)		copy NAME to K.Buf256
				beq .9

				cmp #'='
				beq .2

				sta K.Buf256,y
				iny
				
				inc FORPNT
				bne .1
				inc FORPNT+1
				bra .1

.9				lda #E.SYN
				sec
				rts

.2				lda #0
				sta K.Buf256,y
				
				inc FORPNT
				bne .3
				inc FORPNT+1

.3				>LDYAI K.Buf256
				>STYA TXTPTR
				bra K.SetEnv.I
*/--------------------------------------
* # SetEnv
* Change or add an environment variable
* ## C
* `int setenv(const char *name, const char *value);`
* ## ASM
* **In:**
* `>PUSHW value`
* `>LDYA name`
* `>SYSCALL setenv`
* ## RETURN VALUE
*\--------------------------------------
K.SetEnv		>STYA TXTPTR			name
				>PULLW FORPNT			value
				
K.SetEnv.I		jsr K.UnsetEnv.I

.1				jsr ENV.InitEnvP3		ZPPtr3 -> Env

				lda #1
				sta ZPPtr4
				stz ZPPtr4+1			ZPPtr4 = ENVSIZE = 1

.10				lda (ZPPtr3)			End of ENV
				beq .15
				jsr ENV.GetP3LenY
				jsr ENV.NextEnvP3Y
				jsr ENV.NextEnvP4Y
				bra .10

.15				ldy #$ff

.16				iny
				lda (TXTPTR),y
				bne .16

				jsr ENV.NextEnvP4Y		ZPPtr4 = ENVSIZE + VAR

				ldy #$ff

.19				iny
				lda (FORPNT),y
				bne .19

				jsr ENV.NextEnvP4Y		ZPPtr4 = ENVSIZE + VALUE
				lda ZPPtr4
				beq .20

				inc ZPPtr4+1

.20				ldy #S.PS.ENVPAGECNT
				lda (pPs),y
				cmp ZPPtr4+1
				bcs .22				env is large enough

				lda ZPPtr4+1
				jsr ENV.Dup.A
				bcs .9

				pha
				ldy #S.PS.hENV
				lda (pPs),y
				jsr K.Freemem
				pla
				ldy #S.PS.hENV
				sta (pPs),y
				txa
				dey					S.PS.ENVPAGECNT
				sta (pPs),y
				bra .1				Start over

.22				ldy #$ff

.23				iny
				lda (TXTPTR),y
				sta (ZPPtr3),y
				bne .23

				lda #'='
				sta (ZPPtr3),y
				
				jsr ENV.NextEnvP3Y
				ldy #$ff

.24				iny
				lda (FORPNT),y
				sta (ZPPtr3),y
				bne .24

				iny
				sta (ZPPtr3),y			don't forget array ending 0
				clc
.9				rts
*/--------------------------------------
* # GetEnv
* searches the environment list to find the environment variable name, 
* and returns a pointer to the corresponding value string.
* ## C
* `char *getenv(const char *name, char *value);`
* ## ASM
* **In:**
* `>PUSHW name`
* `>PUSHW value`
* `>SYSCALL getenv`
* ## RETURN VALUE
*  CC : Y,A = PTR to VALUE (C-String)
*  CS : not found
*\--------------------------------------
K.GetEnv		>PULLW FORPNT			value
				>PULLW TXTPTR			name

				jsr ENV.FindVarTXTPTR
				bcs .9

				jsr ENV.NextEnvP3Y		Skip NAME=

				lda FORPNT+1
				bne .3

				ldy #$ff
				
.1				iny
				lda (ZPPtr3),y
				bne .1

				iny
				bne .2
				inc
				
.2				jsr K.getmem
				bcs .99
				
				>STYA FORPNT
				
.3				ldy #$ff

.4				iny
				lda (ZPPtr3),y
				sta (FORPNT),y
				bne .4
				
				>LDYA FORPNT

				clc
				rts
				
.9				>LDYAI 0
*				sec
.99				rts
*/--------------------------------------
* # UnsetEnv
* Remove an environment variable
* ## C
* `int unsetenv(const char *name);`
* ## ASM
* **In:**
* `>LDYA name`
* `>SYSCALL unsetenv`
* ## RETURN VALUE
*\--------------------------------------
K.UnsetEnv		>STYA TXTPTR			name
K.UnsetEnv.I	jsr ENV.FindVarTXTPTR
				bcs K.UnsetEnv.I.8		not found, quit

				jsr ENV.DelVarP3		Ptr3 -> NAME=VALUE
K.UnsetEnv.I.8	clc
K.UnsetEnv.I.9	rts
*--------------------------------------
*               PRIVATE
*--------------------------------------
ENV.SysVarsAllArgs
				lda #1
				jsr K.ArgV
				bcs ENV.SysVarsNum.8
				>STYA ZPPtr3

.1				lda (ZPPtr3)
				beq ENV.SysVarsNum.8

.2				jsr ENV.AddP3ToBuf
				jsr ENV.NextEnvP3
				lda (ZPPtr3)
				beq ENV.SysVarsNum.8
				lda #' '
				jsr ENV.AddAToBuf
				bra .2
*--------------------------------------
ENV.SysVar		txa
				beq ENV.SysVarsAllArgs

				ldy ENV.SysVars.PS-1,x
				lda (pPS),y
*--------------------------------------
ENV.SysVarsNum	jsr MATH.A2STR10NP
				ldy #0
.1				lda A2osX.NumStrBuf,y
				beq ENV.SysVarsNum.8
				iny
				jsr ENV.AddAToBuf
				bra .1
ENV.SysVarsNum.8
				clc
				rts
*--------------------------------------
ENV.SysVars		.AS "*#?@$!"
ENV.SysVars.Cnt	.EQ *-ENV.SysVars
ENV.SysVars.PS	.DA #S.PS.ARGC,#S.PS.RC,#S.PS.PPID,#S.PS.PID,#S.PS.CPID
*--------------------------------------
ENV.ExpandStrVar
				>LDYAI ENV.StrVars
				>STYA ZPPtr3
				ldx #0

.1				lda (ZPPtr3)
				beq .9

				ldy #$ff
.2				iny
				lda (TXTPTR),y
				beq .3

				jsr SHARED.IsIDValid
				bcs .3

				cmp (ZPPtr3),y
				beq .2

				bra .4

.3				lda (ZPPtr3),y
				bne .4

				jmp (ENV.StrVarsJmp,x)

.4				inx
				inx
				jsr ENV.NextEnvP3
				bra .1

.9				sec
				rts
*--------------------------------------
ENV.StrVars		.AZ "LOGNAME"
				.AZ "GECOS"
				.AZ "HOME"
				.AZ "SHELL"
				.AZ "PWD"
				.AZ "UID"
				.AZ "GID"
				.DA #0
*--------------------------------------
ENV.StrVarsJmp	.DA ENV.StrVarsSession
				.DA ENV.StrVarsSession
				.DA ENV.StrVarsSession
				.DA ENV.StrVarsSession
				.DA ENV.StrVarsPWD
				.DA ENV.StrVarsUID
				.DA ENV.StrVarsGID
*--------------------------------------
ENV.StrVarsPWD	ldy #S.PS.hCWD
				lda (pPS),y
				jsr K.GetMemPtr
				jmp ENV.AddYAToBuf
*--------------------------------------
ENV.StrVarsUID	ldy #S.SESSION.UID
				.HS 2C
ENV.StrVarsGID	ldy #S.SESSION.GID
				lda (pSession),y
				jmp ENV.SysVarsNum
ENV.StrVarsSession
				lda pSession
				clc
				adc #S.SESSION.NAME
				sta ZPPtr3
				lda pSession+1
				adc /S.SESSION.NAME
				sta ZPPtr3+1

.1				dex
				dex
				bmi .3
				ldy #$ff
.2				iny
				lda (ZPPtr3),y
				bne .2
				jsr ENV.NextEnvP3Y
				bra .1
.3				jmp ENV.AddP3ToBuf
*--------------------------------------
* ENV.FindVarTXTPTR
*  In:
*	 TXTPTR -> NAME
*  Out:
*   CC: Found
*    Y = NAME len
*	 TXTPTR -> NAME
*	 ZPPtr3 -> NAME=VALUE
*	CS: Not Found
*	 TXTPTR -> NAME
*	 ZPPtr3 -> PTR to Ending 0
*--------------------------------------
ENV.FindVarTXTPTR
				jsr ENV.InitEnvP3		Store ENV

.1				lda (ZPPtr3)
				beq .9					end of ENV

				ldy #$ff

.2				iny
				lda (TXTPTR),y
				beq .3

				jsr SHARED.IsIDValid
				bcs .3

				cmp	(ZPPtr3),y
				beq .2

				bra .4

.3				lda (ZPPtr3),y
				cmp #'='
				bne .4

				clc
				rts

.4				jsr ENV.NextEnvP3		Skip NAME=VALUE
				bra .1

.9				sec
				rts	
*--------------------------------------
* ENV.DelVarP3
*  In:
*	ZPPtr3 -> ENV.NAME to Discard
*--------------------------------------
ENV.DelVarP3	>LDYA ZPPtr3			save actual Ptr
				>STYA ZPPtr4
				jsr ENV.NextEnvP3		Skip NAME=VALUE

.1				ldy #$ff

.2				iny
				lda (ZPPtr3),y			Move back CSTRs...
				sta (ZPPtr4),y
				bne .2
				tya
				beq ENV.InitEnvP3.RTS	we moved back ending \0
				jsr ENV.NextEnvP3Y
				jsr ENV.NextEnvP4Y
				bra .1
*--------------------------------------
ENV.InitEnvP3	ldy #S.PS.hENV
				lda (pPs),y
				.DO AUXENV=1
				ldx #SYS.GetStkObjPtr
				jsr K.SYSCALL2
				.ELSE
				jsr K.GetMemPtr
				.FIN
				>STYA ZPPtr3			Store ENV
ENV.InitEnvP3.RTS
				rts
*--------------------------------------
ENV.NextEnvP3	jsr ENV.GetP3LenY
*--------------------------------------
ENV.NextEnvP3Y	tya
ENV.NextEnvP3A	sec
				adc ZPPtr3
				sta ZPPtr3
				bcc .8
				inc ZPPtr3+1
.8				rts
*--------------------------------------
ENV.GetP3LenY	ldy #$ff
.1				iny
				lda (ZPPtr3),y
				bne .1
				rts
*--------------------------------------			
ENV.NextEnvP4Y	tya
				sec
				adc ZPPtr4
				sta ZPPtr4
				bcc .8
				inc ZPPtr4+1
.8				rts
*--------------------------------------
ENV.AddYAToBuf	>STYA ZPPtr3			
*--------------------------------------
ENV.AddP3ToBuf	ldx ENV.BufLen
				ldy #$ff
				dex
.1				iny
				inx
				lda (ZPPtr3),y
				sta K.Buf256,x
				bne .1
				stx ENV.BufLen
				rts
*--------------------------------------
ENV.AddAToBuf	ldx ENV.BufLen
				sta K.Buf256,x
				inc ENV.BufLen
				rts
*--------------------------------------
* ENV.Dup
*  In:
*   A = ENV hMem To Duplicate
*  Out:
*   A = hMem to new ENV
*   X = Page Count
*--------------------------------------
ENV.Dup			ldy #S.PS.ENVPAGECNT
				lda (pPs),y

ENV.Dup.A		sta .8+1				Store target page Count	
				ldy #0
				jsr K.GetMem
				bcs .9

				>STYA .2+1				Target Buffer
				phx						save hMem
				jsr Mem.SetOwner		Set Ownership

				ldy #S.PS.ENVPAGECNT	get SOURCE page count
				lda (pPs),y
				tax

				iny						#S.PS.hENV
				lda (pPs),y

				.DO AUXENV=1
				sta SETREADAUX
				sta SETWRITEAUX
				.FIN

				jsr K.GetMemPtr
				>STYA .1+1

				ldy #0

.1				lda $ffff,y				SELF MODIFIED
.2				sta $ffff,y				SELF MODIFIED
				iny
				bne .1

				inc .1+2
				inc .2+2
				dex
				bne .1

.8				.DO AUXENV=1
				sta CLRREADAUX
				sta CLRWRITEAUX
				.FIN
				ldx #$ff				SELF MODIFIED Target Page Count
				pla						hMem
				clc
.9				rts
*--------------------------------------
ENV.VARS		.DA .1
				.DA .2
				.DA .3
.1				.AZ "LIB"
.2				.AZ "DRV"
.3				.AZ "PATH"
*--------------------------------------
MAN
SAVE USR/SRC/SYS/KERNEL.S.ENV
LOAD USR/SRC/SYS/KERNEL.S
ASM
