PR#3
PREFIX /A2OSX.SRC
NEW
INC 1
AUTO 6
				.LIST OFF
*--------------------------------------
* S.ExpandPStrA
*  In:
*   A = hMem of String to Expand (PSTRING)
*  Out:
*   A = hMem to Expanded String (PSTRING)
*--------------------------------------
S.ExpandPStrA	jsr S.GetMemPtrA
S.ExpandPStrYA	>STYA ZPQuickPtr3

				stz	TmpBuffer256		init Expanded String len=0		
				
				ldy #0
				
.10				stz S.ExpandPStrA.Start
				
.1				tya
				cmp (ZPQuickPtr3)		End of PSTR?
				beq .6
				
				iny
				lda (ZPQuickPtr3),y
				
				ldx S.ExpandPStrA.Start	
				bne .3					already in a var?
				
				cmp #'$'				no, found one ?
				beq .2
				
				inc TmpBuffer256		no, copy char
				ldx TmpBuffer256
				sta TmpBuffer256,x				
				bra .1
				
.2				sty S.ExpandPStrA.Start	save var start
				stz S.ExpandPStrA.End
				bra .1					skip this char

.3				cmp #'{'				in var, "{" after "$"?
				beq .2

				cmp #'}'				end of var?
				beq .5

.4				jsr S.ExpandPStrA.VC	valid char ?
				bcs .5					no, end here
				sty S.ExpandPStrA.End	yes, save end
				bra .1
				
.5				lda S.ExpandPStrA.End	get end
				beq .1					empty {} or $/
				
				phy						save current index
				jsr S.ExpandPStrA.AV
				ply						restore index in string...
				bra .10					reset start flag and continue
				
.6				sty S.ExpandPStrA.End	end of PSTR
				lda S.ExpandPStrA.Start	are we in a var?
				beq .7					no...exit...
				
				jsr S.ExpandPStrA.AV	yes, expand and add to STR
				
.7				>LDYAI TmpBuffer256
				jsr S.NewPStrYA
				rts					
*--------------------------------------
S.ExpandPStrA.AV
				ldy #S.PS.hENV
				lda (pPs),y
				jsr S.GetMemPtrA
				>STYA ZPQuickPtr1		Store ENV for FindVar
				
				lda S.ExpandPStrA.End	
				sec
				sbc S.ExpandPStrA.Start	compute len of VAR End-Start+1
				
				ldx TmpBuffer256
				inx
				sta TmpBuffer256,x
				
				stx ZPQuickPtr2
				lda /TmpBuffer256
				sta ZPQuickPtr2+1
				
				ldy S.ExpandPStrA.Start
		
.1				iny
				inx
				lda (ZPQuickPtr3),y
				sta TmpBuffer256,x
				cpy S.ExpandPStrA.End
				bne .1
				
				jsr S.FindVar
				bcs .9

				ldy #0
.2				iny
				lda (ZPQuickPtr1),y
				cmp #'='
				bne .2
				
.3				iny
				lda (ZPQuickPtr1),y
				inc TmpBuffer256
				ldx TmpBuffer256
				sta TmpBuffer256,x
					
				tya
				cmp (ZPQuickPtr1)				last char?
				bne .3
.9				rts
*--------------------------------------
S.ExpandPStrA.VC
				cmp #'0'
				bcc .9
				cmp #'9'+1
				bcc .8
				
				cmp #'A'
				bcc .9
				cmp #'Z'+1
				bcc .8
				
				cmp #'_'
				bne .9
				
.8				clc
				rts
.9				sec
				rts
*--------------------------------------
S.ExpandPStrA.Start	.BS 1
S.ExpandPStrA.End	.BS 1
*--------------------------------------
* S.CreateEnv
*  in :
*  out :
*   A = hMem to new env
*--------------------------------------
S.CreateEnv		>PUSHWI K.ENV.SIZE		get a buffer for ENV
				>PUSHBI 0
				jsr S.GetMem			create it...
				bcs .9
				>STYA ZPQuickPtr1
				lda #0
				sta (ZPQuickPtr1)
				txa
				clc
.9				rts
*--------------------------------------
* S.DupEnvA
*  In:
*   A = ENV hMem To Duplicate
*  Out:
*   A = hMem to new ENV
*--------------------------------------
S.DupEnvA		pha
				jsr S.GetMemPtrA
				>STYA ZPQuickPtr1
				pla
				>PUSHWI K.ENV.SIZE
				>PUSHBI 0
				jsr S.GetMem
				bcs .9
				>STYA ZPQuickPtr2
				phx
.1				lda (ZPQuickPtr1)
				sta (ZPQuickPtr2)
				beq .8
				inc ZPQuickPtr1
				bne .2
				inc ZPQuickPtr1+1
.2				inc ZPQuickPtr2
				bne .1
				inc ZPQuickPtr2+1
				bra .1
.8				pla
				clc
.9				rts
*--------------------------------------
* S.GetEnvVarA
*  In:
*  A = hMem to NAME (PSTRING)
*--------------------------------------
* S.GetEnvVarYA
*  In:
*  Y,A = PTR to NAME (PSTRING)
*  Out:
*   A = hMem to VALUE (PSTRING)  0,"" if not exist
*--------------------------------------
S.GetEnvVarA	>PULLA
				jsr S.GetMemPtrA
S.GetEnvVarYA	>STYA ZPQuickPtr2
				jsr S.FindVar
				bcc .1
				>LDYAI 1				not found
				>PUSHYA					create "" PSTR
				>PUSHBI 0
				jsr S.GetMem			create a new PSTR
				bcs .99
				>STYA ZPQuickPtr3
				lda #0
				sta (ZPQuickPtr3)		set len of PSTR
				txa
				clc
				rts
.1				lda (ZPQuickPtr1)		get NAME=VALUE len
				sec
				sbc (ZPQuickPtr2)		substract (NAME len)
				tay						y=len("=VALUE")
				lda #0
				>PUSHYA
				>PUSHBI 0
				jsr S.GetMem			create a new PSTR
				bcs .99
				>STYA ZPQuickPtr3
				phx						save hMem
				lda (ZPQuickPtr1)		get NAME=VALUE len
				clc
				sbc (ZPQuickPtr2)		compute VALUE len
				sta (ZPQuickPtr3)		set new PSTR Len
				tax						x = chr to copy
				lda (ZPQuickPtr2)		get name len
				inc						add 1 to skip "="
				tay
.2				iny
				inc ZPQuickPtr3
				bne .3
				inc ZPQuickPtr3+1
.3				lda (ZPQuickPtr1),y
				sta (ZPQuickPtr3)
				dex
				bne .2
				pla						get back PSTR hMem
				clc
.99				rts
*--------------------------------------
* S.SetEnvVarH
*  In:
*  PULLB = hMem To Name (PSTRING)
*  PULLB = hMem To Value (PSTRING)
*--------------------------------------
* S.SetEnvVarP
*  In:
*  PULLW = PTR To Name (PSTRING)
*  PULLW = PTR To Value (PSTRING)
*  Out:
*--------------------------------------
S.SetEnvVarH	>PULLA 
				jsr S.GetMemPtrA
				>STYA ZPQuickPtr2
				>PULLA
				jsr S.GetMemPtrA
				bra S.SetEnvVar
S.SetEnvVarP	>PULLW ZPQuickPtr2
				>PULLYA
S.SetEnvVar		>STYA ZPQuickPtr3		ZPQuickPtr3 = VALUE
				jsr S.FindVar
				bcs .3					Not Found,ZPQuickPtr1 -> End Of Env
				lda (ZPQuickPtr1)		Found, Discard current NAME definition
				sec
				adc ZPQuickPtr1			add	NAME=VALUE len+1 to ZPQuickPtr1
				sta ZPQuickPtr4
				lda #0
				adc ZPQuickPtr1+1		store it in ZPQuickPtr4
				sta ZPQuickPtr4+1
.1				lda (ZPQuickPtr4)
				sta (ZPQuickPtr1)
				beq .3					until we move ending 0
				inc ZPQuickPtr1
				bne .2
				inc ZPQuickPtr1+1
.2				inc ZPQuickPtr4
				bne .1
				inc ZPQuickPtr4+1
				bra .1
.3				lda ZPQuickPtr1			Compute ENV UPPER LIMIT
				clc
				adc #K.ENV.SIZE
				sta ZPQuickPtr4
				lda ZPQuickPtr1+1
				adc /K.ENV.SIZE
				sta ZPQuickPtr4+1
				ldy ZPQuickPtr1+1
				lda ZPQuickPtr1			Compute New Env Upper limit in A,Y
				sec
				adc (ZPQuickPtr2)		add NAME len +1(for len)
				bcc .4
				iny
.4				sec						
				adc (ZPQuickPtr3)		add VALUE len +1(for "=")
				bcc .5
				iny
.5				sec						A,Y=new upper limit
				sbc ZPQuickPtr4			greater than hMem Upper limit ?
				bcc .51
				tya
				sbc ZPQuickPtr4+1
				bcs .99					
.51				lda (ZPQuickPtr2)		make len = NAME+VALUE+1
				sec
				adc (ZPQuickPtr3)
				sta (ZPQuickPtr1)
				inc ZPQuickPtr1
				bne .6
				inc ZPQuickPtr1+1
.6				ldy #0
.7				iny
				lda (ZPQuickPtr2),y
				sta (ZPQuickPtr1)
				inc ZPQuickPtr1
				bne .8
				inc ZPQuickPtr1+1
.8				tya	
				cmp (ZPQuickPtr2)
				bne .7
				lda #'='
				sta (ZPQuickPtr1)
				inc ZPQuickPtr1
				bne .9
				inc ZPQuickPtr1+1
.9				ldy #0
.10				iny				
				lda (ZPQuickPtr3),y
				sta (ZPQuickPtr1)
				inc ZPQuickPtr1
				bne .11
				inc ZPQuickPtr1+1
.11				tya	
				cmp (ZPQuickPtr3)
				bne .10
				lda #0
				sta (ZPQuickPtr1)
				clc
				rts
.99				lda #SYSMGR.ERRENVF
				sec
				rts
*--------------------------------------
* S.DelEnvVarA
*  In:
*  PULLB = hMem To Name (PSTRING)
*--------------------------------------
* S.DelEnvVarYA
*  In:
*  PULLW = PTR To Name (PSTRING)
*  Out:
*--------------------------------------
S.DelEnvVarA	>PULLA					get NAME
				jsr S.GetMemPtrA
S.DelEnvVarYA	>STYA ZPQuickPtr2		Store VAR Name
S.DelEnvVar		jsr S.FindVar
				bcs .8					not found, quit

				lda (ZPQuickPtr1)		Found, Discard current NAME definition
				sec
				adc ZPQuickPtr1			add	NAME=VALUE len+1 to ZPQuickPtr1
				sta ZPQuickPtr4
				lda #0
				adc ZPQuickPtr1+1		store it in ZPQuickPtr4
				sta ZPQuickPtr4+1
				
.1				lda (ZPQuickPtr4)
				sta (ZPQuickPtr1)
				beq .8					until we move ending 0
				inc ZPQuickPtr1
				bne .2
				inc ZPQuickPtr1+1
				
.2				inc ZPQuickPtr4
				bne .1
				inc ZPQuickPtr4+1
				bra .1
				
.8				clc				
				rts
*--------------------------------------
*               PRIVATE
*--------------------------------------
* S.FindVar
*  In:
*	 ZPQuickPtr2 -> NAME
*--------------------------------------
*  Out:
*   CC: Found
*	 ZPQuickPtr1 -> NAME=VALUE
*	 ZPQuickPtr2 -> NAME
*	CS: Not Found
*	 ZPQuickPtr1 -> PTR to Ending 0
*	 ZPQuickPtr2 -> NAME
*--------------------------------------
S.FindVar		ldy #S.PS.hENV
				lda (pPs),y
				jsr S.GetMemPtrA
				>STYA ZPQuickPtr1		Store ENV
				
.1				lda (ZPQuickPtr1)
				beq .9
				ldy #0
.2				iny
				lda (ZPQuickPtr1),y
				cmp #'='				End Of VAR Name ?
				beq .4
.3				cmp	(ZPQuickPtr2),y
				bne .7
				tya
				cmp (ZPQuickPtr2)
				bne .2
				iny
				lda (ZPQuickPtr1),y
				cmp #'='				End Of VAR Name ?
				bne .3	
.4				dey
				tya
				cmp (ZPQuickPtr2)		Y = VAR Name Len ?
				beq .8					yes, found VAR
.7				lda (ZPQuickPtr1)		no, go to next NAME=VALUE
				sec
				adc ZPQuickPtr1
				sta ZPQuickPtr1
				bcc .1
				inc ZPQuickPtr1+1
				bra .1
.8				clc
				rts
.9				sec
				rts		
*--------------------------------------
MAN
SAVE SYS/KERNEL.S.ENV
LOAD SYS/KERNEL.S
ASM
