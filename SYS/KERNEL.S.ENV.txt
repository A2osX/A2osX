PR#3
PREFIX /A2OSX.SRC
NEW
INC 1
AUTO 6
				.LIST OFF
*/--------------------------------------
* #ExpandPStrYA
* ##In:
*  Y,A = PTR to String to Expand (PSTR)
* ##Out:
*  X = hMem to Expanded String (PSTR)
*  Y,A = PTR to Expanded String 
*\--------------------------------------
K.ExpandPStrYA	stz K.ExpandPStr.hPStr	Reset Intermediate string...
				
.11				>STYA ZPQuickPtr3

				stz	KrnBuf256			init Expanded String len=0		
				stz K.ExpandPStr.bFound	No var found yet
				stz K.ExpandPStr.bNoExp	Reset no expand flag
				ldy #0
				
.10				stz K.ExpandPStr.Start
				
.1				tya
				cmp (ZPQuickPtr3)		End of PSTR?
				beq .6
				
				iny
				lda (ZPQuickPtr3),y

				cmp #'''
				bne .21
				
				lda K.ExpandPStr.bNoExp
				eor #$ff
				sta K.ExpandPStr.bNoExp toggle flag
				bra	 .1
				
.21				bit K.ExpandPStr.bNoExp
				bmi .22

				ldx K.ExpandPStr.Start	
				bne .3					already in a var?
				
				cmp #'$'				no, found one ?
				beq .2
				
.22				inc KrnBuf256		no, copy char
				ldx KrnBuf256
				sta KrnBuf256,x				
				bra .1
				
.2				sec
				ror K.ExpandPStr.bFound	Toggle flag
				
				sty K.ExpandPStr.Start	save var start
				stz K.ExpandPStr.End
				bra .1					skip this char

.3				cmp #'{'				we are in var, "{" after "$"?
				beq .2

				cmp #'}'				end of var?
				beq .5

				jsr K.ExpandPStr.VC		we are in var, is char valid?
				bcs .5					no, end here
				sty K.ExpandPStr.End	yes, save end
				bra .1
				
.5				lda K.ExpandPStr.End	get end
				beq .1					empty {} or $/
				
				phy						save current index
				jsr K.ExpandPStr.AV
				ply						restore index in string...
				bra .10					reset start flag and continue
				
.6				sty K.ExpandPStr.End	end of PSTR
				lda K.ExpandPStr.Start	are we in a var?
				beq .8					no...exit...
				
				jsr K.ExpandPStr.AV		yes, expand and add to STR
				
.8				lda K.ExpandPStr.hPStr	working from our temp string ?
				beq .81					no...
				
				jsr K.FreeMemA			yes, discard....

.81				>LDYAI KrnBuf256
				jsr K.NewPStrYA
				bcs .9
				stx K.ExpandPStr.hPStr	save this as temp string, in case of recurse
				bit K.ExpandPStr.bFound	Did we expand something ?
				bpl .9
				jmp .11					Yes, start over with hPStr
				
* or exit with Y,A & X from K.NewPStrYA
				
.9				rts					
*--------------------------------------
K.ExpandPStr.AV	lda K.ExpandPStr.End	
				sec
				sbc K.ExpandPStr.Start	compute len of VAR End-Start+1
				
				ldx KrnBuf256
				inx
				sta KrnBuf256,x
				
				stx ZPQuickPtr2
				lda /KrnBuf256
				sta ZPQuickPtr2+1
				
				ldy K.ExpandPStr.Start
		
.1				iny
				inx
				lda (ZPQuickPtr3),y
				sta KrnBuf256,x
				cpy K.ExpandPStr.End
				bne .1
				
				jsr ENV.CheckSysVarPtr2
				bcs .10
				>STYA ZPQuickPtr1
				bra .11
				
.10				jsr ENV.FindVarPtr2
				bcs .9

				jsr ENV.NextEnvPtr1		Skip NAME
				
.11				ldy #0
				ldx KrnBuf256
				
.2				iny
				lda (ZPQuickPtr1),y
				inx
				sta KrnBuf256,x
					
				tya
				cmp (ZPQuickPtr1)		last char?
				bne .2
				stx KrnBuf256
				
.9				rts
*--------------------------------------
K.ExpandPStr.VC	cmp #'0'
				bcc .9
				cmp #'9'+1
				bcc .8
				
				cmp #'A'
				bcc .9
				cmp #'Z'+1
				bcc .8
				
				cmp #'_'
				bne .9
				
.8				clc
				rts
.9				sec
				rts
*--------------------------------------
K.ExpandPStr.Start	.BS 1
K.ExpandPStr.End	.BS 1
K.ExpandPStr.bFound	.BS 1
K.ExpandPStr.bNoExp	.BS 1
K.ExpandPStr.hPStr	.BS 1
*/--------------------------------------
* #PutEnvYA
* ##In:
*  Y,A = PTR to String NAME=VALUE (PSTR)
* ##Out:
*\--------------------------------------
K.PutEnvYA		>STYA ZPQuickPtr2		NAME=VALUE
				lda (ZPQuickPtr2)
				beq .9
				sta KrnBuf256
				tay
				
.1				lda (ZPQuickPtr2),y
				sta KrnBuf256,y
				dey
				bne .1
				
				ldy #0
				
.2				iny
				cpy KrnBuf256		last char ?
				beq .9					no "=" found
				
				lda KrnBuf256,y
				cmp #'='
				bne .2
				
				cpy #1					String like "=value" ?
				beq .9
				
				cpy KrnBuf256		last char ?
				beq .9					we have "VAR="

				lda KrnBuf256		save actual string len
				
				sty KrnBuf256		set length of VAR string
				dec KrnBuf256		...without "="
				
				
.3				clc						Substract VAR len+1 from whole len to get 
				sbc KrnBuf256		VALUE len
				sta KrnBuf256,y		save it at "=" POS

				tya
				clc
				adc #KrnBuf256
				sta ZPQuickPtr3
				lda /KrnBuf256
				sta ZPQuickPtr3+1
				
				>LDYAI KrnBuf256
				>STYA ZPQuickPtr2
				
				bra K.SetEnvPtr2Ptr3
				
.9				sec
				rts
*/--------------------------------------
* #SetEnv
* ##In:
*  PUSHW = PTR To Value (PSTR)
*  PUSHW = PTR To Name (PSTR)
* ##Out:
*\--------------------------------------
K.SetEnv		>PULLW ZPQuickPtr2		NAME...
				>PULLW ZPQuickPtr3		...VALUE
				
K.SetEnvPtr2Ptr3
				jsr S.UnsetEnvPtr2

				jsr ENV.InitEnvPtr1		Y,A = ZPQuickPtr1 -> Env
				
				lda ZPQuickPtr1			Compute ENV UPPER LIMIT in Ptr4
				clc
				adc #K.ENV.SIZE
				sta ZPQuickPtr4
				
				lda ZPQuickPtr1+1
				adc /K.ENV.SIZE
				sta ZPQuickPtr4+1
				
				ldy ZPQuickPtr1+1
				lda ZPQuickPtr1			Compute New Env Upper limit in A,Y
				sec
				adc (ZPQuickPtr2)		add NAME len +1
				bcc .1
				iny
				
.1				sec						
				adc (ZPQuickPtr3)		add VALUE len +1
				bcc .2
				iny
				
.2				cmp ZPQuickPtr4			GE than hMem Upper limit ?
				tya
				sbc ZPQuickPtr4+1
				bcs .99
				
.3				lda (ZPQuickPtr1)		Scan until endig 0...
				beq .4
			
				inc	ZPQuickPtr1
				bne .3
				inc ZPQuickPtr1+1
				bne .3
				
.4				lda (ZPQuickPtr2)
				sta (ZPQuickPtr1)
				tay
				
.5				lda (ZPQuickPtr2),y
				sta (ZPQuickPtr1),y
				dey
				bne .5
				
				jsr ENV.NextEnvPtr1
				
				lda (ZPQuickPtr3)
				sta (ZPQuickPtr1)
				tay
				
.6				lda (ZPQuickPtr3),y
				sta (ZPQuickPtr1),y
				dey
				bne .6
				
				jsr ENV.NextEnvPtr1
				
.8				lda #0
				
				sta (ZPQuickPtr1)
				clc
				rts
				
.99				lda #SYSMGR.ERRENVF
				sec
				rts
*/--------------------------------------
* #GetEnvYA
* ##In:
*  Y,A = PTR to NAME (PSTR)
* ##Out:
*  CC : Y,A = PTR to VALUE (PSTR)
*  CS : not found
*\--------------------------------------
K.GetEnvYA		>STYA ZPQuickPtr2
				jsr ENV.CheckSysVarPtr2
				bcc .8
				
				jsr ENV.FindVarPtr2
				bcs .9
				jsr ENV.NextEnvPtr1		Skip NAME
				>LDYA ZPQuickPtr1
				clc						just in case ADC in NextEnvPtr1 disturb CC
.8				rts
				
.9				>LDYAI EmptyPSTR
				rts
*/--------------------------------------
* #UnsetEnvYA
* ##In:
*  Y,A = PTR To Name (PSTR)
* ##Out:
*\--------------------------------------
K.UnsetEnvYA	>STYA ZPQuickPtr2		Store VAR Name
S.UnsetEnvPtr2	jsr ENV.FindVarPtr2
				bcs .8					not found, quit

				jsr ENV.DiscardVarPtr1	Ptr1 -> ENVNAME
				
.8				clc				
				rts
*--------------------------------------
*               PRIVATE
*--------------------------------------
* ENV.CheckSysVarPtr2
*  In:
*	 ZPQuickPtr2 -> NAME
*  Out:
*   CC: Found
*	 YA -> VALUE
*	CS: Not Found
*--------------------------------------
ENV.CheckSysVarPtr2
				lda (ZPQuickPtr2)
				cmp #1					is name 1 char?
				bne .9
				
				ldy #1
				lda (ZPQuickPtr2),y
				cmp #'0'				$0...$9 ??
				bcc .1					no,
				cmp #'9'+1
				bcs .1
				and #$0F
				jmp K.GetArgA

.1				ldx #ENV.SysVarsJmp-ENV.SysVars-1

.2				cmp ENV.SysVars,x
				beq .3
				dex
				bpl .2
				
.9				sec
				rts
				
.3				txa
				asl
				tax
				jmp (ENV.SysVarsJmp,x)
*--------------------------------------
ENV.SysVars		.AS "*#?$!"
ENV.SysVarsJmp	.DA ENV.SysVarsArgs
				.DA ENV.SysVarsArgC
				.DA ENV.SysVarsRC
				.DA ENV.SysVarsPID
				.DA ENV.SysVarsCPID
*--------------------------------------
ENV.SysVarsArgs	sec
				rts
ENV.SysVarsArgC jsr K.GetArgC
				bra ENV.SysVarsA
ENV.SysVarsRC	ldy #S.PS.RC
				.HS 2C
ENV.SysVarsPID	ldy #S.PS.PID
				.HS 2C
ENV.SysVarsCPID ldy #S.PS.CPID
				lda (pPS),y
ENV.SysVarsA	sta HEXBUF
				stz	HEXBUF+1
				stz HEXBUF+2
				stz HEXBUF+3
				jsr HEX2DEC
				
				ldx #0
				
.1				lda ASCBUF,x
				cmp #'0'
				bne .2
				inx
				cpx #10
				bne .1
				
				sta KrnOut256+1
				ldy #1
				bne .8					always
				
.2				ldy #0

.3				lda ASCBUF,x
				iny
				sta KrnOut256,y
				inx
				cpx #10
				bne .3
				
.8				sty KrnOut256
				>LDYAI KrnOut256
				clc
				rts
*--------------------------------------
* ENV.FindVarPtr2
*  In:
*	 ZPQuickPtr2 -> NAME
*  Out:
*   CC: Found
*	 ZPQuickPtr1 -> ENV.NAME
*	 ZPQuickPtr2 -> NAME
*	CS: Not Found
*	 ZPQuickPtr1 -> PTR to Ending 0
*	 ZPQuickPtr2 -> NAME
*--------------------------------------
ENV.FindVarPtr2	jsr ENV.InitEnvPtr1		Store ENV
				bcs .99
				
				lda (ZPQuickPtr1)
				beq .9					end of ENV
				
.1				cmp (ZPQuickPtr2)		Same len as NAME?
				bne .3
				
				tay

.2				lda (ZPQuickPtr1),y
				cmp	(ZPQuickPtr2),y
				bne .3
				dey
				bne .2
				clc
				rts
				
.3				jsr ENV.NextEnvPtr1		Skip NAME
				jsr ENV.NextEnvPtr1		Skip VALUE
				lda (ZPQuickPtr1)
				bne .1
				
.9				sec
.99				rts		
*--------------------------------------
* ENV.DiscardVarPtr1	
*  In:
*	ZPQuickPtr1 -> ENV.NAME to Discard
*--------------------------------------
ENV.DiscardVarPtr1
				lda ZPQuickPtr1			Discard current NAME & VALUE definition
				sec						ZPQuickPtr1 -> NAME
				adc (ZPQuickPtr1)		add	NAME+1 to ZPQuickPtr1
				sta ZPQuickPtr4			store it in ZPQuickPtr4
				lda #0
				adc ZPQuickPtr1+1
				sta ZPQuickPtr4+1
				
				lda ZPQuickPtr4			add	VALUE+1 to ZPQuickPtr4
				sec 
				adc (ZPQuickPtr4)
				sta ZPQuickPtr4
				bcc .1
				inc ZPQuickPtr4+1
				 
.1				ldy #0

.2				lda (ZPQuickPtr4),y		Move back tail...
				sta (ZPQuickPtr1),y
				beq .8					...until we move ending 0
				iny
				bne .2
				inc ZPQuickPtr1+1
				inc ZPQuickPtr4+1
				bra .2
				
.8				rts
*--------------------------------------
ENV.InitEnvPtr1	ldy #S.PS.hENV
				lda (pPs),y
				jsr K.GetMemPtrA
				>STYA ZPQuickPtr1		Store ENV
				rts
*--------------------------------------
ENV.NextEnvPtr1	lda ZPQuickPtr1
				sec
				adc (ZPQuickPtr1)
				sta ZPQuickPtr1
				bcc .8
				inc ZPQuickPtr1+1
.8				rts		
*--------------------------------------
MAN
SAVE SYS/KERNEL.S.ENV
LOAD SYS/KERNEL.S
ASM
