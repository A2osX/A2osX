NEW
  AUTO 3,1
*/--------------------------------------
* # Expand
* ## C
* `char *expand(const char *str, char *expanded);`
* ## ASM
* **In:**
* `>PUSHW str`
* `>PUSHW expanded`
* `>SYSCALL expand`
* ## RETURN VALUE
*  Y,A = PTR to Expanded String 
*  X = hMem to Expanded String (C-String)
*\--------------------------------------
				.DUMMY
				.OR ZPDRV
ENV.BufLen		.BS 1
ENV.VarEndChar	.BS 1
ENV.bNoExp		.BS 1
ENV.bExp		.BS 1
				.ED
*--------------------------------------
K.Expand		jsr K.strdup
				bcc .1
				
				rts
				
.1				phx						Save temp string...
				>STYA TXTPTR

				stz	ENV.BufLen			init Expanded String len=0
				stz ENV.bExp			No var found yet
				stz ENV.bNoExp			Reset no expand flag

.10				lda (TXTPTR)			End of CSTR?
				beq .80

				jsr SHARED.TXTPTR.Next
				
.11				cmp #'''
				bne .21

				lda ENV.bNoExp
				eor #$ff
				sta ENV.bNoExp			toggle flag
				bra	.10

.21				bit ENV.bNoExp
				bpl .23

.22				jsr ENV.AddAToBuf
				bra .10

.23				cmp #'$'				no, found one ?
				bne .22					no, store...

				ror ENV.bExp			Toggle Expanded flag
				lda (TXTPTR)
				bne .30

				lda #'$'				End of string, output $
				bra .22
				
.30				stz ENV.VarEndChar
				cmp #'{'				 "${VAR]"?
				bne .31

				dec ENV.VarEndChar		"}" expected

				jsr SHARED.TXTPTR.Next	skip "{"
				bra .40

.31				jsr ZP.IsDigit			$0 ... $9 ?
				bcs .32

				and #$0f

				jsr K.ArgV
				bcs .35					Arg# is undefined, do not append anything

				jsr ENV.AddYAToBuf
				bra .35

.32				jsr ENV.SysVar
				bcs .40

.35				jsr SHARED.TXTPTR.Next	skip $x
				bra .10
				
.40				jsr ENV.ExpandStrVar
				bcc .70

.50				jsr ENV.FindVar
				bcs .70

				jsr ENV.NextEnvP3Y		Skip NAME=
				
				.DO AUXENV=1
				sta SETREADAUX
				.FIN
				
				jsr ENV.AddP3ToBuf		Add VALUE
				
				.DO AUXENV=1
				sta CLRREADAUX
				.FIN
				
.70				lda (TXTPTR)
				beq .72

				jsr SHARED.IsIDValid
				bcs .72
				jsr SHARED.TXTPTR.Next
				bra .70

.72				lda ENV.VarEndChar			
				beq .10

				bra .35					skip "}" and loop

.80				ldx ENV.BufLen
				stz K.Buf256,x

				pla						discard temp string
				jsr K.FreeMem

				>LDYAI K.Buf256			dup in case of '' processing
				jsr K.strdup
				bcs .9
				
				bit ENV.bExp			Did we expand something ?
				bpl .9
				jmp .1
				
*				clc
.9				rts
*--------------------------------------
ENV.SysVar		ldx #ENV.SysVars.Cnt-1

.1				cmp ENV.SysVars,x
				beq .2
				dex
				bpl .1
				
				sec
				rts

.2				txa
				beq ENV.SysVarsAllArgs

				ldy ENV.SysVars.PS-1,x
				lda (pPS),y
*--------------------------------------
ENV.SysVarsNum	jsr MATH.A2STR10NP
				ldy #0
.1				lda A2osX.NumStrBuf,y
				beq ENV.SysVarsNum.8
				iny
				jsr ENV.AddAToBuf
				bra .1
ENV.SysVarsNum.8
				clc
				rts
*--------------------------------------
ENV.SysVarsAllArgs
				lda #1
				jsr K.ArgV
				bcs ENV.SysVarsNum.8
				>STYA ZPPtr3

.1				lda (ZPPtr3)
				beq ENV.SysVarsNum.8

.2				jsr ENV.AddP3ToBuf
				jsr ENV.NextEnvP3
				lda (ZPPtr3)
				beq ENV.SysVarsNum.8
				lda #C.SPACE
				jsr ENV.AddAToBuf
				bra .2
*--------------------------------------
ENV.SysVars		.AS "*#?@$!"
ENV.SysVars.Cnt	.EQ *-ENV.SysVars
ENV.SysVars.PS	.DA #S.PS.ARGC,#S.PS.RC,#S.PS.PPID,#S.PS.PID,#S.PS.CPID
*--------------------------------------
ENV.ExpandStrVar
				>LDYAI ENV.StrVars
				>STYA ZPPtr3
				ldx #0

.1				lda (ZPPtr3)
				beq .9

				ldy #$ff
.2				iny
				lda (TXTPTR),y
				beq .3

				jsr SHARED.IsIDValid
				bcs .3

				cmp (ZPPtr3),y
				beq .2

				bra .4

.3				lda (ZPPtr3),y
				bne .4

				jmp (ENV.StrVarsJmp,x)

.4				inx
				inx
				jsr ENV.NextEnvP3
				bra .1

.9				sec
				rts
*--------------------------------------
ENV.StrVars		.AZ "LOGNAME"
				.AZ "GECOS"
				.AZ "HOME"
				.AZ "SHELL"
				.AZ "PWD"
				.AZ "UID"
				.AZ "GID"
				.DA #0
*--------------------------------------
ENV.StrVarsJmp	.DA ENV.StrVarsSession
				.DA ENV.StrVarsSession
				.DA ENV.StrVarsSession
				.DA ENV.StrVarsSession
				.DA ENV.StrVarsPWD
				.DA ENV.StrVarsUID
				.DA ENV.StrVarsGID
*--------------------------------------
ENV.StrVarsPWD	ldy #S.PS.hCWD
				lda (pPS),y
				jsr K.GetMemPtr
				jmp ENV.AddYAToBuf
*--------------------------------------
ENV.StrVarsUID	ldy #S.SESSION.UID
				.HS 2C
ENV.StrVarsGID	ldy #S.SESSION.GID
				lda (pSession),y
				jmp ENV.SysVarsNum
ENV.StrVarsSession
				lda pSession
				clc
				adc #S.SESSION.NAME
				sta ZPPtr3
				lda pSession+1
				adc /S.SESSION.NAME
				sta ZPPtr3+1

.1				dex
				dex
				bmi .3

				ldy #$ff
.2				iny
				lda (ZPPtr3),y
				bne .2

				jsr ENV.NextEnvP3Y
				bra .1

.3				jmp ENV.AddP3ToBuf
*--------------------------------------
ENV.AddYAToBuf	>STYA ZPPtr3			
*--------------------------------------
ENV.AddP3ToBuf	ldx ENV.BufLen
				ldy #$ff
				dex
.1				iny
				inx
				lda (ZPPtr3),y
				sta K.Buf256,x
				bne .1
				stx ENV.BufLen
				rts
*--------------------------------------
ENV.AddAToBuf	ldx ENV.BufLen
				sta K.Buf256,x
				inc ENV.BufLen
				rts
*/--------------------------------------
* # PutEnv
* Change or add an environment variable, string is 'NAME=VALUE'
* ## C
* `int putenv(char *string);`
* ## ASM
* **In:**
* `>PUSHW string`
* `>SYSCALL putenv`
* ## RETURN VALUE
*\--------------------------------------
K.PutEnv		>PULLW TXTPTR		NAME=VALUE

				ldy #$ff

.1				iny
				lda (TXTPTR),y		 NAME=
				beq .9

				cmp #'='
				bne .1

				tya
				sec					skip =
				adc TXTPTR
				sta FORPNT
				
				lda #0
				adc TXTPTR+1
				sta FORPNT+1
				
				bra K.SetEnv.I

.9				lda #E.SYN
				sec
				rts
*/--------------------------------------
* # SetEnv
* Change or add an environment variable
* ## C
* `int setenv(const char *name, const char *value);`
* ## ASM
* **In:**
* `>PUSHW name`
* `>PUSHW value`
* `>SYSCALL setenv`
* ## RETURN VALUE
*\--------------------------------------
K.SetEnv		>PULLW FORPNT			value
				>PULLW TXTPTR			name
				
K.SetEnv.I		jsr K.UnsetEnv.I
				
.1				jsr ENV.InitEnvP3		ZPPtr3 -> Env (SETREADAUX)

				lda #1
				sta ZPPtr4
				stz ZPPtr4+1			ZPPtr4 = ENVSIZE = 1

.10				lda (ZPPtr3)			End of ENV
				beq .15

				jsr ENV.GetP3LenY
				jsr ENV.NextEnvP3Y
				jsr ENV.NextEnvP4Y
				bra .10

.15				.DO AUXENV=1
				sta CLRREADAUX
				.FIN
				
				ldy #$ff

.16				iny
				lda (TXTPTR),y
				beq .17

				jsr SHARED.IsIDValid
				bcc .16

.17				jsr ENV.NextEnvP4Y		ZPPtr4 = ENVSIZE + VAR

				ldy #$ff

.19				iny
				lda (FORPNT),y
				bne .19

				jsr ENV.NextEnvP4Y		ZPPtr4 = ENVSIZE + VALUE
				lda ZPPtr4
				beq .20

				inc ZPPtr4+1

.20				ldy #S.PS.ENVPAGECNT
				lda (pPs),y
				cmp ZPPtr4+1
				bcs .22				env is large enough

				lda ZPPtr4+1
				jsr ENV.Dup.A
				bcs .9

				phx					page count
				pha					hENV
				
				ldy #S.PS.hENV
				lda (pPs),y
				
				.DO AUXENV=1
				ldx #SYS.FreeStkObj
				jsr K.SYSCALL2.AUX
				.ELSE
				jsr K.Freemem
				.FIN
				
				pla					hEnv
				ldy #S.PS.hENV
				sta (pPs),y
				pla					page count
				dey					S.PS.ENVPAGECNT
				sta (pPs),y
				bra .1				Start over

.22				ldy #$ff

				.DO AUXENV=1
				sta SETWRITEAUX
				.FIN
				
.23				iny
				lda (TXTPTR),y
				sta (ZPPtr3),y
				beq .24
				jsr SHARED.IsIDValid
				bcc .23

.24				lda #'='
				sta (ZPPtr3),y
				
				jsr ENV.NextEnvP3Y
				ldy #$ff

.25				iny
				lda (FORPNT),y
				sta (ZPPtr3),y
				bne .25

				iny
				sta (ZPPtr3),y			don't forget array ending 0
				clc

.9				.DO AUXENV=1
				sta CLRREADAUX
				sta CLRWRITEAUX
				.FIN
				rts
*/--------------------------------------
* # GetEnv
* searches the environment list to find the environment variable name, 
* and returns a pointer to the corresponding value string.
* ## C
* `char *getenv(const char *name, char *value);`
* ## ASM
* **In:**
* `>PUSHW name`
* `>PUSHW value`
* `>SYSCALL getenv`
* ## RETURN VALUE
*  CC : Y,A = PTR to VALUE (C-String)
*  CS : not found
*\--------------------------------------
K.GetEnv		>PULLW FORPNT			value
				>PULLW TXTPTR			name
				
K.GetEnv.I		lda TXTPTR
				beq K.GetEnvDump

				jsr ENV.FindVar
				bcs .9

				jsr ENV.NextEnvP3Y		Skip NAME=

				lda FORPNT+1
				bne .3

				ldy #$ff
				
				.DO AUXENV=1
				sta SETREADAUX
				.FIN
				
.1				iny
				lda (ZPPtr3),y
				bne .1

				.DO AUXENV=1
				sta CLRREADAUX
				.FIN
				
				iny
				bne .2
				inc

.2				.DO AUXENV=1
				sta CLRREADAUX
				sta CLRWRITEAUX
				.FIN
				
				jsr K.getmem
				bcs .99
				
				>STYA FORPNT

.3				.DO AUXENV=1
				sta SETREADAUX
				.FIN
				
				ldy #$ff

.4				iny
				lda (ZPPtr3),y
				sta (FORPNT),y
				bne .4
				
				>LDYA FORPNT
				.DO AUXENV=1
				sta CLRREADAUX
				.FIN

				clc
				rts
				
.9				>LDYAI 0
*				sec
.99				rts

K.GetEnvDump	ldy #S.PS.ENVPAGECNT
				lda (pPs),y
				sta .1+1
				
				ldy #0
				jsr K.getmem
				bcs .9

				>STYA FORPNT
				sty .80+1
				sta .81+1
				stx .82+1
				
				jsr ENV.InitEnvP3		SETREADAUX

.1				ldx #$ff				SELF MODIFIED

				ldy #0

.2				lda (ZPPtr3),y
				sta (FORPNT),y
				iny
				bne .2


.80				ldy #$ff				SELF MODIFIED
.81				lda #$ff				SELF MODIFIED
.82				ldx #$ff				SELF MODIFIED

				.DO AUXENV=1
				sta CLRREADAUX
				.FIN

				clc
.9				rts
*/--------------------------------------
* # UnsetEnv
* Remove an environment variable
* ## C
* `int unsetenv(const char *name);`
* ## ASM
* **In:**
* `>PUSHW name`
* `>SYSCALL unsetenv`
* ## RETURN VALUE
*\--------------------------------------
K.UnsetEnv		>PULLW TXTPTR			name

K.UnsetEnv.I	jsr ENV.FindVar
				bcs K.UnsetEnv.I.8		not found, quit

				jsr ENV.DelVarP3		Ptr3 -> NAME=VALUE
K.UnsetEnv.I.8	clc
				
K.UnsetEnv.I.9	rts
*--------------------------------------
* ENV.FindVar
*  In:
*	 TXTPTR -> NAME
*  Out:
*   CC: Found
*    Y = NAME len
*	 TXTPTR -> NAME
*	 ZPPtr3 -> NAME=VALUE
*	CS: Not Found
*	 TXTPTR -> NAME
*	 ZPPtr3 -> PTR to Ending 0
*--------------------------------------
ENV.FindVar
				.DO AUXENV=1
				sta SETREADAUX
				sta SETWRITEAUX
				.FIN
				
				jsr ENV.InitEnvP3		Store ENV

.1				lda (ZPPtr3)
				beq .9					end of ENV

				ldy #$ff

.2				iny
				.DO AUXENV=1
				jsr SHARED.TXTPTR.GetY
				.ELSE
				lda (TXTPTR),y
				.FIN
				beq .3

				jsr SHARED.IsIDValid
				bcs .3

				cmp	(ZPPtr3),y
				beq .2

				bra .4

.3				lda (ZPPtr3),y
				cmp #'='
				bne .4

				.DO AUXENV=1
				sta CLRREADAUX
				sta CLRWRITEAUX
				.FIN
				clc
				rts

.4				jsr ENV.NextEnvP3		Skip NAME=VALUE
				bra .1

.9				.DO AUXENV=1
				sta CLRREADAUX
				sta CLRWRITEAUX
				.FIN
				sec
				rts	
*--------------------------------------
* ENV.DelVarP3
*  In:
*	ZPPtr3 -> ENV.NAME to Discard
*--------------------------------------
ENV.DelVarP3	.DO AUXENV=1
				sta SETREADAUX
				sta SETWRITEAUX
				.FIN
				>LDYA ZPPtr3			save actual Ptr
				>STYA ZPPtr4
				jsr ENV.NextEnvP3		Skip NAME=VALUE

.1				ldy #$ff

.2				iny
				lda (ZPPtr3),y			Move back CSTRs...
				sta (ZPPtr4),y
				bne .2

				tya
				
				beq .8					we moved back ending \0

				jsr ENV.NextEnvP3Y
				jsr ENV.NextEnvP4Y
				bra .1
				
.8				.DO AUXENV=1
				sta CLRREADAUX
				sta CLRWRITEAUX
				.FIN
				rts
*--------------------------------------
ENV.InitEnvP3	.DO AUXENV=1
				sta CLRREADAUX
				.FIN
				ldy #S.PS.hENV
				lda (pPs),y
				.DO AUXENV=1
				sta SETREADAUX
				.FIN
				jsr K.GetMemPtr
				>STYA ZPPtr3			Store ENV
ENV.InitEnvP3.RTS
				rts
*--------------------------------------
ENV.NextEnvP3	jsr ENV.GetP3LenY
*--------------------------------------
ENV.NextEnvP3Y	tya
ENV.NextEnvP3A	sec
				adc ZPPtr3
				sta ZPPtr3
				bcc .8
				inc ZPPtr3+1
.8				rts
*--------------------------------------
ENV.GetP3LenY	ldy #$ff
.1				iny
				lda (ZPPtr3),y
				bne .1
				rts
*--------------------------------------			
ENV.NextEnvP4Y	tya
				sec
				adc ZPPtr4
				sta ZPPtr4
				bcc .8
				inc ZPPtr4+1
.8				rts
*--------------------------------------
* ENV.Dup
*  In:
*   A = ENV hMem To Duplicate
*  Out:
*   A = hMem to new ENV
*   X = Page Count
*--------------------------------------
ENV.Dup			ldy #S.PS.ENVPAGECNT
				lda (pPs),y

ENV.Dup.A		sta .8+1				Store target page Count	

				ldy #S.PS.ENVPAGECNT	get SOURCE page count
				lda (pPs),y
				sta .10+1

				ldy	#S.PS.hENV
				lda (pPs),y
				.DO AUXENV=1
				sta SETREADAUX
				sta SETWRITEAUX
				.FIN
				jsr K.GetMemPtr
				>STYA .1+1
				
				ldy #0
				lda .8+1
				jsr K.GetMem
				bcs .9

				>STYA .2+1				Target Buffer
				phx						save hMem
				jsr Mem.SetOwner		Set Ownership

				ldy #0
				
.10				ldx #$ff				SELF MODIFIED				

.1				lda $ffff,y				SELF MODIFIED
.2				sta $ffff,y				SELF MODIFIED
				iny
				bne .1

				inc .1+2
				inc .2+2
				dex
				bne .1

.8				ldx #$ff				SELF MODIFIED Target Page Count
				pla						hMem
				clc
				
.9				.DO AUXENV=1
				sta CLRREADAUX
				sta CLRWRITEAUX
				.FIN
				rts
*--------------------------------------
MAN
SAVE USR/SRC/SYS/KERNEL.S.ENV
LOAD USR/SRC/SYS/KERNEL.S
ASM
