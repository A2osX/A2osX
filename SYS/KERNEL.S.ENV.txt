NEW
  AUTO 3,1
*/--------------------------------------
* # Expand
* ## C
* `char *expand(const char *str, char *expanded);`
* ## ASM
* **In:**
* `>PUSHW str`
* `>PUSHW expanded`
* `>SYSCALL expand`
* ## RETURN VALUE
*  Y,A = PTR to Expanded String 
*  X = hMem to Expanded String (C-String)
*\--------------------------------------
				.DUMMY
				.OR ZPDRV
ENV.BufLen		.BS 1
ENV.VarEndChar	.BS 1
ENV.bNoExp		.BS 1
ENV.bExp		.BS 1
				.ED
*--------------------------------------
K.Expand		jsr K.strdup
				bcc .1
				
				rts
				
.1				phx						Save temp string...
				>STYA TXTPTR

				stz	ENV.BufLen			init Expanded String len=0
				stz ENV.bExp			No var found yet
				stz ENV.bNoExp			Reset no expand flag

.10				lda (TXTPTR)			End of CSTR?
				beq .80

				jsr SHARED.TXTPTR.Next
				
.11				cmp #'''
				bne .21

				lda ENV.bNoExp
				eor #$ff
				sta ENV.bNoExp			toggle flag
				bra	.10

.21				bit ENV.bNoExp
				bpl .23

.22				jsr ENV.AddAToBuf
				bra .10

.23				cmp #'$'				no, found one ?
				bne .22					no, store...

				ror ENV.bExp			Toggle Expanded flag
				lda (TXTPTR)
				bne .30

				lda #'$'				End of string, output $
				bra .22
				
.30				stz ENV.VarEndChar
				cmp #'{'				 "${VAR]"?
				bne .31

				dec ENV.VarEndChar		"}" expected

				jsr SHARED.TXTPTR.Next	skip "{"
				bra .40

.31				jsr ENV.SysVar			0-9 *#?@$!
				bcs .40

.35				jsr SHARED.TXTPTR.Next	skip $x
				bra .10
				
.40				jsr ENV.ExpandStrVar
				bcc .70

.50				ldy ENV.BufLen
				lda /K.Buf256
				>STYA FORPNT

				jsr K.GetEnv.I
				bcs .70

				ldx ENV.BufLen
				
.51				lda K.Buf256,x
				beq .52
				inx
				bra .51
				
.52				stx	ENV.BufLen
				
.70				lda (TXTPTR)
				beq .72

				jsr SHARED.IsIDValid
				bcs .72
				jsr SHARED.TXTPTR.Next
				bra .70

.72				lda ENV.VarEndChar			
				bne .35					skip "}" and loop

				bra .10

.80				ldx ENV.BufLen
				stz K.Buf256,x

				pla						discard temp string
				jsr K.FreeMem

				>LDYAI K.Buf256			dup in case of '' processing
				jsr K.strdup
				bcs .9
				
				bit ENV.bExp			Did we expand something ?
				bpl .9
				jmp .1
				
*				clc
.9				rts
*--------------------------------------
ENV.SysVar		jsr ZP.IsDigit			$0 ... $9 ?
				bcs .1

				and #$0f

				jsr K.ArgV
				bcs .8					Arg# is undefined, do not append anything

				jsr ENV.AddYAToBuf

.8				clc
				rts

.1				ldx #ENV.SysVars.Cnt-1

.2				cmp ENV.SysVars,x
				beq .3
				dex
				bpl .2
				
				sec
				rts

.3				txa
				beq ENV.SysVarsAllArgs

				ldy ENV.SysVars.PS-1,x
				lda (pPS),y
*--------------------------------------
ENV.SysVarsNum	jsr MATH.A2STR10NP
				ldy #0
.1				lda A2osX.NumStrBuf,y
				beq ENV.SysVarsNum.8
				iny
				jsr ENV.AddAToBuf
				bra .1
ENV.SysVarsNum.8
				clc
				rts
*--------------------------------------
ENV.SysVarsAllArgs
				lda #1
				jsr K.ArgV
				bcs ENV.SysVarsNum.8
				>STYA ZPPtr3

.1				lda (ZPPtr3)
				beq ENV.SysVarsNum.8

.2				jsr ENV.AddP3ToBuf
				jsr ENV.NextEnvP3
				lda (ZPPtr3)
				beq ENV.SysVarsNum.8
				lda #C.SPACE
				jsr ENV.AddAToBuf
				bra .2
*--------------------------------------
ENV.SysVars		.AS "*#?@$!"
ENV.SysVars.Cnt	.EQ *-ENV.SysVars
ENV.SysVars.PS	.DA #S.PS.ARGC,#S.PS.RC,#S.PS.PPID,#S.PS.PID,#S.PS.CPID
*--------------------------------------
ENV.ExpandStrVar
				>LDYAI ENV.StrVars
				>STYA ZPPtr3
				ldx #0

.1				lda (ZPPtr3)
				beq .9

				ldy #$ff
.2				iny
				lda (TXTPTR),y
				beq .3

				jsr SHARED.IsIDValid
				bcs .3

				cmp (ZPPtr3),y
				beq .2

				bra .4

.3				lda (ZPPtr3),y
				bne .4

				jmp (ENV.StrVarsJmp,x)

.4				inx
				inx
				jsr ENV.NextEnvP3
				bra .1

.9				sec
				rts
*--------------------------------------
ENV.StrVars		.AZ "LOGNAME"
				.AZ "GECOS"
				.AZ "HOME"
				.AZ "SHELL"
				.AZ "PWD"
				.AZ "UID"
				.AZ "GID"
				.DA #0
*--------------------------------------
ENV.StrVarsJmp	.DA ENV.StrVarsSession
				.DA ENV.StrVarsSession
				.DA ENV.StrVarsSession
				.DA ENV.StrVarsSession
				.DA ENV.StrVarsPWD
				.DA ENV.StrVarsUID
				.DA ENV.StrVarsGID
*--------------------------------------
ENV.StrVarsPWD	ldy #S.PS.hCWD
				lda (pPS),y
				jsr K.GetMemPtr
				jmp ENV.AddYAToBuf
*--------------------------------------
ENV.StrVarsUID	ldy #S.SESSION.UID
				.HS 2C
ENV.StrVarsGID	ldy #S.SESSION.GID
				lda (pSession),y
				jmp ENV.SysVarsNum
ENV.StrVarsSession
				lda pSession
				clc
				adc #S.SESSION.NAME
				sta ZPPtr3
				lda pSession+1
				adc /S.SESSION.NAME
				sta ZPPtr3+1

.1				dex
				dex
				bmi ENV.AddP3ToBuf

				ldy #$ff
.2				iny
				lda (ZPPtr3),y
				bne .2

				jsr ENV.NextEnvP3Y
				bra .1
*--------------------------------------
ENV.AddYAToBuf	>STYA ZPPtr3
*--------------------------------------
ENV.AddP3ToBuf	ldx ENV.BufLen
				ldy #$ff
				dex
.1				iny
				inx
				lda (ZPPtr3),y
				sta K.Buf256,x
				bne .1
				stx ENV.BufLen
				rts
*--------------------------------------
ENV.AddAToBuf	ldx ENV.BufLen
				sta K.Buf256,x
				inc ENV.BufLen
				rts
*/--------------------------------------
* # PutEnv
* Change or add an environment variable, string is 'NAME=VALUE'
* ## C
* `int putenv(char *string);`
* ## ASM
* **In:**
* `>PUSHW string`
* `>SYSCALL putenv`
* ## RETURN VALUE
*\--------------------------------------
K.PutEnv		>PULLW TXTPTR		NAME=VALUE

				ldy #$ff

.1				iny
				lda (TXTPTR),y		 NAME=
				beq .9

				cmp #'='
				bne .1

				tya
				sec					skip =
				adc TXTPTR
				sta FORPNT
				
				lda #0
				adc TXTPTR+1
				sta FORPNT+1
				
				bra K.SetEnv.I

.9				lda #E.SYN
				sec
				rts
*/--------------------------------------
* # SetEnv
* Change or add an environment variable
* ## C
* `int setenv(const char *name, const char *value);`
* ## ASM
* **In:**
* `>PUSHW name`
* `>PUSHW value`
* `>SYSCALL setenv`
* ## RETURN VALUE
*\--------------------------------------
K.SetEnv		>PULLW FORPNT			value
				>PULLW TXTPTR			name
				
K.SetEnv.I		ldy #S.PS.hENV
				lda (pPs),y
				
				sta SETREADAUX
				sta SETWRITEAUX
				jsr ENVX.SetEnv
				sta CLRREADAUX
				sta CLRWRITEAUX
				rts
				
				jsr K.UnsetEnv.I
				
.1				jsr ENV.InitEnvP3		ZPPtr3 -> Env (SETREADAUX)

				lda #1
				sta ZPPtr4
				stz ZPPtr4+1			ZPPtr4 = ENVSIZE = 1

.10				lda (ZPPtr3)			End of ENV
				beq .15

				jsr ENV.GetP3LenY
				jsr ENV.NextEnvP3Y
				jsr ENV.NextEnvP4Y
				bra .10

.15				sta CLRREADAUX
				
				ldy #$ff

.16				iny
				lda (TXTPTR),y
				beq .17

				jsr SHARED.IsIDValid
				bcc .16

.17				jsr ENV.NextEnvP4Y		ZPPtr4 = ENVSIZE + VAR

				ldy #$ff

.19				iny
				lda (FORPNT),y
				bne .19

				jsr ENV.NextEnvP4Y		ZPPtr4 = ENVSIZE + VALUE
				lda ZPPtr4
				beq .20

				inc ZPPtr4+1

.20				ldy #S.PS.ENVPAGECNT
				lda (pPs),y
				cmp ZPPtr4+1
				bcs .22				env is large enough

				lda ZPPtr4+1
				jsr ENV.Dup.A
				bcs .9

				phx					page count
				pha					hENV
				
				ldy #S.PS.hENV
				lda (pPs),y
				
				ldx #SYS.FreeStkObj
				jsr K.SYSCALL2.AUX
				
				pla					hEnv
				ldy #S.PS.hENV
				sta (pPs),y
				pla					page count
				dey					S.PS.ENVPAGECNT
				sta (pPs),y
				bra .1				Start over

.22				ldy #$ff

				sta SETWRITEAUX
				
.23				iny
				lda (TXTPTR),y
				sta (ZPPtr3),y
				beq .24
				jsr SHARED.IsIDValid
				bcc .23

.24				lda #'='
				sta (ZPPtr3),y
				
				jsr ENV.NextEnvP3Y
				ldy #$ff

.25				iny
				lda (FORPNT),y
				sta (ZPPtr3),y
				bne .25

				iny
				sta (ZPPtr3),y			don't forget array ending 0
				clc

.9				sta CLRREADAUX
				sta CLRWRITEAUX
				rts
*/--------------------------------------
* # GetEnv
* searches the environment list to find the environment variable name, 
* and returns a pointer to the corresponding value string.
* ## C
* `char *getenv(const char *name, char *value);`
* ## ASM
* **In:**
* `>PUSHW name`
* `>PUSHW value`
* `>SYSCALL getenv`
* ## RETURN VALUE
*  CC : Y,A = PTR to VALUE (C-String)
*  CS : not found
*\--------------------------------------
K.GetEnv		>PULLW FORPNT			value
				>PULLW TXTPTR			name
				
K.GetEnv.I		ldy #S.PS.hENV
				lda (pPs),y
				
				ldy TXTPTR+1
				bne	.10

				tax
				
				jsr MEM.GetMemByID
				
				sta SETREADAUX
				ldy #S.MEM.LEN
				lda (ZPMemMgrSPtr),y
				pha
				iny
				lda (ZPMemMgrSPtr),y
				ply
				sta CLRREADAUX

				jmp MEM.CopyToMain

.10				sta SETREADAUX
				sta SETWRITEAUX
				jsr ENVX.GetEnv
				sta CLRREADAUX
				sta CLRWRITEAUX
				rts
*/--------------------------------------
* # UnsetEnv
* Remove an environment variable
* ## C
* `int unsetenv(const char *name);`
* ## ASM
* **In:**
* `>PUSHW name`
* `>SYSCALL unsetenv`
* ## RETURN VALUE
*\--------------------------------------
K.UnsetEnv		>PULLW TXTPTR			name

K.UnsetEnv.I	ldy #S.PS.hENV
				lda (pPs),y
				
				sta SETREADAUX
				sta SETWRITEAUX
				jsr ENVX.UnsetEnv
				sta CLRREADAUX
				sta CLRWRITEAUX
				rts
*--------------------------------------
ENV.InitEnvP3	sta CLRREADAUX
				ldy #S.PS.hENV
				lda (pPs),y
				sta SETREADAUX
				jsr K.GetMemPtr
				>STYA ZPPtr3			Store ENV

				rts
*--------------------------------------
ENV.NextEnvP3	jsr ENV.GetP3LenY
*--------------------------------------
ENV.NextEnvP3Y	tya
ENV.NextEnvP3A	sec
				adc ZPPtr3
				sta ZPPtr3
				bcc .8
				inc ZPPtr3+1
.8				rts
*--------------------------------------
ENV.GetP3LenY	ldy #$ff
.1				iny
				lda (ZPPtr3),y
				bne .1
				rts
*--------------------------------------			
ENV.NextEnvP4Y	tya
				sec
				adc ZPPtr4
				sta ZPPtr4
				bcc .8
				inc ZPPtr4+1
.8				rts
*--------------------------------------
* ENV.Dup
*  In:
*   A = ENV hMem To Duplicate
*  Out:
*   A = hMem to new ENV
*   X = Page Count
*--------------------------------------
ENV.Dup			ldy #S.PS.ENVPAGECNT
				lda (pPs),y

ENV.Dup.A		sta .8+1				Store target page Count	

				ldy #S.PS.ENVPAGECNT	get SOURCE page count
				lda (pPs),y
				sta .10+1

				ldy	#S.PS.hENV
				lda (pPs),y
				sta SETREADAUX
				sta SETWRITEAUX
				jsr K.GetMemPtr
				>STYA .1+1
				
				ldy #0
				lda .8+1
				jsr K.GetMem
				bcs .9

				>STYA .2+1				Target Buffer
				phx						save hMem
				jsr Mem.SetOwner		Set Ownership

				ldy #0
				
.10				ldx #$ff				SELF MODIFIED				

.1				lda $ffff,y				SELF MODIFIED
.2				sta $ffff,y				SELF MODIFIED
				iny
				bne .1

				inc .1+2
				inc .2+2
				dex
				bne .1

.8				ldx #$ff				SELF MODIFIED Target Page Count
				pla						hMem
				clc
				
.9				sta CLRREADAUX
				sta CLRWRITEAUX
				rts
*--------------------------------------
MAN
SAVE USR/SRC/SYS/KERNEL.S.ENV
LOAD USR/SRC/SYS/KERNEL.S
ASM
