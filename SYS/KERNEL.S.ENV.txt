PR#3
PREFIX /A2OSX.BUILD
LOMEM $A00
INC 1
AUTO 6
*/--------------------------------------
* # ExpandStr.YA
* ## In:
*  Y,A = PTR to String to Expand (C-String)
* ## Out:
*  X = hMem to Expanded String (C-String)
*  Y,A = PTR to Expanded String 
*\--------------------------------------
K.ExpandStr.YA	stz K.ExpandStr.hPStr	Reset Intermediate string...

.1				>STYA ZPPtr2
				stz	K.ExpandStr.Len		init Expanded String len=0
				stz K.ExpandStr.bFound	No var found yet

				stz K.ExpandStr.bNoExp	Reset no expand flag
				
				ldy #0

.10				stz K.ExpandStr.VarLen
				stz K.ExpandStr.bInVar

.11				lda (ZPPtr2),y			End of CSTR?
				beq .8

				iny

				cmp #'''
				bne .21

				lda K.ExpandStr.bNoExp
				eor #$ff
				sta K.ExpandStr.bNoExp	toggle flag
				bra	 .11

.21				bit K.ExpandStr.bNoExp
				bpl .23

.22				ldx K.ExpandStr.Len
				sta K.Buf256,x
				inx
				stx K.ExpandStr.Len
				bra .11

.23				ldx K.ExpandStr.bInVar 	already in a var?
				bne .3					yes...

				cmp #'$'				no, found one ?
				bne .22					no, store...

				sta K.ExpandStr.bFound	Toggle flag
				sta K.ExpandStr.bInVar

				bra .11					skip this char

.3				cmp #'{'				we are in var, "{" after "$"?
				bne .31
				ldx K.ExpandStr.VarLen	No char in var yet ?
				beq .11					normal, "${" syntax is ok,skip

				bne .5					not allowed char in varname, end of var
				
.31				cmp #'}'				end of var?
				beq .50

				jsr K.ExpandStrValidChar
				bcc .32					yes, add to varname
				
				ldx K.ExpandStr.VarLen
				bne .5					varname has already chars...end of var
				
				inx						must be a $? or ?x.....go expand
				stx K.ExpandStr.VarLen
				sta K.ExpandStr.VarName
				bra .51					go Expand....
				
.32				ldx K.ExpandStr.VarLen
				cpx #16
				beq .11					varname longer than 15....ignore
				sta K.ExpandStr.VarName,x
				inx
				stx K.ExpandStr.VarLen
				bra .11

.5				dey						last char was invalid...move back
				
.50				ldx K.ExpandStr.VarLen
				beq .52					var name is empty...start over
				
.51				stz K.ExpandStr.VarName,x
				phy						save current index
				jsr K.ExpandStrGetValue
				ply						restore index in string...
.52				jmp .10					reset start flag and continue
				
.8				ldx K.ExpandStr.VarLen	end of STR,are we in a var?
				beq .80					no...exit...
				
				stz K.ExpandStr.VarName,x
				jsr K.ExpandStrGetValue	yes, expand and add to STR
				
.80				lda K.ExpandStr.hPStr	working from our temp string ?
				beq .81					no...
				
				jsr K.FreeMem.A			yes, discard....

.81				ldx K.ExpandStr.Len
				stz K.Buf256,x
				
				>LDYAI K.Buf256
				jsr K.NewStr.YA
				bcs .9
				stx K.ExpandStr.hPStr	save this as temp string, in case of recurse
				ldx K.ExpandStr.bFound	Did we expand something ?
				beq .82
				jmp .1					Yes, start over with hPStr

.82				ldx K.ExpandStr.hPStr
* or exit with Y,A from K.NewStrYA
				
.9				rts					
*--------------------------------------
K.ExpandStrValidChar
				cmp #'0'
				bcc .9
				cmp #'9'+1
				bcc .8
				
				cmp #'A'
				bcc .9
				cmp #'Z'+1
				bcc .8
				
				cmp #'_'
				bne .9
				
.8				clc
				rts
.9				sec
				rts
*--------------------------------------
K.ExpandStrGetValue
				jsr ENV.ExpandSysVar
				bcc .9
				
				>LDYAI K.ExpandStr.VarName
				jsr K.GetEnv.YA
				bcs .9
				
				>STYA ZPPtr3
				
				jsr ENV.AppendPtr3ToBuf
				
.9				rts
*--------------------------------------
K.ExpandStr.Len		.BS 1
K.ExpandStr.bNoExp	.BS 1
K.ExpandStr.bInVar	.BS 1
K.ExpandStr.bFound	.BS 1
K.ExpandStr.hPStr	.BS 1
K.ExpandStr.VarLen	.BS 1
K.ExpandStr.VarName	.BS 16
*/--------------------------------------
* # PutEnv.YA
* ## In:
*  Y,A = PTR to String NAME=VALUE (C-String)
* ## Out:
*\--------------------------------------
K.PutEnv.YA		>STYA ZPPtr1		NAME=VALUE

				ldy #0
				
.1				lda (ZPPtr1),y		copy STR to K.Buf256
				beq .9
				cmp #'='
				beq .2
				sta K.Buf256,y
				iny
				bne .1
				
.2				lda #0
				sta K.Buf256,y

				tya
				sec
				adc ZPPtr1
				sta ZPPtr2
				lda ZPPtr1+1
				adc #0
				sta ZPPtr2+1

				>LDYAI K.Buf256
				>STYA ZPPtr1
				bra K.SetEnvPtr1Ptr2

.9				sec
				rts
*/--------------------------------------
* # SetEnv
* ## In:
*  PUSHW = PTR To Value (PSTR)
*  PUSHW = PTR To Name (PSTR)
* ## Out:
*\--------------------------------------
K.SetEnv		jsr PullPtr1Ptr2		Ptr1=NAME,Ptr2=VALUE
K.SetEnvPtr1Ptr2
				jsr S.UnsetEnvPtr1

				jsr ENV.InitEnvPtr3		ZPPtr3 -> Env

				ldy #0
				ldx #0
				
.10				lda (ZPPtr3)			End of ENV
				beq .15
				
.11				iny						Compute ENV size in X,Y
				bne .12
				inx
				
.12				inc ZPPtr3
				bne .13
				inc ZPPtr3+1
				
.13				lda (ZPPtr3)			End of string
				bne .11

				iny
				bne .14
				inx
				
.14				inc ZPPtr3
				bne .10
				inc ZPPtr3+1
				bra .10

.15				sty ZPPtr4
				stx ZPPtr4+1

				ldy #0
				
.16				lda (ZPPtr1),y
				beq .17
				iny
				bne .16
				
.17				tya
				sec
				adc ZPPtr4
				sta ZPPtr4
				bcc .18
				inc ZPPtr4+1
				
.18				ldy #0

.19				lda (ZPPtr2),y
				beq .20
				iny
				bne .19
				
.20				tya
				sec
				adc ZPPtr4
				tax
				bcc .21
				inc ZPPtr4+1
	
.21				cpx #K.ENV.SIZE
				lda ZPPtr4+1
				sbc /K.ENV.SIZE
				bcs .99
				
				ldy #$ff
				
.22				iny
				lda (ZPPtr1),y
				sta (ZPPtr3),y
				bne .22
				
				tya
				sec
				adc ZPPtr3
				sta ZPPtr3
				bcc .23
				inc ZPPtr3+1
				
.23				ldy #$ff

.24				iny
				lda (ZPPtr2),y
				sta (ZPPtr3),y
				bne .24

				iny
.25				lda #0
				sta (ZPPtr3),y			don't forget array ending 0
				clc
				rts
				
.99				lda #SYSMGR.ERRENVF
*				sec
				rts
*/--------------------------------------
* # GetEnv.YA
* ## In:
*  Y,A = PTR to NAME (PSTR)
* ## Out:
*  CC : Y,A = PTR to VALUE (PSTR)
*  CS : not found
*\--------------------------------------
K.GetEnv.YA		>STYA ZPPtr1
				jsr ENV.FindVarPtr1
				bcs .9
				
				jsr ENV.NextEnvPtr3		Skip NAME
				>LDYA ZPPtr3
				clc						just in case ADC in NextEnvPtr1 disturb CC
.8				rts
				
.9				>LDYAI EmptyPSTR
				rts
*/--------------------------------------
* # UnsetEnv.YA
* ## In:
*  Y,A = PTR To Name (PSTR)
* ## Out:
*\--------------------------------------
K.UnsetEnv.YA	>STYA ZPPtr1		Store VAR Name
S.UnsetEnvPtr1	jsr ENV.FindVarPtr1
				bcs .8					not found, quit

				jsr ENV.DiscardVarPtr3	Ptr3 -> ENVNAME
				
.8				clc				
				rts
*--------------------------------------
*               PRIVATE
*--------------------------------------
* ENV.ExpandSysVar
*  In:
*	 K.ExpandStr.VarName
*  Out:
*   CC: Found
*	 Append VALUE to K.Buf256
*	CS: Not Found
*--------------------------------------
ENV.ExpandSysVar
				ldx K.ExpandStr.VarLen
				cpx #1					is name 1 char?
				bne .9

				lda K.ExpandStr.VarName
				cmp #'0'-1				$0...$9 ??
				bcc .1
				cmp #'9'+1
				bcs .1
				and #$0F
				jsr K.GetArg.A
				bcs .99
				
				>STYA ZPPtr3
				jmp ENV.AppendPtr3ToBuf
				
.8				clc
				rts
				
.1				ldx #ENV.SysVarsJmp-ENV.SysVars-1

.2				cmp ENV.SysVars,x
				beq .3
				dex
				bpl .2
				
.9				sec
.99				rts
				
.3				txa
				asl
				tax
				jmp (ENV.SysVarsJmp,x)

ENV.SysVars		.AS "*#?@$!"
ENV.SysVarsJmp	.DA ENV.SysVarsArgs
				.DA ENV.SysVarsArgC
				.DA ENV.SysVarsRC
				.DA ENV.SysVarsPPID
				.DA ENV.SysVarsPID
				.DA ENV.SysVarsCPID
*--------------------------------------
ENV.SysVarsArgs	lda #1
				jsr K.GetArg.A
				bcs ENV.SysVarsExit2
				
				>STYA ZPPtr3
				
.1				lda (ZPPtr3)
				beq ENV.SysVarsExit2
				jsr ENV.AppendPtr3ToBuf
				
.2				jsr ENV.NextEnvPtr3
				lda (ZPPtr3)
				beq ENV.SysVarsExit2
				
				ldx K.Buf256
				inx
				beq ENV.SysVarsExit2	make sure not overlapping buf 256
				stx K.Buf256
				lda #' '
				sta K.Buf256,x
				
				jsr ENV.AppendPtr3ToBuf
				bra .2
*--------------------------------------
ENV.SysVarsArgC jsr K.GetArgC			Trash Ptr1
				bra ENV.SysVarsA
				
ENV.SysVarsRC	ldy #S.PS.RC
				.HS 2C
ENV.SysVarsPPID	ldy #S.PS.PPID
				.HS 2C
ENV.SysVarsPID	ldy #S.PS.PID
				.HS 2C
ENV.SysVarsCPID ldy #S.PS.CPID
				lda (pPS),y

ENV.SysVarsA	sta HEXBUF
				stz	HEXBUF+1
				stz HEXBUF+2
				stz HEXBUF+3
				jsr HEX2DEC
				
				ldy #6					Start at 0000000xxx
				
.1				iny
				lda ASCBUF,y
				cmp #'0'
				bne .2
				
				cpy #9					Print always last char
				bne .1
				
.2				ldx K.Buf256

.3				inx
				beq ENV.SysVarsExit2
				
				sta K.Buf256,x
				iny
				cpy #10
				beq ENV.SysVarsExit
				
				lda ASCBUF,y
				bra .3

ENV.SysVarsExit	stx K.Buf256
ENV.SysVarsExit2
				clc
				rts
*--------------------------------------
* ENV.FindVarPtr1
*  In:
*	 ZPPtr1 -> NAME
*  Out:
*   CC: Found
*	 ZPPtr1 -> NAME
*	 ZPPtr3 -> ENV.NAME
*	CS: Not Found
*	 ZPPtr1 -> NAME
*	 ZPPtr3 -> PTR to Ending 0
*--------------------------------------
ENV.FindVarPtr1	jsr ENV.InitEnvPtr3		Store ENV
				bcs .99

.1				lda (ZPPtr3)
				beq .9					end of ENV
				
				ldy #0

.2				lda (ZPPtr1),y
				cmp	(ZPPtr3),y
				bne .3

				ora #0
				beq .8
				
				iny
				bne .2

.8				clc
				rts

.3				jsr ENV.NextEnvPtr3		Skip NAME
				jsr ENV.NextEnvPtr3		Skip VALUE
				bra .1

.9				sec
.99				rts	
*--------------------------------------
* ENV.DiscardVarPtr3
*  In:
*	ZPPtr3 -> ENV.NAME to Discard
*--------------------------------------
ENV.DiscardVarPtr3
				>LDYA ZPPtr3			save actual Ptr
				>STYA ZPPtr4
				jsr ENV.NextEnvPtr3		Skip current NAME....
				jsr ENV.NextEnvPtr3		Skip current VALUE....

				ldy #0

.1				lda (ZPPtr3),y			Move back CSTRs...

.2				sta (ZPPtr4),y
				beq .3					0 ended....
				iny
				bne .1
				inc ZPPtr3+1
				inc ZPPtr4+1
				bra .1

.3				iny
				bne .4

				inc ZPPtr3+1
				inc ZPPtr4+1

.4				lda (ZPPtr3),y
				bne .2					Until array ending 0
				sta (ZPPtr4),y

.8				rts
*--------------------------------------
ENV.InitEnvPtr3	ldy #S.PS.hENV
				lda (pPs),y
				jsr K.GetMemPtr.A
				>STYA ZPPtr3		Store ENV
				rts
*--------------------------------------
ENV.NextEnvPtr3	ldy #0

.1				lda (ZPPtr3),y
				beq .2
				iny
				bne .1

.2				tya
				sec
				adc ZPPtr3
				sta ZPPtr3
				bcc .8
				inc ZPPtr3+1
.8				rts
*--------------------------------------
ENV.AppendPtr3ToBuf
				ldx #$ff

.1				inx
				lda	K.Buf256,x
				bne .1

				ldy #$ff
				dex

.2				iny
				inx
				lda (ZPPtr3),y
				sta K.Buf256,x
				bne .2

				rts
*--------------------------------------
MAN
SAVE /A2OSX.SRC/SYS/KERNEL.S.ENV
LOAD /A2OSX.SRC/SYS/KERNEL.S
ASM
