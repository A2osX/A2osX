PR#3
PREFIX /A2OSX.SRC
NEW
INC 1
AUTO 6
				.LIST OFF
*/--------------------------------------
* #ExpandPStrYA
* ##In:
*  Y,A = PTR to String to Expand (PSTR)
* ##Out:
*  X = hMem to Expanded String (PSTR)
*  Y,A = PTR to Expanded String 
*\--------------------------------------
K.ExpandPStrYA	stz K.ExpandPStr.hPStr	Reset Intermediate string...
				
.11				>STYA ZPQuickPtr2

				stz	KrnBuf256			init Expanded String len=0		
				stz K.ExpandPStr.bFound	No var found yet
				stz K.ExpandPStr.bNoExp	Reset no expand flag
				
				ldy #0
				
.10				stz K.ExpandPStr.Start
				
.1				tya
				cmp (ZPQuickPtr2)		End of PSTR?
				beq .6
				
				iny
				lda (ZPQuickPtr2),y

				cmp #'''
				bne .21
				
				lda K.ExpandPStr.bNoExp
				eor #$ff
				sta K.ExpandPStr.bNoExp toggle flag
				bra	 .1
				
.21				bit K.ExpandPStr.bNoExp
				bmi .22

				ldx K.ExpandPStr.Start	
				bne .3					already in a var?
				
				cmp #'$'				no, found one ?
				beq .2
				
.22				inc KrnBuf256		no, copy char
				ldx KrnBuf256
				sta KrnBuf256,x				
				bra .1
				
.2				sec
				ror K.ExpandPStr.bFound	Toggle flag
				
				sty K.ExpandPStr.Start	save var start
				stz K.ExpandPStr.End
				bra .1					skip this char

.3				cmp #'{'				we are in var, "{" after "$"?
				beq .2

				cmp #'}'				end of var?
				beq .5

				jsr K.ExpandPStr.VC		we are in var, is char valid?
				bcs .5					no, end here
				sty K.ExpandPStr.End	yes, save end
				bra .1
				
.5				lda K.ExpandPStr.End	get end
				beq .1					empty {} or $/
				
				phy						save current index
				jsr K.ExpandPStr.AV
				ply						restore index in string...
				bra .10					reset start flag and continue
				
.6				sty K.ExpandPStr.End	end of PSTR
				lda K.ExpandPStr.Start	are we in a var?
				beq .8					no...exit...
				
				jsr K.ExpandPStr.AV		yes, expand and add to STR
				
.8				lda K.ExpandPStr.hPStr	working from our temp string ?
				beq .81					no...
				
				jsr K.FreeMemA			yes, discard....

.81				>LDYAI KrnBuf256
				jsr K.NewPStrYA
				bcs .9
				stx K.ExpandPStr.hPStr	save this as temp string, in case of recurse
				bit K.ExpandPStr.bFound	Did we expand something ?
				bpl .82
				jmp .11					Yes, start over with hPStr

.82				
* or exit with Y,A & X from K.NewPStrYA
				
.9				rts					
*--------------------------------------
K.ExpandPStr.AV	lda K.ExpandPStr.End	
				sec
				sbc K.ExpandPStr.Start	compute len of VAR End-Start+1
				
				ldx KrnBuf256
				inx
				sta KrnBuf256,x
				
				stx ZPQuickPtr1			Make Ptr1 -> Var NAME
				lda /KrnBuf256
				sta ZPQuickPtr1+1
				
				ldy K.ExpandPStr.Start
		
.1				iny
				inx
				lda (ZPQuickPtr2),y
				sta KrnBuf256,x
				cpy K.ExpandPStr.End
				bne .1
				
				jsr ENV.CheckSysVarPtr1
				bcc .2					Ptr3=VALUE
				
				jsr ENV.FindVarPtr1
				bcs .9

				jsr ENV.NextEnvPtr3		Skip NAME
				
.2				lda (ZPQuickPtr3)
				beq .9					in case CheckSysVarPtr1 returned a NUL string
				
				ldy #0
				ldx KrnBuf256
				
.3				iny
				lda (ZPQuickPtr3),y
				inx
				sta KrnBuf256,x
					
				tya
				cmp (ZPQuickPtr3)		last char?
				bne .3
				stx KrnBuf256
				
.9				rts
*--------------------------------------
K.ExpandPStr.VC	cmp #'0'
				bcc .9
				cmp #'9'+1
				bcc .8
				
				cmp #'A'
				bcc .9
				cmp #'Z'+1
				bcc .8
				
				cmp #'_'
				bne .9
				
.8				clc
				rts
.9				sec
				rts
*--------------------------------------
K.ExpandPStr.Start	.BS 1
K.ExpandPStr.End	.BS 1
K.ExpandPStr.bFound	.BS 1
K.ExpandPStr.bNoExp	.BS 1
K.ExpandPStr.hPStr	.BS 1
*/--------------------------------------
* #PutEnvYA
* ##In:
*  Y,A = PTR to String NAME=VALUE (PSTR)
* ##Out:
*\--------------------------------------
K.PutEnvYA		>STYA ZPQuickPtr1		NAME=VALUE

				lda (ZPQuickPtr1)
				beq .9
				sta KrnBuf256
				tay
				
.1				lda (ZPQuickPtr1),y		copy PSTR to KrnBuf256
				sta KrnBuf256,y
				dey
				bne .1
				
				ldy #0
				
.2				iny
				cpy KrnBuf256		last char ?
				beq .9					no "=" found
				
				lda KrnBuf256,y
				cmp #'='
				bne .2
				
				cpy #1					String like "=value" ?
				beq .9
				
				cpy KrnBuf256		last char ?
				beq .9					we have "VAR="

				lda KrnBuf256		get actual string len
				
				sty KrnBuf256		set length of VAR string
				dec KrnBuf256		...without "="
				
				clc					Substract VAR len+1 from whole len to get 
				sbc KrnBuf256		VALUE len
				sta KrnBuf256,y		save it at "=" POS

				stz ZPQuickPtr1		#KrnBuf256
				sty ZPQuickPtr2

				lda /KrnBuf256
				sta ZPQuickPtr1+1
				sta ZPQuickPtr2+1
				
				bra K.SetEnvPtr1Ptr2
				
.9				sec
				rts
*/--------------------------------------
* #SetEnv
* ##In:
*  PUSHW = PTR To Value (PSTR)
*  PUSHW = PTR To Name (PSTR)
* ##Out:
*\--------------------------------------
K.SetEnv		jsr PullPtr1Ptr2		Ptr1=NAME,Ptr2=VALUE
				
K.SetEnvPtr1Ptr2
				jsr S.UnsetEnvPtr1

				jsr ENV.InitEnvPtr3		ZPQuickPtr3 -> Env
				
				lda ZPQuickPtr3			Compute ENV UPPER LIMIT in Ptr4
				clc
				adc #K.ENV.SIZE
				sta ZPQuickPtr4
				
				lda ZPQuickPtr3+1
				adc /K.ENV.SIZE
				sta ZPQuickPtr4+1
				
				ldy ZPQuickPtr3+1
				lda ZPQuickPtr3			Compute New Env Upper limit in A,Y
				sec
				adc (ZPQuickPtr1)		add NAME len +1
				bcc .1
				iny
				
.1				sec						
				adc (ZPQuickPtr2)		add VALUE len +1
				bcc .2
				iny
				
.2				cmp ZPQuickPtr4			GE than hMem Upper limit ?
				tya
				sbc ZPQuickPtr4+1
				bcs .99
				
.3				lda (ZPQuickPtr3)		Scan until ending 0...
				beq .4
			
				inc	ZPQuickPtr3
				bne .3
				inc ZPQuickPtr3+1
				bne .3
				
.4				lda (ZPQuickPtr1)
				sta (ZPQuickPtr3)
				tay
				
.5				lda (ZPQuickPtr1),y
				sta (ZPQuickPtr3),y
				dey
				bne .5
				
				jsr ENV.NextEnvPtr3
				
				lda (ZPQuickPtr2)
				sta (ZPQuickPtr3)
				tay
				
.6				lda (ZPQuickPtr2),y
				sta (ZPQuickPtr3),y
				dey
				bne .6
				
				jsr ENV.NextEnvPtr3
				
.8				lda #0
				
				sta (ZPQuickPtr3)
				clc
				rts
				
.99				lda #SYSMGR.ERRENVF
				sec
				rts
*/--------------------------------------
* #GetEnvYA
* ##In:
*  Y,A = PTR to NAME (PSTR)
* ##Out:
*  CC : Y,A = PTR to VALUE (PSTR)
*  CS : not found
*\--------------------------------------
K.GetEnvYA		>STYA ZPQuickPtr1
				jsr ENV.CheckSysVarPtr1
				bcc .8
				
				jsr ENV.FindVarPtr1
				bcs .9
				jsr ENV.NextEnvPtr3		Skip NAME
				>LDYA ZPQuickPtr3
				clc						just in case ADC in NextEnvPtr1 disturb CC
.8				rts
				
.9				>LDYAI EmptyPSTR
				rts
*/--------------------------------------
* #UnsetEnvYA
* ##In:
*  Y,A = PTR To Name (PSTR)
* ##Out:
*\--------------------------------------
K.UnsetEnvYA	>STYA ZPQuickPtr1		Store VAR Name
S.UnsetEnvPtr1	jsr ENV.FindVarPtr1
				bcs .8					not found, quit

				jsr ENV.DiscardVarPtr3	Ptr3 -> ENVNAME
				
.8				clc				
				rts
*--------------------------------------
*               PRIVATE
*--------------------------------------
* ENV.CheckSysVarPtr1
*  In:
*	 ZPQuickPtr1 -> NAME
*  Out:
*   CC: Found
*	 YA -> VALUE
*	CS: Not Found
*--------------------------------------
ENV.CheckSysVarPtr1
				lda (ZPQuickPtr1)
				cmp #1					is name 1 char?
				bne .9
				
				ldy #1
				lda (ZPQuickPtr1),y
				cmp #'0'-1				$0...$9 ??
				bcc .1
				cmp #'9'+1
				bcs .1
				and #$0F
				jsr K.GetArgA
				>STYA ZPQuickPtr3
				rts
				
.1				ldx #ENV.SysVarsJmp-ENV.SysVars-1

.2				cmp ENV.SysVars,x
				beq .3
				dex
				bpl .2
				
.9				sec
				rts
				
.3				txa
				asl
				tax
				jmp (ENV.SysVarsJmp,x)
*--------------------------------------
ENV.SysVars		.AS "*#?@$!"
ENV.SysVarsJmp	.DA ENV.SysVarsArgs
				.DA ENV.SysVarsArgC
				.DA ENV.SysVarsRC
				.DA ENV.SysVarsPPID
				.DA ENV.SysVarsPID
				.DA ENV.SysVarsCPID
*--------------------------------------
ENV.SysVarsArgs	lda #1
				jsr K.GetArgA			Trash Ptr1
				
				stz KrnOut256

				ldx #0

.1				lda (ZPQuickPtr1)
				beq ENV.SysVarsExit
				
				ldy #0
				
.2				iny
				inx
				lda (ZPQuickPtr1),y
				sta KrnOut256,x
				tya
				cmp (ZPQuickPtr1)
				bne .2
				
				adc	ZPQuickPtr1			CS from beq .2
				sta ZPQuickPtr1
				bcc .3
				inc ZPQuickPtr1+1
.3				lda #' '
				inx
				beq ENV.SysVarsExit		make sure not overlapping buf 256
				sta KrnOut256,x
				bra .1
				
ENV.SysVarsArgC jsr K.GetArgC			Trash Ptr1
				bra ENV.SysVarsA
				
ENV.SysVarsRC	ldy #S.PS.RC
				.HS 2C
ENV.SysVarsPPID	ldy #S.PS.PPID
				.HS 2C
ENV.SysVarsPID	ldy #S.PS.PID
				.HS 2C
ENV.SysVarsCPID ldy #S.PS.CPID
				lda (pPS),y
ENV.SysVarsA	sta HEXBUF
				stz	HEXBUF+1
				stz HEXBUF+2
				stz HEXBUF+3
				jsr HEX2DEC
				
				ldy #0
				
.1				lda ASCBUF,y
				cmp #'0'
				bne .2
				iny
				cpy #10
				bne .1
				
				sta KrnOut256+1
				ldx #1
				bra ENV.SysVarsExit
				
.2				ldx #0

.3				lda ASCBUF,y
				inx
				sta KrnOut256,x
				iny
				cpy #10
				bne .3
				
ENV.SysVarsExit	stx KrnOut256
				>LDYAI KrnOut256
				>STYA ZPQuickPtr3
				clc
				rts
*--------------------------------------
* ENV.FindVarPtr1
*  In:
*	 ZPQuickPtr1 -> NAME
*  Out:
*   CC: Found
*	 ZPQuickPtr1 -> NAME
*	 ZPQuickPtr3 -> ENV.NAME
*	CS: Not Found
*	 ZPQuickPtr1 -> NAME
*	 ZPQuickPtr3 -> PTR to Ending 0
*--------------------------------------
ENV.FindVarPtr1	jsr ENV.InitEnvPtr3		Store ENV
				bcs .99
				
				lda (ZPQuickPtr3)
				beq .9					end of ENV
				
.1				cmp (ZPQuickPtr1)		Same len as NAME?
				bne .3
				
				tay

.2				lda (ZPQuickPtr1),y
				cmp	(ZPQuickPtr3),y
				bne .3
				dey
				bne .2
				clc
				rts
				
.3				jsr ENV.NextEnvPtr3		Skip NAME
				jsr ENV.NextEnvPtr3		Skip VALUE
				lda (ZPQuickPtr3)
				bne .1
				
.9				sec
.99				rts		
*--------------------------------------
* ENV.DiscardVarPtr3	
*  In:
*	ZPQuickPtr3 -> ENV.NAME to Discard
*--------------------------------------
ENV.DiscardVarPtr3
				lda ZPQuickPtr3			Discard current NAME & VALUE definition
				sec						ZPQuickPtr3 -> NAME
				adc (ZPQuickPtr3)		add	NAME+1 to ZPQuickPtr3
				sta ZPQuickPtr4			store it in ZPQuickPtr4
				lda #0
				adc ZPQuickPtr3+1
				sta ZPQuickPtr4+1
				
				lda ZPQuickPtr4			add	VALUE+1 to ZPQuickPtr4
				sec 
				adc (ZPQuickPtr4)
				sta ZPQuickPtr4
				bcc .1
				inc ZPQuickPtr4+1
				 
.1				ldy #0

.2				lda (ZPQuickPtr4),y		Move back tail...
				sta (ZPQuickPtr3),y
				beq .8					...until we move ending 0
				iny
				bne .2
				inc ZPQuickPtr3+1
				inc ZPQuickPtr4+1
				bra .2
				
.8				rts
*--------------------------------------
ENV.InitEnvPtr3	ldy #S.PS.hENV
				lda (pPs),y
				jsr K.GetMemPtrA
				>STYA ZPQuickPtr3		Store ENV
				rts
*--------------------------------------
ENV.NextEnvPtr3	lda ZPQuickPtr3
				sec
				adc (ZPQuickPtr3)
				sta ZPQuickPtr3
				bcc .8
				inc ZPQuickPtr3+1
.8				rts		
*--------------------------------------
MAN
SAVE SYS/KERNEL.S.ENV
LOAD SYS/KERNEL.S
ASM
