PR#3
PREFIX /A2OSX.SRC
NEW
INC 1
AUTO 6
				.LIST OFF
*--------------------------------------
K.ExpandPStrYA.NEW
				>STYA ZPQuickPtr3
				
				lda (ZPQuickPtr3)
				sta KrnBuf256
				tay

.1				lda (ZPQuickPtr3),y
				sta KrnBuf256,y
				dey
				bne .1
				
				ldy #0
				
.2				stz K.ExpandPStr.Start

.3				tya
				cmp KrnBuf256		End of PSTR?
				beq .80
				
				iny
				lda KrnBuf256,y
				
.80

				rts
*--------------------------------------
* K.ExpandPStrYA
*  In:
*   Y,A = PTR to String to Expand (PSTRING)
*  Out:
*   X = hMem to Expanded String (PSTRING)
*   Y,A = PTR to Expanded String 
*--------------------------------------
K.ExpandPStrYA
				>STYA ZPQuickPtr3

				stz	KrnBuf256		init Expanded String len=0		
				
				ldy #0
				
.10				stz K.ExpandPStr.Start
				
.1				tya
				cmp (ZPQuickPtr3)		End of PSTR?
				beq .6
				
				iny
				lda (ZPQuickPtr3),y
				
				ldx K.ExpandPStr.Start	
				bne .3					already in a var?
				
				cmp #'$'				no, found one ?
				beq .2
				
				inc KrnBuf256		no, copy char
				ldx KrnBuf256
				sta KrnBuf256,x				
				bra .1
				
.2				sty K.ExpandPStr.Start	save var start
				stz K.ExpandPStr.End
				bra .1					skip this char

.3				cmp #'{'				in var, "{" after "$"?
				beq .2

				cmp #'}'				end of var?
				beq .5

.4				jsr K.ExpandPStr.VC		valid char ?
				bcs .5					no, end here
				sty K.ExpandPStr.End	yes, save end
				bra .1
				
.5				lda K.ExpandPStr.End	get end
				beq .1					empty {} or $/
				
				phy						save current index
				jsr K.ExpandPStr.AV
				ply						restore index in string...
				bra .10					reset start flag and continue
				
.6				sty K.ExpandPStr.End	end of PSTR
				lda K.ExpandPStr.Start	are we in a var?
				beq .7					no...exit...
				
				jsr K.ExpandPStr.AV		yes, expand and add to STR
				
.7				>LDYAI KrnBuf256
				jsr K.NewPStrYA
				rts					
*--------------------------------------
K.ExpandPStr.AV	lda K.ExpandPStr.End	
				sec
				sbc K.ExpandPStr.Start	compute len of VAR End-Start+1
				
				ldx KrnBuf256
				inx
				sta KrnBuf256,x
				
				stx ZPQuickPtr2
				lda /KrnBuf256
				sta ZPQuickPtr2+1
				
				ldy K.ExpandPStr.Start
		
.1				iny
				inx
				lda (ZPQuickPtr3),y
				sta KrnBuf256,x
				cpy K.ExpandPStr.End
				bne .1
				
				jsr S.CheckSysVarPtr2
				bcs .10
				>STYA ZPQuickPtr1
				bra .11
				
.10				jsr S.FindVarPtr2
				bcs .9

				jsr S.NextEnvPtr1		Skip NAME
				
.11				ldy #0
				ldx KrnBuf256
				
.2				iny
				lda (ZPQuickPtr1),y
				inx
				sta KrnBuf256,x
					
				tya
				cmp (ZPQuickPtr1)		last char?
				bne .2
				stx KrnBuf256
				
.9				rts
*--------------------------------------
K.ExpandPStr.VC	cmp #'0'
				bcc .9
				cmp #'9'+1
				bcc .8
				
				cmp #'A'
				bcc .9
				cmp #'Z'+1
				bcc .8
				
				cmp #'_'
				bne .9
				
.8				clc
				rts
.9				sec
				rts
*--------------------------------------
K.ExpandPStr.Start	.BS 1
K.ExpandPStr.End	.BS 1
*--------------------------------------
* K.PutEnvYA
*--------------------------------------
K.PutEnvYA		>STYA ZPQuickPtr2		NAME=VALUE
				lda (ZPQuickPtr2)
				beq .9
				sta KrnBuf256
				tay
				
.1				lda (ZPQuickPtr2),y
				sta KrnBuf256,y
				dey
				bne .1
				
				ldy #0
				
.2				iny
				cpy KrnBuf256		last char ?
				beq .9					no "=" found
				
				lda KrnBuf256,y
				cmp #'='
				bne .2
				
				cpy #1					String like "=value" ?
				beq .9
				
				cpy KrnBuf256		last char ?
				beq .9					we have "VAR="

				lda KrnBuf256		save actual string len
				
				sty KrnBuf256		set length of VAR string
				dec KrnBuf256		...without "="
				
				
.3				clc						Substract VAR len+1 from whole len to get 
				sbc KrnBuf256		VALUE len
				sta KrnBuf256,y		save it at "=" POS

				tya
				clc
				adc #KrnBuf256
				sta ZPQuickPtr3
				lda /KrnBuf256
				sta ZPQuickPtr3+1
				
				>LDYAI KrnBuf256
				>STYA ZPQuickPtr2
				
				bra K.SetEnvPtr2Ptr3
				
.9				sec
				rts
*--------------------------------------
* K.SetEnv
*  In:
*  PULLW = PTR To Name (PSTRING)
*  PULLW = PTR To Value (PSTRING)
*  Out:
*--------------------------------------
K.SetEnv		>PULLW ZPQuickPtr2		NAME...
				>PULLW ZPQuickPtr3		...VALUE
				
K.SetEnvPtr2Ptr3
				jsr S.UnsetEnvPtr2

				jsr S.InitEnvPtr1		Y,A = ZPQuickPtr1 -> Env
				
				lda ZPQuickPtr1			Compute ENV UPPER LIMIT in Ptr4
				clc
				adc #K.ENV.SIZE
				sta ZPQuickPtr4
				
				lda ZPQuickPtr1+1
				adc /K.ENV.SIZE
				sta ZPQuickPtr4+1
				
				ldy ZPQuickPtr1+1
				lda ZPQuickPtr1			Compute New Env Upper limit in A,Y
				sec
				adc (ZPQuickPtr2)		add NAME len +1
				bcc .1
				iny
				
.1				sec						
				adc (ZPQuickPtr3)		add VALUE len +1
				bcc .2
				iny
				
.2				cmp ZPQuickPtr4			GE than hMem Upper limit ?
				tya
				sbc ZPQuickPtr4+1
				bcs .99
				
.3				lda (ZPQuickPtr1)		Scan until endig 0...
				beq .4
			
				inc	ZPQuickPtr1
				bne .3
				inc ZPQuickPtr1+1
				bne .3
				
.4				lda (ZPQuickPtr2)
				sta (ZPQuickPtr1)
				tay
				
.5				lda (ZPQuickPtr2),y
				sta (ZPQuickPtr1),y
				dey
				bne .5
				
				jsr S.NextEnvPtr1
				
				lda (ZPQuickPtr3)
				sta (ZPQuickPtr1)
				tay
				
.6				lda (ZPQuickPtr3),y
				sta (ZPQuickPtr1),y
				dey
				bne .6
				
				jsr S.NextEnvPtr1
				
.8				lda #0
				
				sta (ZPQuickPtr1)
				clc
				rts
				
.99				lda #SYSMGR.ERRENVF
				sec
				rts
*--------------------------------------
* K.GetEnvYA
*  In:
*  Y,A = PTR to NAME (PSTRING)
*  Out:
*  CC : Y,A = PTR to VALUE (PSTRING)
*  CS : not found
*--------------------------------------
K.GetEnvYA		>STYA ZPQuickPtr2
				jsr S.CheckSysVarPtr2
				bcc .9
				
				jsr S.FindVarPtr2
				bcs .9
				jsr S.NextEnvPtr1		Skip NAME
				>LDYA ZPQuickPtr1
.9				rts
*--------------------------------------
* K.UnsetEnvYA
*  In:
*  YA = PTR To Name (PSTRING)
*  Out:
*--------------------------------------
K.UnsetEnvYA	>STYA ZPQuickPtr2		Store VAR Name
S.UnsetEnvPtr2	jsr S.FindVarPtr2
				bcs .8					not found, quit

				jsr S.DiscardVarPtr1	Ptr1 -> ENVNAME
				
.8				clc				
				rts
*--------------------------------------
*               PRIVATE
*--------------------------------------
* S.CheckSysVarPtr2
*  In:
*	 ZPQuickPtr2 -> NAME
*  Out:
*   CC: Found
*	 YA -> VALUE
*	CS: Not Found
*--------------------------------------
S.CheckSysVarPtr2
				lda (ZPQuickPtr2)
				cmp #1					is name 1 char?
				bne .9
				
				ldy #1
				lda (ZPQuickPtr2),y
				cmp #'0'				$0...$9 ??
				bcc .1					no,
				cmp #'9'+1
				bcs .99
				and #$0F
				jmp K.GetArgA

.1				cmp #'*'				$* : All ARGS
				bne .9
				
				cmp #'#'				$# : ARGC
				bne .9
				
				cmp #'?'				$? : RC
				bne .9
				
				cmp #'$'				$$ : PID
				bne .9

.9				sec
.99				rts
*--------------------------------------
* S.FindVarPtr2
*  In:
*	 ZPQuickPtr2 -> NAME
*  Out:
*   CC: Found
*	 ZPQuickPtr1 -> ENV.NAME
*	 ZPQuickPtr2 -> NAME
*	CS: Not Found
*	 ZPQuickPtr1 -> PTR to Ending 0
*	 ZPQuickPtr2 -> NAME
*--------------------------------------
S.FindVarPtr2	jsr S.InitEnvPtr1		Store ENV
				bcs .99
				
				lda (ZPQuickPtr1)
				beq .9					end of ENV
				
.1				cmp (ZPQuickPtr2)		Same len as NAME?
				bne .3
				
				tay

.2				lda (ZPQuickPtr1),y
				cmp	(ZPQuickPtr2),y
				bne .3
				dey
				bne .2
				clc
				rts
				
.3				jsr S.NextEnvPtr1		Skip NAME
				jsr S.NextEnvPtr1		Skip VALUE
				lda (ZPQuickPtr1)
				bne .1
				
.9				sec
.99				rts		
*--------------------------------------
* S.DiscardVar	
*  In:
*	ZPQuickPtr1 -> ENV.NAME to Discard
*--------------------------------------
S.DiscardVarPtr1
				lda ZPQuickPtr1			Discard current NAME & VALUE definition
				sec						ZPQuickPtr1 -> NAME
				adc (ZPQuickPtr1)		add	NAME+1 to ZPQuickPtr1
				sta ZPQuickPtr4			store it in ZPQuickPtr4
				lda #0
				adc ZPQuickPtr1+1
				sta ZPQuickPtr4+1
				
				lda ZPQuickPtr4			add	VALUE+1 to ZPQuickPtr4
				sec 
				adc (ZPQuickPtr4)
				sta ZPQuickPtr4
				bcc .1
				inc ZPQuickPtr4+1
				 
.1				ldy #0

.2				lda (ZPQuickPtr4),y		Move back tail...
				sta (ZPQuickPtr1),y
				beq .8					...until we move ending 0
				iny
				bne .2
				inc ZPQuickPtr1+1
				inc ZPQuickPtr4+1
				bra .2
				
.8				rts
*--------------------------------------
S.InitEnvPtr1	ldy #S.PS.hENV
				lda (pPs),y
				jsr K.GetMemPtrA
				>STYA ZPQuickPtr1		Store ENV
				rts
*--------------------------------------
S.NextEnvPtr1	lda ZPQuickPtr1
				sec
				adc (ZPQuickPtr1)
				sta ZPQuickPtr1
				bcc .8
				inc ZPQuickPtr1+1
.8				rts		
*--------------------------------------
MAN
SAVE SYS/KERNEL.S.ENV
LOAD SYS/KERNEL.S
ASM
