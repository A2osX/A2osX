NEW
  AUTO 3,1
*--------------------------------------
IO.CLOSE.REG
IO.CLOSE.DIR	ldy #S.FD.REG.REF
				lda (pFD),y
				beq .1
				sta K.MLI.PARAMS+1
				>MLICALL MLICLOSE

.1				ldy #S.FD.REG.IOBUF
				lda (pFD),y
				beq .2
				
				jsr K.FreeMem
				
.2				lda IO.hFD
				jmp K.FreeMem
*--------------------------------------
IO.READ.REG		ldx #MLIREAD
				.HS 2C					BIT ABS
*--------------------------------------
IO.WRITE.REG	ldx #MLIWRITE

				ldy #S.FD.REG.REF
				lda (pFD),y
				sta K.MLI.PARAMS+1
				>PULLW K.MLI.PARAMS+2
				>PULLW K.MLI.PARAMS+4

				lda #4					Param Count = 4 for MLIREAD & MLIWRITE
				jsr GP.MLICall
				bcs .9
				>LDYA K.MLI.PARAMS+6
.9				rts
*--------------------------------------
IO.OPEN.CDEV
IO.OPEN.BDEV	jsr K.IOCTL.GetPDrv
				
				ldx #IOCTL.OPEN
				lda IO.hDev
				jsr K.IOCTL.pDrvJmp
				bcs .9
	
				lda IO.hDev

.9				rts				
*--------------------------------------
IO.CLOSE.CDEV
IO.CLOSE.BDEV
				clc
				rts
*--------------------------------------
IO.READ.CDEV	ldx #IOCTL.READ
				.HS 2C					BIT ABS
*--------------------------------------
IO.WRITE.CDEV	ldx #IOCTL.WRITE

				>PULLW K.S.IOCTL+S.IOCTL.BUFPTR
				>PULLW K.S.IOCTL+S.IOCTL.BYTECNT
				jsr K.IOCTL.GetPDRV
				
				>LDYAI K.S.IOCTL
				
				jsr K.IOCTL.pDrvJmp
				bcs .9
				>LDYA K.S.IOCTL+S.IOCTL.BYTECNT

.9				rts
*--------------------------------------
IO.OPEN.DSOCK
*--------------------------------------
IO.OPEN.SSOCK	lda IO.hFD
				clc
				rts
*--------------------------------------
IO.CLOSE.DSOCK
IO.CLOSE.SSOCK	
				ldy #S.FD.SSOCK.CLOSE
				lda (pFD),y
				tax						Function Offset in LIB

				ldy #S.FD.SSOCK.IOHANDLER
				lda (pFD),y
				jsr K.GetMemPtr
				>STYA .1+1
				
				lda	IO.hFD				

.1				jmp $FFFF				SELF MODIFIED
*--------------------------------------
IO.READ.SSOCK	ldy #S.FD.SSOCK.READ
				.HS 2C					BIT ABS
*--------------------------------------
IO.WRITE.SSOCK	ldy #S.FD.SSOCK.WRITE

				lda (pFD),y
				tax						Function Offset in LIB

				ldy #S.FD.SSOCK.IOHANDLER
				lda (pFD),y
				jsr K.GetMemPtr
				>STYA .1+1
				
				lda	IO.hFD				

.1				jmp $FFFF				SELF MODIFIED
*/--------------------------------------
* # IOCTL
* ## C
* `int ioctl(short int DevID, int request, void * param );`
* ## ASM
* `PUSHWI param`
* `PUSHBI request`
* `lda hDEV`
* `>SYSCALL IOCTL`
* ## RETURN VALUE
*  Y,A = ...
*\--------------------------------------
K.IOCTL			tax
				lda Dev.Table,x
				beq K.IOCTL.9

				ldy Dev.Table-1,x
				>STYA pFD
				
				jsr K.IOCTL.GetPDrv
				
				>PULLA
				tax						request
				
				>PULLYA					param

K.IOCTL.pDrvJmp	jmp (pDrv)
				
K.IOCTL.9		sec
				lda #MLI.E.NODEV
				>RET 3
*--------------------------------------
K.IOCTL.GetPDrv	ldy #S.FD.DEV.DRVPTR
				lda (pFD),y
				sta pDRV
				iny
				lda (pFD),y
				sta pDRV+1
				rts
*--------------------------------------				
IO.EOF.REG		>MLICALL MLIGETMARK
				bcs IO.EOF.REG.RTS
				
				ldy #2
				
.1				lda K.MLI.PARAMS+2,y
				sta ACC32,y
				dey
				bpl .1

				>MLICALL MLIGETEOF
				bcs IO.EOF.REG.RTS

				ldy #2
				
.2				lda K.MLI.PARAMS+2,y
				eor ACC32,y
				bne IO.EOF.FALSE
				dey
				bpl .2
				
				lda #$ff
*				clc
IO.EOF.REG.RTS	rts
*--------------------------------------
IO.EOF.CDEV		lda #S.IOCTL.STATCODE.EOF
				jmp K.GetDevStatus.I
*--------------------------------------
IO.EOF.SSOCK	ldy #S.FD.SSOCK.EOF

				lda (pFD),y
				tax						Function Offset in LIB

				ldy #S.FD.SSOCK.IOHANDLER
				lda (pFD),y
				jsr K.GetMemPtr
				>STYA .1+1
				
				lda	IO.hFD				

.1				jmp $FFFF				SELF MODIFIED
*--------------------------------------
IO.EOF.FALSE	lda #0
*				clc
				rts			
*--------------------------------------
* X = 0 > REG
* X = 1 > DIR
* X = 2 > PIPE
*--------------------------------------
IO.MkFD			stx .8+1
				
				ldy IO.MkFD.Y,x
				lda #0
				ldx #S.MEM.F.INIT0+S.MEM.F.FD
				jsr MEM.GetMem.YAX
				bcs .9
				
				>STYA pFD
				stx IO.hFD
				
.8				ldx #$ff				SELF MODIFIED
				lda IO.MkFD.T,x
				sta (pFD)				X = hFD, A = T
				
*				clc				
.9				rts

IO.MkFD.Y		.DA #S.FD.REG,#S.FD.DIR,#S.FD.PIPE
IO.MkFD.T		.DA #S.FD.T.REG,#S.FD.T.DIR,#S.FD.T.PIPE
*--------------------------------------
IO.MLI.CREATE	sta K.MLI.PARAMS+7		Storage Type
				
				ldx #3
				
.1				lda DATELO,x
				sta K.MLI.PARAMS+8,x	Create Date/Time
				dex
				bpl .1

				lda #S.FI.A.FULL
				sta K.MLI.PARAMS+3		Access
				
				>MLICALL MLICREATE
				rts
*--------------------------------------
IO.MLI.OPEN		>LDYAI 1024				get a ProDOS IOBUF
				ldx #S.MEM.F.ALIGN+S.MEM.F.NOMOVE
				jsr MEM.GetMem.YAX
				bcs .9

				>STYA K.MLI.PARAMS+3	Save Ptr to IOBUF for MLIOPEN call
				txa
				ldy #S.FD.REG.IOBUF
				sta (pFD),y

				>MLICALL MLIOPEN
				bcs .9
				
				lda K.MLI.PARAMS+5		get ref_num
				ldy #S.FD.REG.REF
				sta (pFD),y

				sta K.MLI.PARAMS+1		Next MLI Calls are REF_NUM based

*				clc				
.9				rts
*--------------------------------------
IO.CLOSE.NOD	ldx #2

				lda IO.hFD

.1				cmp Nod.Table.hFD-2,x
				bne .2
				
				stz Nod.Table.hFD-2,x
				
				lda Nod.Table.hPath-2,x
				stz Nod.Table.hPath-2,x
				jmp K.FreeMem
				
.2				inx
				cpx #K.Nod.MAX+2
				bne .1

				lda #E.INVH
*				sec				
				rts
*--------------------------------------
IO.DEV.FIFO		.AS "/DEV/FIFO"
*--------------------------------------
MAN
SAVE USR/SRC/SYS/KERNEL.S.IO
LOAD USR/SRC/SYS/KERNEL.S
ASM
