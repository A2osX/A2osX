NEW
PREFIX /A2OSX.BUILD
AUTO 4,1
*/--------------------------------------
* # open
* ## C
* `hFD open(const char *pathname, int flags);`
* ## ASM
* **In:**
* `>PUSHB flags`
* `>LDYA pathname`
* `>SYSCALL open`
* **Out:**
* A = hFD
* note : if file is created on ProDOS : T=TXT,X=$0000
*\--------------------------------------
K.Open			jsr PFT.CheckPathYA		check if not /mnt

K.Open.I		jsr STDIO.SetMLIPathYA	local pathname...
				>PULLB K.FOpen.MODE
				
				ldx #5					$/DEV/ 
				cpx K.MLI.PATH
				bcs K.Open.REG
				
.1				lda K.MLI.PATH,x
				cmp IO.DEVDIR,x
				bne K.Open.REG
				dex
				bne .1
*--------------------------------------		
K.Open.DEV		>LDYAI K.MLI.PATH+6		skip $/DEV/
	
				jsr K.GetDevByName
				bcs .9
				
				>STYA pFD
				stx .1+1				DEVID
				
				jsr K.IOCTL.GetPDrv
				
.1				lda #$ff				SELF MODIFIED pass A=DEVID To Driver
				ldx #IOCTL.OPEN
.2				jsr K.IOCTL.pDrvJmp
				bcs .9
				
				ldx .1+1
				lda Dev.Table.hFD,x
.9				rts				
*--------------------------------------
K.Open.REG		lda #S.FI.T.TXT
				sta K.FOpen.TYPE
				stz K.FOpen.AUXTYPE
				stz K.FOpen.AUXTYPE+1
				jmp K.FOpen.I
*/--------------------------------------
* # close
* ## C
* `int close(hFD fd);`
* ## ASM
* **In:**
* `lda fd`
* `>SYSCALL close`
*\--------------------------------------
K.Close			jsr K.GetMemPtr
				bcs .9
				
				>STYA pFD

				lda (pFD)				#S.FD.T
				tax
				jmp (.1,x)
				
.1				.DA IO.CLOSE.REG
				.DA IO.CLOSE.DIR
				.DA IO.CLOSE.CDEV
				.DA STDIO.IOERR			BDEV
				.DA STDIO.IOERR			LNK
				.DA IO.CLOSE.DSOCK
				.DA IO.CLOSE.SSOCK
				.DA IO.CLOSE.PIPE

.9				lda #MLI.E.NODEV
				sec
				rts
*--------------------------------------
IO.CLOSE.REG
IO.CLOSE.DIR
				ldy #S.FD.REG.REF
				lda (pFD),y
				beq .1
				sta K.MLI.PARAMS+1
				>MLICALL MLICLOSE

.1				ldy #S.FD.REG.IOBUF
				lda (pFD),y
				beq .8
				
				jmp K.FreeMem
				
.8				clc				
				rts
*--------------------------------------
IO.CLOSE.CDEV
*--------------------------------------
IO.CLOSE.DSOCK
IO.CLOSE.SSOCK
*--------------------------------------
IO.CLOSE.PIPE	clc
				rts
*/--------------------------------------
* # read
* ## C
* `int read(hFD fd, void *buf, int count);`
* ## ASM
* **In:**
* `>PUSHWI count`
* `>PUSHW buf`
* `lda fd`
* `>SYSCALL read`
* **Out:**
* CC: Y,A = bytes read
* CS: A = EC
*\--------------------------------------
K.Read			jsr K.GetMemPtr
				>STYA pFD
				
				>PULLW K.S.IOCTL+S.IOCTL.BUFPTR
				>PULLW K.S.IOCTL+S.IOCTL.BYTECNT				
				
IO.Read.I		lda (pFD)				#S.FD.T
				tax
				jmp (.1,x)
				
.1				.DA IO.READ.REG
				.DA STDIO.IOERR			DIR
				.DA IO.READ.CDEV
				.DA STDIO.IOERR			BDEV
				.DA STDIO.IOERR			LNK
				.DA STDIO.IOERR			DSOCK
				.DA IO.READ.SSOCK
				.DA IO.READ.PIPE
*/--------------------------------------
* # write
* ## C
* `int write(hFD fd, const void *buf, int count);`
* ## ASM
* **In:**
* `>PUSHWI count`
* `>PUSHW buf`
* `lda fd`
* `>SYSCALL write`
* **Out:**
* CC: Y,A = bytes written
* CS: A = EC
*\--------------------------------------
K.Write			jsr K.GetMemPtr
				>STYA pFD

IO.Write.I		lda (pFD)				#S.FD.T
				tax
				jmp (.1,x)
				
.1				.DA IO.WRITE.REG
				.DA STDIO.IOERR			DIR
				.DA IO.WRITE.CDEV
				.DA STDIO.IOERR			BDEV
				.DA STDIO.IOERR			LNK
				.DA STDIO.IOERR			DSOCK
				.DA IO.WRITE.SSOCK
				.DA IO.WRITE.PIPE
				
K.Write.9		lda #MLI.E.NODEV
				>RET 4				
*--------------------------------------
IO.READ.REG		ldx #MLIREAD
				.HS 2C					BIT ABS
*--------------------------------------
IO.WRITE.REG	ldx #MLIWRITE
				ldy #S.FD.REG.REF
				lda (pFD),y
				sta K.MLI.PARAMS+1
				>PULLW K.MLI.PARAMS+2
				>PULLW K.MLI.PARAMS+4

				lda #4					Param Count = 4 for MLIREAD & MLIWRITE
				jsr GP.MLICall
				>LDYA K.MLI.PARAMS+6
				rts
*--------------------------------------
IO.READ.CDEV	ldx #IOCTL.READ
				.HS 2C					BIT ABS
*--------------------------------------
IO.WRITE.CDEV	ldx #IOCTL.WRITE

				>PULLW K.S.IOCTL+S.IOCTL.BUFPTR
				>PULLW K.S.IOCTL+S.IOCTL.BYTECNT
				
				jsr K.IOCTL.GetPDRV
				
				>LDYAI K.S.IOCTL
				
.1				jsr K.IOCTL.pDrvJmp
				bcs .9
				>LDYA K.S.IOCTL+S.IOCTL.BYTECNT
.9				rts
*--------------------------------------
IO.WRITE.SSOCK	ldy #S.FD.SOCK.WRITE
				.HS 2C					BIT ABS
*--------------------------------------
IO.READ.SSOCK	ldy #S.FD.SOCK.READ
				lda (pFD),y
				tax						Function Offset in LIB

				ldy #S.FD.HANDLER
				lda (pFD),y
				jsr K.GetMemPtr
				>STYA .1
				
				ldy #S.FD.SOCK.HSKT
				lda (pFD),y
				
.1				jmp $ffff
*--------------------------------------
IO.READ.PIPE	>PULLW K.S.IOCTL+S.IOCTL.BUFPTR
				>PULLW K.S.IOCTL+S.IOCTL.BYTECNT

				ldy #S.FD.PIPE.S
				lda (pFD),y
				bit #S.FD.PIPE.S.WOpened
				beq .9					Remote PS did not opened yet the pipe
				bit #S.FD.PIPE.S.WClosed
				beq .99					Remote PS closed the Pipe
				
				ldy #S.FD.PIPE.hMem
				lda (pFD),y
				jsr K.GetMemPtr

				clc
				rts

.9				lda #MLI.E.VOLFULL
				sec
				rts
.99				lda #MLI.E.EOF
				sec
				rts					
*--------------------------------------
IO.WRITE.PIPE	>PULLW K.S.IOCTL+S.IOCTL.BUFPTR
				>PULLW K.S.IOCTL+S.IOCTL.BYTECNT

				ldy #S.FD.PIPE.S
				lda (pFD),y
				bit #S.FD.PIPE.S.ROpened
				beq .9					Remote PS did not opened yet the pipe
				bit #S.FD.PIPE.S.RClosed
				beq .99					Remote PS closed the Pipe
				
				ldy #S.FD.PIPE.hMem
				lda (pFD),y
				jsr K.GetMemPtr
				>STYA .1+2
				
				ldy #S.FD.PIPE.Head
				lda (pFD),y
				inc
				dey						#S.FD.PIPE.Tail	
				cmp (pFD),y
				beq .9					PIPE is full
				iny
				sta (pFD),y
				tay
				lda K.IOBuf
.1				sta $ffff,y
				clc
				rts
				
.9				lda #MLI.E.VOLFULL
				sec
				rts
.99				lda #MLI.E.EOF
				sec
				rts	
*/--------------------------------------
* # IOCTL
* ## C
* `int ioctl(short int hFD, int request, void * param );`
* ## ASM
* **In:** 
* `PUSHWI param`
* `PUSHBI request`
* `lda hFD`
* `>SYSCALL IOCTL`
* **Out:**
*  Y,A = ...
*\--------------------------------------
K.IOCTL			jsr K.GetMemPtr
				bcs .9
				
				>STYA pFD
				
				jsr K.IOCTL.GetPDrv
				
				>PULLA
				tax						request
				
				>PULLYA					param

				jmp (pDRV)				SELF MODIFIED x = op
				
.9				lda #MLI.E.NODEV
				>RET 3
*--------------------------------------
K.IOCTL.GetPDrv	ldy #S.FD.DEV.DRVPTR
				lda (pFD),y
				sta pDRV
				iny
				lda (pFD),y
				sta pDRV+1
				rts
K.IOCTL.pDrvJmp	jmp (pDrv)				
*/--------------------------------------
* # pipe
* ## C
* `int pipe(int pipefd[2]);`
* ## ASM
* **In:** 
*\--------------------------------------
K.Pipe
.9				sec
				rts				
*--------------------------------------
IO.DEVDIR		>PSTR "/DEV/"
*--------------------------------------
MAN
SAVE /A2OSX.SRC/SYS/KERNEL.S.IO
LOAD /A2OSX.SRC/SYS/KERNEL.S
ASM
