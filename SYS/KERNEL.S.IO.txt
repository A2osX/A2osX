NEW
PREFIX /A2OSX.BUILD
AUTO 4,1
*/--------------------------------------
* # open
* ## C
* `hFD open(const char *pathname, int flags);`
* ## ASM
* **In:**
* `>PUSHB flags`
* `>LDYA pathname`
* `>SYSCALL open`
* **Out:**
* A = hFD
* note : if file is created on ProDOS : T=TXT,X=$0000
*\--------------------------------------
K.Open			jsr PFT.CheckPathYA		check if not /mnt

K.Open.I		jsr IO.SetMLIPathYA		local pathname...

				ldx #5					$/DEV/ 
				cpx K.MLI.PATH
				bcs K.Open.REG
				
.1				lda K.MLI.PATH,x
				cmp IO.DEVDIR,x
				bne K.Open.REG
				dex
				bne .1
				
K.Open.DEV		>LDYAI K.MLI.PATH+6		skip $/DEV/
	
				jsr K.GetDevByName
				bcs .9
				
				>STYA pFD
				stx .1+1				DEVID
				
				ldy #S.FD.DEV.DRVPTR
				lda (pFD),y
				sta .2+1
				iny
				lda (pFD),y
				sta .2+2
				
				>PULLA					get flags
				
.1				lda #$ff				SELF MODIFIED pass A=DEVID To Driver
				ldx #IOCTL.OPEN
.2				jsr $ffff				SELF MODIFIED pDRV	
				bcs .99
				
				ldx .1+1
				lda Dev.Table.hFD,x
.99				rts				
				
.9				>RET 1					discard flags			
	
K.Open.REG		>LDYAI K.MLI.PATH
				>STYA K.MLI.PARAMS+1
				bra *
				lda (pStack)
*				sta K.S.IOCTL

				>RET 1
*/--------------------------------------
* # close
* ## C
* `int close(hFD fd);`
* ## ASM
* **In:**
* `lda fd`
* `>SYSCALL close`
*\--------------------------------------
K.Close			jsr K.GetMemPtr
				bcs .9
				
				>STYA pFD

				lda (pFD)				#S.FD.T
				tax
				jmp (.1,x)
				
.1				.DA IO.CLOSE.REG
				.DA STDIO.IOERR			DIR
				.DA IO.CLOSE.CDEV
				.DA STDIO.IOERR			BDEV
				.DA STDIO.IOERR			LNK
				.DA STDIO.IOERR			DSOCK
				.DA IO.CLOSE.SSOCK
				.DA IO.CLOSE.FIFO

.9				lda #MLI.E.NODEV
				sec
				rts
*--------------------------------------
IO.CLOSE.REG
*--------------------------------------
IO.CLOSE.CDEV
*--------------------------------------
IO.CLOSE.SSOCK
*--------------------------------------
IO.CLOSE.FIFO	clc
				rts
*/--------------------------------------
* # read
* ## C
* `int read(hFD fd, void *buf, int count);`
* ## ASM
* **In:**
* `>PUSHWI count`
* `>PUSHW buf`
* `lda fd`
* `>SYSCALL read`
* **Out:**
* CC: Y,A = bytes read
* CS: A = EC
*\--------------------------------------
K.Read			jsr K.GetMemPtr
				bcs K.Write.9

				>STYA pFD
				
				>PULLW K.S.IOCTL+S.IOCTL.BUFPTR
				>PULLW K.S.IOCTL+S.IOCTL.BYTECNT				
				
IO.Read.I		lda (pFD)				#S.FD.T
				tax
				jmp (.1,x)
				
.1				.DA IO.READ.REG
				.DA STDIO.IOERR			DIR
				.DA IO.READ.CDEV
				.DA STDIO.IOERR			BDEV
				.DA STDIO.IOERR			LNK
				.DA STDIO.IOERR			DSOCK
				.DA IO.READ.SSOCK
				.DA IO.READ.FIFO
*/--------------------------------------
* # write
* ## C
* `int write(hFD fd, const void *buf, int count);`
* ## ASM
* **In:**
* `>PUSHWI count`
* `>PUSHW buf`
* `lda fd`
* `>SYSCALL write`
* **Out:**
* CC: Y,A = bytes written
* CS: A = EC
*\--------------------------------------
K.Write			jsr K.GetMemPtr
				bcs K.Write.9
				
				>STYA pFD

				>PULLW K.S.IOCTL+S.IOCTL.BUFPTR
				>PULLW K.S.IOCTL+S.IOCTL.BYTECNT
				
IO.Write.I		lda (pFD)				#S.FD.T
				tax
				jmp (.1,x)
				
.1				.DA IO.WRITE.REG
				.DA STDIO.IOERR			DIR
				.DA IO.WRITE.CDEV
				.DA STDIO.IOERR			BDEV
				.DA STDIO.IOERR			LNK
				.DA STDIO.IOERR			DSOCK
				.DA IO.WRITE.SSOCK
				.DA IO.WRITE.FIFO
				
K.Write.9		lda #MLI.E.NODEV
				>RET 4				
*--------------------------------------
IO.READ.REG		ldx #MLIREAD
				.HS 2C					BIT ABS
*--------------------------------------
IO.WRITE.REG	ldx #MLIWRITE
				ldy #S.FD.REG.REF
				lda (pFD),y
				sta K.MLI.PARAMS+1
				>LDYA K.S.IOCTL+S.IOCTL.BUFPTR
				>STYA K.MLI.PARAMS+2
				>LDYA K.S.IOCTL+S.IOCTL.BYTECNT
				>STYA K.MLI.PARAMS+4

				lda #4					Param Count = 4 for MLIREAD & MLIWRITE
				jsr GP.MLICall
				rts
*--------------------------------------
IO.READ.CDEV	ldx #IOCTL.READ
				.HS 2C					BIT ABS
*--------------------------------------
IO.WRITE.CDEV	ldx #IOCTL.WRITE

				ldy #S.FD.DEV.DRVPTR
				lda (pFD),y
				sta .1+1
				iny
				lda (pFD),y
				sta .1+2
				
				>LDYAI K.S.IOCTL
				
.1				jsr $ffff
				bcs .9
				>LDYA K.S.IOCTL+S.IOCTL.BYTECNT
.9				rts
*--------------------------------------
IO.WRITE.SSOCK	ldy #S.FD.SSOCK.WRITE
				.HS 2C					BIT ABS
*--------------------------------------
IO.READ.SSOCK	ldy #S.FD.SSOCK.READ
				lda (pFD),y
				tax						Function Offset in LIB

				ldy #S.FD.HANDLER
				lda (pFD),y
				jsr K.GetMemPtr
				>STYA .1
				
				ldy #S.FD.SSOCK.HSKT
				>PUSHB (pFD),y
				>PUSHB K.IOBuf
				
.1				jmp $ffff
*--------------------------------------
IO.READ.FIFO

				clc
				rts
*--------------------------------------
IO.WRITE.FIFO	ldy #S.FD.FIFO.S
				lda (pFD),y
				beq .9					Remote PS did not opened yet the pipe
				cmp #S.FD.FIFO.S.Closed
				beq .99					Remote PS closed the Pipe
				
				ldy #S.FD.FIFO.hMem
				lda (pFD),y
				jsr K.GetMemPtr
				>STYA .1+2
				
				ldy #S.FD.FIFO.Head
				lda (pFD),y
				inc
				dey						#S.FD.FIFO.Tail	
				cmp (pFD),y
				beq .9					FIFO is full
				iny
				sta (pFD),y
				tay
				lda K.IOBuf
.1				sta $ffff,y
				clc
				rts
				
.9				lda #MLI.E.VOLFULL
				.HS 2C					bit abs			
.99				lda #MLI.E.EOF
				sec
				rts	
*/--------------------------------------
* # IOCTL
* ## C
* `int ioctl(short int hFD, int request, void * param );`
* ## ASM
* **In:** 
* `PUSHWI param`
* `PUSHBI request`
* `lda hFD`
* `>SYSCALL IOCTL`
* **Out:**
*  Y,A = ...
*\--------------------------------------
K.IOCTL			jsr K.GetMemPtr
				bcs .9
				
				>STYA pFD
				
				ldy #S.FD.DEV.DRVPTR
				lda (pFD),y
				sta .8+1
				iny
				lda (pFD),y
				sta .8+2

				>PULLA
				tax						request
				
				>PULLYA					param

.8				jmp $ffff				SELF MODIFIED x = op
				
.9				lda #MLI.E.NODEV
				>RET 3
*/--------------------------------------
* # pipe
* ## C
* `int pipe(int pipefd[2]);`
* ## ASM
* **In:** 
*\--------------------------------------
K.Pipe
.9				sec
				rts				
*--------------------------------------
IO.PullMLIPath	>PULLYA
IO.SetMLIPathYA	>STYA .1+1
				
				ldx #0
				
.1				lda $ffff,x				Self Modified
				beq .8
				inx
				sta K.MLI.PATH,x
				cpx #MLI.MAXPATH
				bne .1
				
.8				stx K.MLI.PATH
				inx
				stz K.MLI.PATH,x
				
				rts
*--------------------------------------
IO.DEVDIR		>PSTR "/DEV/"
*--------------------------------------
MAN
SAVE /A2OSX.SRC/SYS/KERNEL.S.IO
LOAD /A2OSX.SRC/SYS/KERNEL.S
ASM
