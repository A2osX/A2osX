PR#3
PREFIX /A2OSX.SRC
NEW
INC 1
AUTO 6
				.LIST OFF
*--------------------------------------
* K.PrintFYA :
* Prints C-Style String
* Y,A = PTR to Sting,Last Byte negative 
* %a pull 2 bytes to Print Access right String drwxrwxrwx
* %b pull 1 byte to Print BIN 
* %B pull 2 bytes to Print BIN
* %d pull 1 byte unsigned DEC 0..255
* %D pull 2 bytes unsigned DEC 0..65535
* %u pull 2 bytes PTR to 4 bytes long unsigned DEC 0..4294967295
* %e pull 2 bytes PTR to 6 Bytes Real +1.23456789e+12
* %f pull 2 bytes PTR to 6 Bytes Real 3.1415
* %h pull 1 byte to Print HEX
* %H pull 2 bytes to Print HEX
* %i pull 1 byte to Print signed DEC -128..127
* %I pull 2 bytes to Print signed DEC -32768..32767
* %L pull 2 bytes PTR to 4 bytes signed DEC -2147483648..2147483647
* %n pull 1 byte to Print low Nibble HEX
* %N pull 1 byte to Print high Nibble HEX
* %s pull 2 bytes ptr to C-Style String
* %S pull 2 bytes ptr to P-Style String
* \e Print 'ESC' ($1B,27)
* \n Print CR=13
* \\ Print \
* \% Print %
* len/padding : 
*   %d	   '9'  '12'
*   %2d	   ' 9' '12'   				
*	%02d   '09' '12'
*	%11s   'ABCDEFGH   '	
*	%011s  'ABCDEFGH000'
*   %2f		'3.14'
*--------------------------------------
K.PrintFYA		>STYA ZPQuickPtr1

				ldy	#0
				
.1				lda (ZPQuickPtr1),y
				beq .99 
				cmp #'%'
				bne .10
						
				stz PADLEN
				lda #' '
				sta PADCHAR
				
.2				ldx	#PrintFTBL1.END-PrintFTBL1-1
				iny
				lda	(ZPQuickPtr1),y
				beq .99
				
.3				cmp PrintFTBL1,x		do we have a %x command?
				beq .8					yes, jmp to it!
				dex
				bpl	.3					no valid letter...
				
				cmp #'0'				...a 0...mmm... padding char?
				bne .4
				
				ldx PADLEN				PADLEN is not nul, so this 0 is second digit
				bne .5
				
				lda #'0'
				sta PADCHAR				no, this is the first 0, so make it PADCHAR
				bra .2

.4				bcc .99					less than '0'....error				
				cmp #'9'+1
				bcs .99					more than '9' ....error			
				
.5				and #$0F				we have a digit
				pha						save it...
				lda PADLEN				starts PADLEN * 10
				asl 
				asl 					A=times 4
				adc PADLEN				CC by ASL, A=times 5			
				asl						times 10
				sta PADLEN

				pla						get back digit
				adc PADLEN
				sta PADLEN
				bra .2					go get next char...

.8				phy
				txa
				asl
				tax
				jsr PrintFESC
				ply
				iny
				bne .1
				rts

.10				cmp #'\'
				bne .20
				
				ldx	#PrintFTBL2.END-PrintFTBL2-1
				iny
				lda	(ZPQuickPtr1),y
				beq .99
.12				cmp PrintFTBL2,x
				beq .13
				dex
				bpl	.12
				bra .80
				
.13				lda	PrintFTBL2.OUT,x	

.20				jsr	K.COutA
.80				iny
				bne	.1
.99				rts
*--------------------------------------
PrintFESC		jmp	(PrintFJMP,x)
*--------------------------------------
PrintFTBL1		.AS	"abBdDuefhHiILnNsS"
PrintFTBL1.END
PrintFTBL2		.AS	"en\%"
PrintFTBL2.END
PrintFTBL2.OUT	.HS 1B.0D				\e\n
				.DA #'\'				\\
				.DA #'%'				\%
PrintFJMP		.DA PrintF.A
				.DA PrintF.B,PrintF.BB
				.DA PrintF.D,PrintF.DD,PrintF.U
				.DA PrintF.E,PrintF.F
				.DA PrintF.H,PrintF.HH
				.DA PrintF.I,PrintF.II,PrintF.L
				.DA PrintF.N,PrintF.NN
				.DA PrintF.S,PrintF.SS
*--------------------------------------
PrintF.A		>PULLW HEXBUF
				rts
*--------------------------------------
PrintF.BB		>PULLYA
				phy
				jsr PrintF.B
				pla
				bra PrintF.B.1
*--------------------------------------
PrintF.B		>PULLA
				
PrintF.B.1		ldx #8
				
.1				asl
				pha
				lda #'0'
				adc #0					add Carry
				jsr K.COutA
				pla
				dex
				bne .1
				rts
*--------------------------------------
PrintF.D		>PULLB HEXBUF
				stz HEXBUF+1
				bra PrintF.DD.1
				
PrintF.DD		>PULLW HEXBUF
PrintF.DD.1		stz HEXBUF+2
				stz HEXBUF+3
				bra PrintF.U.1
				
PrintF.U		>PULLW ZPQuickPtr2
				ldy #3
				
.1				lda (ZPQuickPtr2),y
				sta HEXBUF,y
				dey
				bpl .1

PrintF.U.1		stz SIGN
				jsr HEX2DEC
				jmp PrintDEC
*--------------------------------------				
PrintF.E		>PULLW ZPQuickPtr2
				rts
*--------------------------------------
PrintF.F		>PULLW ZPQuickPtr2
				rts
*--------------------------------------
PrintF.HH		>PULLYA
K.HexOutYA
				phy
				jsr PrintF.H.1
				pla
				bra PrintF.H.1
*--------------------------------------
PrintF.H		>PULLA
K.HexOutA
PrintF.H.1		pha
				jsr PrintF.NN.1
				pla
				jmp PrintF.N.1
*--------------------------------------
PrintF.I		>PULLB HEXBUF
				eor #$ff				if positive, it becomes neg so branch if....minus!
				clc
				bmi .1
				sec
				inc						2s complement...
				sta HEXBUF

				
.1				stz HEXBUF+1
				bra PrintF.II.1
				
PrintF.II		>PULLW HEXBUF			A=HI
				eor #$ff
				clc
				bmi PrintF.II.1
				sec
				tax
				lda HEXBUF
				eor #$ff
				inc						2s complement...
				sta HEXBUF
				bne .1
				inx
.1				sta HEXBUF
				stx HEXBUF+1

PrintF.II.1		stz HEXBUF+2
				stz HEXBUF+3
				bra PrintF.L.1
				
PrintF.L		>PULLW ZPQuickPtr2
				ldy #3
				
.1				lda (ZPQuickPtr2),y
				sta HEXBUF,y
				dey
				bpl .1

				
PrintF.L.1		ror SIGN
				jsr HEX2DEC
				jmp PrintDEC
*--------------------------------------
PrintF.N		>PULLA
PrintF.N.1		and #$0F
				bra PrintF.NN.2

PrintF.NN		>PULLA
PrintF.NN.1		lsr
				lsr
				lsr
				lsr
				
PrintF.NN.2		ora #$30
				cmp #$3A
				bcc .1
				adc #6
.1				jmp K.COutA
*--------------------------------------
* CStr 
*--------------------------------------
PrintF.S		>PULLW ZPQuickPtr2

				ldy	#0
				
.1				lda	(ZPQuickPtr2),y
				beq .2
		
				jsr K.COutA
				iny
				lda PADLEN
				
				beq .1
				cpy	PADLEN
				bne .1
				rts
				
.2				lda PADLEN
				beq .8
				
.3				lda PADCHAR				
				jsr K.COutA
				iny
				cpy PADLEN
				bne .3
				
.8				rts
*--------------------------------------
* PStr 
*--------------------------------------
PrintF.SS		>PULLW ZPQuickPtr2
				
				ldy	#0
				lda	(ZPQuickPtr2),y
				tax
				beq .8
				
.1				iny
				lda	(ZPQuickPtr2),y
				jsr K.COutA
				lda PADLEN
				
				beq .2
				cpy	PADLEN
				beq .8
				
.2				dex
				bne .1
				
				lda PADLEN
				beq .8
				
.3				lda PADCHAR				
				jsr K.COutA
				iny
				cpy PADLEN
				bne .3
				
.8				rts
*--------------------------------------
K.COutA			phx
				phy
				cmp #13
				bne .1
				ldx #DEVMGR.COUT
				jsr pDevJmp
				bcs .2
				lda #10
.1				ldx #DEVMGR.COUT
				jsr pDevJmp
.2				ply
				plx
				rts
*--------------------------------------
* Convert HEXBUF to ASCBUF decimal padded with 0
*--------------------------------------
HEX2DEC			ldx #4

.1				stz BCDBUF,x	Clear all 5 bytes
				dex
				bpl .1
				
				sed				switch to BCD mode

				ldx #32			let's roll 32 bits
				
.2				asl HEXBUF
				rol	HEXBUF+1
				rol HEXBUF+2
				rol HEXBUF+3

				ldy #4
				
.3				lda BCDBUF,y
				adc BCDBUF,y
				sta BCDBUF,y
				dey
				bpl .3
				
				dex
				bne .2
				
				cld
				
				ldy #4
				ldx #9
				
.4				lda BCDBUF,y
				pha
				and #$0F
				ora #$30
				sta	ASCBUF,x
				dex
				pla
				lsr
				lsr
				lsr
				lsr
				ora #$30
				sta	ASCBUF,x
				dey
				dex
				bpl .4
				
				rts
*--------------------------------------
PRINTDEC		lda PADLEN			any Len format ?
				beq .1				no
				
				lda #10
				sec					yes, Print only digits starting at pos 10-padlen
				sbc PADLEN
				
.1				tax					x=0 if no padlen, or x=10-padlen

.2				lda ASCBUF,x		
				cmp #'0'			a zero?
				beq .3
				
				inc PADLEN			found a non zero, Print all digits, even if 0, next time
				ldy #'0'
				sty PADCHAR
				bra .4
				
.3				cpx #9				last digit ?
				beq .4				Print always
				
				ldy PADLEN			no pad to fill, do not Print 0
				beq .9
				
				lda PADCHAR			fill with PADCHAR
				
.4				bit SIGN			a sign to print before digits ?
				bpl .5
				pha					yes, save whatever we have to print....
				lda #'-'
				jsr K.COutA
				stz SIGN			reset flag for next char...
				pla
				
.5				jsr K.COutA

.9				inx
				cpx #10
				bne .2
				
				rts
*--------------------------------------
* Convert ASCBUF decimal to HEXBUF
*--------------------------------------
DEC2HEX			stz HEXBUF
				stz HEXBUF+1
				stz HEXBUF+2
				stz HEXBUF+3
				
				ldx #0
				
.1				lda HEXBUF+3			save HEXBUF for 4+1
				pha
				lda HEXBUF+2
				pha
				lda HEXBUF+1
				pha
				lda HEXBUF
				pha

				asl HEXBUF				HEXBUF * 2 -> HEXBUF
				rol HEXBUF+1
				rol HEXBUF+2
				rol HEXBUF+3
				bcs .9					overflow!!!
				
				asl HEXBUF				HEXBUF * 4 -> HEXBUF
				rol HEXBUF+1
				rol HEXBUF+2
				rol HEXBUF+3
				bcs .9					overflow!!!

				pla				HEXBUF * 4 + HEXBUF -> HEXBUF
				adc HEXBUF
				sta HEXBUF
				pla
				adc HEXBUF+1
				sta HEXBUF+1
				pla
				adc HEXBUF+2
				sta HEXBUF+2
				pla
				adc HEXBUF+3
				sta HEXBUF+3
				bcs .99					overflow!!!

				asl HEXBUF				HEXBUF * 10 -> HEXBUF
				rol HEXBUF+1
				rol HEXBUF+2
				rol HEXBUF+3
				bcs .99					overflow!!!

				inx
				lda ASCBUF,x
				and #$0F

				adc HEXBUF
				sta HEXBUF
				bcc .2
				inc HEXBUF+1
				bne .2
				inc HEXBUF+2
				bne .2
				inc HEXBUF+3
				
.2				cpx ASCBUF
				bne .1
				rts
				
.9				pla					discard saved HEXBUF
				pla
				pla
				pla
.99				rts
*--------------------------------------
ACCESS			.AS "drwxrwxrwx"
HEXBUF			.BS 4					32 bits max
BCDBUF			.BS 5					5, enough to handle 10 digits (32bits)
ASCBUF			.BS 12					LEN + sign + 10 digits ($FFFFFFFF=4.294.967.295)
SIGN			.BS 1
PADLEN			.BS 1
PADCHAR			.BS 1
*--------------------------------------
*    SUPERSEEDED by K.PrintFYA
*--------------------------------------
* Mini printf for PSTR
*  %d : byte
*  %D : word
*  %h : hex byte
*  %H : hex word
*  %s : hSTR
*  %S : PSTR
*  \e : ESC
*  \n : CR
*--------------------------------------
K.PStrOutYA		>STYA ZPQuickPtr1
			
				ldy #0
				
.1				jsr K.PStrOut.Next
				bne .12
.8				clc
				rts
				
.12				cmp #'\'
				bne .2
				jsr K.PStrOut.Next
				beq .8

				cmp #'e'
				bne .11
				lda #27
				bra .6

.11				cmp #'n'
				bne .6
				lda #13
				bra .6

.2				cmp #'%'
				bne .6
	
				jsr K.PStrOut.Next
				beq .8
				cmp #'d'
				bne .3
				phy
				>PULLA
				jsr K.DecOutA
				ply
				bcc .1
				rts
				
.3				cmp #'D'
				bne .4
				phy
				>PULLYA
				jsr K.DecOutYA
				ply
				bcc .1
				rts
				
.4				cmp #'h'
				bne .5
				phy
				>PULLA
				jsr K.HexOutA
				ply
				bcc .1
				rts
				
.5				cmp #'H'
				bne .51
				phy
				>PULLYA
				jsr K.HexOutYA
				ply
				bcc .1
				rts
				
.51				cmp #'s'
				bne .52
				jsr K.PStrOutYAS1
				bcc .1
				rts
				
.52				cmp #'S'
				bne .53
				jsr K.PStrOutYAS2
				bcc .10
				rts
				
.53				tax
				lda #'%'
				jsr K.COutA
				bcs .9
				txa
				
.6				jsr K.COutA
				bcs .9
.10				jmp .1
.9				rts
*--------------------------------------
K.PStrOut.Next	tya
				eor (ZPQuickPtr1)
				beq .8
				iny
				lda (ZPQuickPtr1),y
.8				rts				
*--------------------------------------
K.PStrOutYAS1	phy
				>PULLA
				jsr K.GetMemPtrA
				bra K.PStrOutYAS
				
K.PStrOutYAS2	phy
				>PULLYA
K.PStrOutYAS	>STYA ZPQuickPtr2

				clc
				lda (ZPQuickPtr2)
				tax
				beq .9
				
				ldy #1
.1				lda (ZPQuickPtr2),y
				jsr K.COutA
				bcs .9
				iny
				dex
				bne .1 

.9				ply
				rts
*--------------------------------------
K.DecOutA		tay
				lda #0
K.DecOutYA		>STYA HEX
				stz BCD
				stz BCD+1
				stz BCD+2
				
				ldx #16			let's roll 16 bits
				sed
.2				asl HEX
				rol	HEX+1
				php				cpy will disturb carry while BCD adc
				ldy #0
.3				plp
				lda BCD,y
				adc BCD,y
				sta BCD,y
				php
				iny
				cpy #3			Last byte of BCDBUF?
				bne .3
				plp
				dex
				bne .2
				
				cld
				
				stz bL0Flag
				ldx #2
				
.4				lda BCD,x
				lsr
				lsr
				lsr
				lsr
				bne .5
				bit bL0Flag
				bpl .6
.5				sec
				ror bL0Flag
				ora #$30
				jsr K.COutA
				bcs .9
				
.6				lda BCD,x
				and #$0F
				bne .7
				bit bL0Flag
				bpl .8
.7				sec
				ror bL0Flag
				ora #$30
				jsr K.COutA
				bcs .9
				
.8				dex
				bpl .4
				
				bit bL0Flag
				bmi .9
				lda #$30
				jsr K.COutA
				
.9				rts
*--------------------------------------
HEX				.BS 2
BCD				.BS 3
bL0Flag			.BS 1
*--------------------------------------
MAN
SAVE SYS/KERNEL.S.CIO
LOAD SYS/KERNEL.S
ASM
