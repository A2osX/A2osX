PR#3
PREFIX /A2OSX.SRC
NEW
INC 1
AUTO 6
				.LIST OFF
*--------------------------------------
* S.InsBin
*--------------------------------------
S.InsBin		>LDYA S.LoadBin.NewBase
				>STYA ZPQuickPtr1
				
				ldy #H.BIN.CODE.LEN		make AX = Code Len
				lda (ZPQuickPtr1),y
				sta Rel.CodeLen
				iny
				lda (ZPQuickPtr1),y
				sta Rel.CodeLen+1
			
				lda S.LoadBin.OldBase
				sta Rel.Start				Make BX=Range Start=AUXTYPE
				clc
				adc S.LoadBin.SegLen
				sta Rel.End				Make CX=Range End=AUXTYPE+FILELEN

				lda S.LoadBin.OldBase+1
				sta Rel.Start+1
				adc S.LoadBin.SegLen+1
				sta Rel.End+1
				
				lda ZPQuickPtr1			Compute relocation offset in DX
				sec
				sbc S.LoadBin.OldBase
				sta Rel.Offset				DX=Offset=ZPQuickPtr1-AUXTYPE	
				lda ZPQuickPtr1+1
				sbc S.LoadBin.OldBase+1
				sta Rel.Offset+1
				
				jmp S.BinRelocate
*--------------------------------------
* S.InsDrv
* pDrv = .DRV File Loaded Address
*--------------------------------------
S.InsDrv		ldy #H.BIN.DRV.CODE.LEN
				lda (pDrv),y
				sta Rel.CodeLen
				iny
				lda (pDrv),y
				sta Rel.CodeLen+1
				
				ldy #H.BIN.DRV.CODE.O
				lda (pDrv),y
				clc
				adc S.LoadBin.OldBase
				sta Rel.Start
				iny
				lda (pDrv),y
				adc S.LoadBin.OldBase+1
				sta Rel.Start+1				set BX=End Of Code
				
				lda S.LoadBin.OldBase
				clc
				adc S.LoadBin.SegLen
				sta Rel.End
				lda S.LoadBin.OldBase+1
				adc S.LoadBin.SegLen+1
				sta Rel.End+1				set CX=End Of Range
				
				ldy #H.BIN.DRV.CODE.O
				lda	S.LoadBin.SegLen
				sec
				sbc (pDrv),y
				sta S.InsDrv.DRVLen
				iny
				lda	S.LoadBin.SegLen+1
				sbc (pDrv),y
				sta S.InsDrv.DRVLen+1	Compute DRV Len
				
				lda DevMgr.Free
				clc
				adc S.InsDrv.DRVLen
				sta S.InsDrv.DRVEnd
				lda DevMgr.Free+1
				adc S.InsDrv.DRVLen+1
				sta S.InsDrv.DRVEnd+1

				bcs .98					we crossed $FFFF, out of mem
				
				lda S.InsDrv.DRVEnd
				sec
				sbc #DevMgr.HiMem
				lda S.InsDrv.DRVEnd+1
				sbc /DevMgr.HiMem
				bcs .98					No More Room to load Driver....

				lda DevMgr.LastDevID
				inc
				cmp #K.DEV.MAX
				beq .99					No Device Handle Left
				
				sta DevMgr.LastDevID
				
				ldy	#H.BIN.DEV.HEADER.O
				lda (pDrv),y
				clc
				adc pDrv
				sta ZPQuickPtr1
				iny
				lda (pDrv),y
				adc pDrv+1
				sta ZPQuickPtr1+1

				ldy #S.DEV.JMP
				
				lda DevMgr.Free
				sec
				sbc (ZPQuickPtr1),y
				sta Rel.Offset
				lda DevMgr.Free+1
				iny
				sbc (ZPQuickPtr1),y
				sta Rel.Offset+1				set DX=Offset

				ldy #H.BIN.DRV.CODE.O
				lda (pDrv),y
				clc
				adc pDrv
				sta ZPQuickPtr1
				
				iny
				lda (pDrv),y
				adc pDrv+1
				sta ZPQuickPtr1+1
				
				jsr S.DrvRelocate
				
				jsr S.InsDrv.Move
				
				>LDYA S.InsDrv.DrvEnd
				>STYA DevMgr.Free
				clc
				rts
				
.98				lda #DEVMGR.ERROOM
				sec
				rts
				
.99				lda #DEVMGR.ERROOH
				sec
				rts
*--------------------------------------
S.InsDrv.Move	ldy	#H.BIN.DEV.HEADER.O
				lda (pDrv),y
				clc
				adc pDrv
				sta ZPQuickPtr1
				iny
				lda (pDrv),y
				adc pDrv+1
				sta ZPQuickPtr1+1

				ldy #S.DEV.JMP			Relocate Main JMP
				lda (ZPQuickPtr1),y
				clc
				adc Rel.Offset
				sta (ZPQuickPtr1),y
				iny
				lda (ZPQuickPtr1),y
				adc Rel.Offset+1
				sta (ZPQuickPtr1),y
				
				lda DevMgr.LastDevID
				jsr S.GetDevByIDA
				>STYA pDev
				
				ldy #S.DEV.SIZE			Make sure DevMgr.Table Ends with 0
				lda #0
				sta (pDev),y
				dey
				
.1				lda (ZPQuickPtr1),y		Copy DRV.Header
				sta (pDev),y
				dey
				bpl .1
				
				lda DevMgr.LastDevID	Save Dev.ID in the driver for SELECT
				ldy #S.DEV.ID
				sta (pDev),y
				
				ldy #H.BIN.DRV.CODE.O
				lda (pDrv),y
				clc
				adc pDrv
				sta ZPQuickPtr1
				iny 
				lda (pDrv),y
				adc pDrv+1
				sta ZPQuickPtr1+1		Make ZPQuickPtr1=DRV.CODE
				
				lda DevMgr.Free
				sta ZPQuickPtr2
				lda DevMgr.Free+1
				sta ZPQuickPtr2+1		Make ZPQuickPtr2=Dest Ram Location
				
				ldy S.InsDrv.DrvLen
				ldx S.InsDrv.DrvLen+1
				
.2				lda (ZPQuickPtr1)
				sta (ZPQuickPtr2)
				
				inc ZPQuickPtr1
				bne .3
				inc ZPQuickPtr1+1
				
.3				inc ZPQuickPtr2
				bne .4
				inc ZPQuickPtr2+1
				
.4				tya
				bne .5
				txa
				beq .8
				dex
				
.5				dey
				bra .2		
.8				rts
*--------------------------------------
S.InsDrv.DrvLen	.BS 2
S.InsDrv.DrvEnd	.BS 2
*--------------------------------------
* S.BinRelocate :
* ZPQuickPtr1 = Ptr to Code
* R.AX = Code Length
* R.BX = Range Start address to relocate
* R.CX = Range End  address to relocate
* R.DX = offset to apply to all abs addresses between R.BX and R.CX
*--------------------------------------
S.BinRelocate	ldy #H.BIN.JMP			relocate Main JMP
				lda (ZPQuickPtr1),y
				clc
				adc Rel.Offset
				sta (ZPQuickPtr1),y

				iny
				lda (ZPQuickPtr1),y
				adc Rel.Offset+1
				sta (ZPQuickPtr1),y

				ldy #H.BIN.RELOC.TABLE	skip Header, CS.SIZE & DS.SIZE... (16 bytes)
				
				.HS 2C					bit abs
				
S.DrvRelocate	ldy #0
				
.1				lda (ZPQuickPtr1),y		Start Relocate JMP table
				tax
				iny
				ora (ZPQuickPtr1),y
				beq .2					$0000 = end of table
				
				dey
				txa
				clc
				adc Rel.Offset
				sta (ZPQuickPtr1),y

				iny
				lda (ZPQuickPtr1),y
				adc Rel.Offset+1
				sta (ZPQuickPtr1),y

				iny

				bra .1
				
.2				lda ZPQuickPtr1
				clc
				adc Rel.CodeLen				Make ZPQuickPtr2=End of code
				sta ZPQuickPtr2			=ZPQuickPtr1+AX (code len)
				lda ZPQuickPtr1+1
				adc Rel.CodeLen+1
				sta ZPQuickPtr2+1
	
				iny
				tya						add current offset in Y to Ptr
				clc
				adc ZPQuickPtr1
				sta ZPQuickPtr1
				bcc .5	
				inc ZPQuickPtr1+1		ZPQuickPtr1=Current Code PTR
				clc
				
.5				lda (ZPQuickPtr1)		get OPCODE
				tax
				lda OPCODES,x			get OPCODE definition
				bpl .7					abs addressing?
				
				and #3					save Opcode length...
				pha
				
				ldy #1
				lda (ZPQuickPtr1),y		Get LO
				sec
				sbc Rel.Start
				iny
				lda (ZPQuickPtr1),y		Get HI
				sbc Rel.Start+1
				bcc .6					addr < AX, out of range
				
				dey
				lda (ZPQuickPtr1),y		Get LO
				sec
				sbc Rel.End
				iny
				lda (ZPQuickPtr1),y		Get HI
				sbc Rel.End+1
				bcs .6					addr > CX, out of range
				
				dey
				lda (ZPQuickPtr1),y		Get LO
				clc
				adc Rel.Offset				add DX to abs address
				sta (ZPQuickPtr1),y		store relocated addr LO
				iny
				lda (ZPQuickPtr1),y		Get HI
				adc Rel.Offset+1
				sta (ZPQuickPtr1),y		store relocated addr HI
				
.6				pla

.7				clc						A = OPCODE length
				adc ZPQuickPtr1
				sta ZPQuickPtr1
				bcc .8
				inc ZPQuickPtr1+1
				
.8				lda ZPQuickPtr1			is Current PTR < Code Limit ?
				sec
				sbc ZPQuickPtr2
				lda ZPQuickPtr1+1
				sbc ZPQuickPtr2+1
				bcc .5					yes, continue relocating
				
				clc
				rts
*--------------------------------------
* 65C02 OPCODES
* Bit 7 : 1 absolute addressing
* Bit 1-0 : opcode + @ length
*--------------------------------------
*					x0.x1.x2.x3.x4.x5.x6.x7.x8.x9.xA.xB.xC.xD.xE.xF
OPCODES			.HS 01.02.02.01.02.02.02.02.01.02.01.01.83.83.83.03
				.HS 02.02.02.01.02.02.02.02.01.83.01.01.83.83.83.03
				.HS 83.02.02.01.02.02.02.02.01.02.01.01.83.83.83.03
				.HS 02.02.02.01.02.02.02.02.01.83.01.01.83.83.83.03
				.HS 01.02.02.01.02.02.02.02.01.02.01.01.83.83.83.03
				.HS 02.02.02.01.02.02.02.02.01.83.01.01.01.83.83.03
				.HS 01.02.02.01.02.02.02.02.01.02.01.01.83.83.83.03
				.HS 02.02.02.01.02.02.02.02.01.83.01.01.83.83.83.03
				.HS 02.02.02.01.02.02.02.02.01.02.01.01.83.83.83.03
				.HS 02.02.02.01.02.02.02.02.01.83.01.01.83.83.83.03
				.HS 02.02.02.01.02.02.02.02.01.02.01.01.83.83.83.03
				.HS 02.02.02.01.02.02.02.02.01.83.01.01.83.83.83.03
				.HS 02.02.02.01.02.02.02.02.01.02.01.01.83.83.83.03
				.HS 02.02.02.01.02.02.02.02.01.83.01.01.01.83.83.03
				.HS 02.02.02.01.02.02.02.02.01.02.01.01.83.83.83.03
				.HS 02.02.02.01.02.02.02.02.01.83.01.01.01.83.83.03
*--------------------------------------
Rel.CodeLen		.BS 2
Rel.Start		.BS 2
Rel.End			.BS 2
Rel.Offset		.BS 2
*--------------------------------------
MAN
SAVE SYS/KERNEL.S.REL
LOAD SYS/KERNEL.S
ASM
