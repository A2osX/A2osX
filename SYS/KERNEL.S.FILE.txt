PR#3
PREFIX /A2OSX.SRC
NEW
INC 1
AUTO 6
				.LIST OFF
*--------------------------------------
* For All SYS.xxxx calls, X = #SYSCall
* Must be kept in X before calling
* PFT.Check
*/--------------------------------------
* #FOpen
* Open a file
* ##In :
*  PUSHW = AUXTYPE
*  PUSHB = TYPE
*  PUSHB = MODE
*   SYS.FOPEN.R : if R and !exists -> ERROR
*   SYS.FOPEN.W : if W and !exists -> CREATE
*   SYS.FOPEN.A : Append
*   SYS.FOPEN.T : Open/Append in Text mode
*   SYS.FOPEN.X : Create if not exists
*  PUSHW = PATH (PSTR)
* ##Out : 
*  CC : A = hFILE
*  CS : A = EC
*\--------------------------------------
K.FOPEN			jsr PFT.CheckPathSTK
				>PULLW MLICALL.PARAMS+1
				>PULLB K.FOPEN.MODE
				>PULLB K.FOPEN.TYPE
				>PULLW K.FOPEN.AUXTYPE
				
				>MLICALL MLIGETFILEINFO
				bcc .10					Already Exists
				
				bit K.FOPEN.MODE		Create if not exists ?
				bpl .9					No, return MLI error
				
				lda #S.FILEINFO.ACCESS.FULL				Yes, Create...
				sta MLICALL.PARAMS+3	Access
				lda K.FOPEN.TYPE
				sta MLICALL.PARAMS+4	File type
				>LDYA K.FOPEN.AUXTYPE
				>STYA MLICALL.PARAMS+5	Aux type
				lda #S.FILEINFO.STORETYPE.STD
				sta MLICALL.PARAMS+7	
				>MLICALL MLICREATE
				bcc .10
.9				rts

.10				>PUSHWI S.FILE.PRODOS
				>PUSHBI S.MEM.F.INIT0
				jsr K.GetMem
				bcs .99
				
				>STYA ZPQuickPtr1
				stx hFILE
				
				
				>PUSHWI 1024			get a ProDOS IOBUF
				>PUSHBI S.MEM.F.ALIGN+S.MEM.F.NOMOVE
				jsr K.GetMem
				bcs .98
				
				>STYA MLICALL.PARAMS+3	Save Ptr to IOBUF for MLIOPEN call
				txa
				ldy #S.FILE.PRODOS.IOBUF
				sta (ZPQuickPtr1),y
				
				>MLICALL MLIOPEN
				bcs .98
				
				lda MLICALL.PARAMS+5	get ref_num
				ldy #S.FILE.PRODOS.REF
				sta (ZPQuickPtr1),y
				
				sta MLICALL.PARAMS+1	Next MLI Calls are REF_NUM based
				
				lda K.FOPEN.MODE
				and #SYS.FOPEN.A		Append ?
				beq .20
				
				>MLICALL MLIGETEOF
				bcs .98
				
				>MLICALL MLISETMARK
				bcs .98
				
.20				lda K.FOPEN.MODE
				and #SYS.FOPEN.T		Text Mode ?
				beq .30
				
				lda #$FF
				sta MLICALL.PARAMS+2
				lda #$0D
				sta MLICALL.PARAMS+3
				>MLICALL MLINEWLINE				
				
.30				lda hFILE
				clc
				rts						CC
				
.98				pha						save MLI error
				jsr K.FCLOSEA.1
				pla						get back MLI error
				sec
.99				rts
*--------------------------------------
K.FOPEN.MODE	.BS 1
K.FOPEN.TYPE	.BS 1
K.FOPEN.AUXTYPE	.BS 2
hFILE			.BS 1
*/--------------------------------------
* #FCloseA
* Close a file
* ##In :
*  A = hFILE
* ##Out :
*\--------------------------------------
K.FCLOSEA		jsr PFT.CheckFileA
				sta hFILE
				jsr K.GetMemPtrA
				>STYA ZPQuickPtr1
				
K.FCLOSEA.1		ldy #S.FILE.PRODOS.REF
				lda (ZPQuickPtr1),y
				beq .1
				sta MLICALL.PARAMS+1
				>MLICALL MLICLOSE
				
.1				ldy #S.FILE.PRODOS.IOBUF				
				lda (ZPQuickPtr1),y
				beq .2
				jsr K.FreeMemA
				
.2				lda hFILE
				jsr K.FreeMemA
				rts
*/--------------------------------------
* #FRead
* Read bytes from file
* ##In :
*  PULLB = hFILE
*  PULLW = Bytes To Read
*  PULLW = Dest Ptr
* ##Out :
*  Y,A = Bytes Read
*\--------------------------------------
K.FREAD			jsr PFT.CheckFileSTK
				ldx #MLIREAD
				bra K.FREAD.1
*/--------------------------------------
* #FWrite
* ##In:
*  PULLB = hFILE
*  PULLW = Bytes To Write
*  PULLW = Src Ptr
* #Out:
*  Y,A = Bytes Written
*\--------------------------------------
K.FWRITE		jsr PFT.CheckFileSTK
				ldx #MLIWRITE
K.FREAD.1		>PULLA
				jsr FILE.SetupPrt1A
				>PULLW MLICALL.PARAMS+4
				>PULLW MLICALL.PARAMS+2

*				>MLICALL MLIWRITE
				
				lda #4					Param Count = 4 for MLIREAD & MLIWRITE
				jsr A2osX.MLICALL
				bcs .9
				>LDYA MLICALL.PARAMS+6
.9				rts
*/--------------------------------------
* #FFLUSHA
* ##In:
*  A = hFILE
*\--------------------------------------
K.FFLUSHA		jsr PFT.CheckFileA
				jsr FILE.SetupPrt1A
				>MLICALL MLIFLUSH
				rts
*/-------------------------------------
* #FSEEK
* ##In:
*  PUSHW = OffsetHi
*  PUSHW = OffsetLo
*  PUSHB = From
*  PUSHB = hFILE
*\-------------------------------------
K.FSEEK			jsr PFT.CheckFileSTK
				>PULLA
				jsr FILE.SetupPrt1A
				>PULLB K.FSEEK.FROM
				>PULLW K.FSEEK.OFFSET
				>PULLW K.FSEEK.OFFSET+2
				
				lda K.FSEEK.FROM
				
*				cmp #SYS.FSEEK.SET		=0
				
				bne .1
				stz MLICALL.PARAMS+2
				stz MLICALL.PARAMS+3
				stz MLICALL.PARAMS+4
				bra .8
				
.1				cmp #SYS.FSEEK.CUR
				bne .2
				>MLICALL MLIGETMARK
				bcc .8
				rts
				
.2				cmp #SYS.FSEEK.END
				bne .98
				>MLICALL MLIGETEOF
				bcs .9
				
.8				lda MLICALL.PARAMS+2
				adc K.FSEEK.OFFSET
				sta MLICALL.PARAMS+2
				lda MLICALL.PARAMS+3
				adc K.FSEEK.OFFSET+1
				sta MLICALL.PARAMS+3
				lda MLICALL.PARAMS+4
				adc K.FSEEK.OFFSET+2
				sta MLICALL.PARAMS+4
				bcs .99					Offset out of range!			
				
				>MLICALL MLISETMARK

.9				rts

.98				lda #SYSMGR.ERRSYN
				.HS 2C					bit abs
.99				lda #SYSMGR.ERRFTB
				sec
				rts
*--------------------------------------
K.FSEEK.FROM	.BS 1
K.FSEEK.OFFSET	.BS 4			
*/--------------------------------------
* #FTELLA
* ##In:
*  A = hFILE
* ##Out:
*   Y,A,X = Offset
*\--------------------------------------
K.FTELLA		jsr PFT.CheckFileA
K.FTELLA.1		jsr FILE.SetupPrt1A
				>MLICALL MLIGETMARK
				bcs .9
				>LDYA MLICALL.PARAMS+2
				ldx MLICALL.PARAMS+4
.9				rts
*/--------------------------------------
* #FEOFA
* ##In:
*  A = hFILE
* ##Out:
*  CC : 
*   A=0 EOF
*   A !=0 NOT EOF
*  CS :
*\--------------------------------------
K.FEOFA			jsr PFT.CheckFileA
				jsr FILE.SetupPrt1A
				jsr K.FTELLA.1
				bcs .9
				>STYA K.FEOFA.MARK
				stx K.FEOFA.MARK+2
				
				>MLICALL MLIGETEOF
				bcs .9
				
				sec
				lda MLICALL.PARAMS+2
				sbc K.FEOFA.MARK
				bne .8
				lda MLICALL.PARAMS+3
				sbc K.FEOFA.MARK+1
				bne .8
				lda MLICALL.PARAMS+4
				sbc K.FEOFA.MARK+2
.8				clc
.9				rts
K.FEOFA.MARK	.BS 3
*/--------------------------------------
* #REMOVEYA
*\--------------------------------------
K.REMOVEYA		jsr PFT.CheckPathYA
				>STYA MLICALL.PARAMS+1
				>MLICALL MLIDESTROY
				rts
*/--------------------------------------
* #RENAME
* Rename a file
* ##In :
*  PUSHW = New Name
*  PUSHW = Old Name
* ##Out :
*\--------------------------------------
K.RENAME		jsr PFT.CheckPathSTK
				>PULLW MLICALL.PARAMS+1
				>PULLW MLICALL.PARAMS+3
				>MLICALL MLIRENAME
				rts
*/--------------------------------------
* #STAT
* Return information about a file
* ##In :
*  PUSHW = PTR to S.STAT buffer
*  PUSHW = PTR to Filename (PSTR)
* ##Out :
*\--------------------------------------
K.STAT			jsr PFT.CheckPathSTK
				>PULLW MLICALL.PARAMS+1
				>PULLW ZPQuickPtr2
				>MLICALL MLIGETFILEINFO
				bcs .9
				jsr FILE.MLI2STAT
				clc
.9				rts
*--------------------------------------
FILE.SetupPrt1A	jsr K.GetMemPtrA
				>STYA ZPQuickPtr1				
				ldy #S.FILE.PRODOS.REF
				lda (ZPQuickPtr1),y
				sta MLICALL.PARAMS+1
				rts
*--------------------------------------
FILE.MLI2STAT
				lda MLICALL.PARAMS+S.FILEINFO.ACCESS
				cmp #S.FILEINFO.ACCESS.FULL
				bne .1
				
				lda #S.STAT.MODE.XO+S.STAT.MODE.WO+S.STAT.MODE.RO
				bra .2
				
.1				and #S.FILEINFO.ACCESS.R
				beq .2
				lda #S.STAT.MODE.XO+S.STAT.MODE.RO	
				
.2				ldy #S.STAT.MODE				
				sta (ZPQuickPtr2),y

				ldx #2
				ldy #S.STAT.PRODOS.TYPE+2
				
.3				lda MLICALL.PARAMS+S.FILEINFO.TYPE,x
				sta (ZPQuickPtr2),y
				dey
				dex
				bpl .3
				rts
*--------------------------------------
MAN
SAVE SYS/KERNEL.S.FILE
LOAD SYS/KERNEL.S
ASM
