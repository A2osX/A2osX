	KEEP	PRODOS
	MCOPY	PRODOS.MAC

* disassembly of prodos version 2.0.3
* can be compiled with the orca/m assembler
*    which produces an output file PRODOS (type = EXE)
* address refs beginning with 'L' were generated by orca disassembler
* address refs beginning with 'H' were added manually

* last edit: 01/24/13

* map of the object modules within prodos exe are as follows:

*  $2000 mli_0    mli loader/relocator
*  $2C80 ram_1    installer for /RAM
*  $2D00 ram_2    /RAM driver in main lc
*  $2D9B mli_3    interrupts
*  $2E00 mli_1    global page
*  $2F00 tclock_0 Thunderclock driver
*  $2F80 cclock_0 Cortland clock driver
*  $3000 mli_2    xdos mli & block file manager
*  $5100 ram_0    /RAM driver in aux mem
*  $5300 xrw_0    disk core routines
*  $5A00 sel_0    dispatcher
*  $5D00 sel_1    enhanced quit code (Bird's Better Bye)
*  $6000 sel_2    GQuit dispatcher support

************************    IMPORTANT    ************************
*                                                               *
* 1. In the language card area, the $D000 areas overlay. To     *
*    determine which bank is active requires that the main bank *
*    has a CLD ($D8) at $D000 and the alternate bank does not.  *
*    $D000 in ROM = $6F, LC bank1 = $D8, LC bank2 = $EE         *
*                                                               *
* 2. Location $E000 is used to determine the state of ROM vs.   *
*    language card. Therefore, the value of $E000 in the MLI    *
*    and ROM must differ.                                       *
*                                                               *
* 3. In the section MEMMGR, the routine CALLDISP must access    *
*    the other $D000 bank so it MUST reside ABOVE $E000 in the  *
*    language card area.                                        *
*                                                               *
* 4. The Disk II routine xrwtot MUST reside on a page boundary  *
*    to distinguish it from a ram-based driver.                 *
*                                                               *
* 5. In the /RAM driver ram3, the byte at $FF58 MUST be an rts  *
*    ($60) so the routine JSR $FF58 to determine an I/O card's  *
*    slot still works when the language card is switched in.    *
*                                                               *
*****************************************************************

PRODOS	START

* Predefined labels:

lookptr	equ	$0A
idapple	equ	$0C		model machine id
idxl	equ	$10		general use 16 bit index pointer
devid	equ	$12
src	equ	$12
dst	equ	$14
cnt	equ	$16
cde	equ	$18
ecde	equ	$1A
wndlft	equ	$20
wndwdth	equ	$21
wndtop	equ	$22
wndbtm	equ	$23
ch	equ	$24		cursor horizontal
cv	equ	$25		cursor vertical
invflg	equ	$32		inverse flag
pcl	equ	$3A
pch	equ	$3B
A1L	equ	$3C
A1H	equ	$3D
A2L	equ	$3E
A2H	equ	$3F
A3L	equ	$40
A4L	equ	$42
unitnum	equ	$43
buf	equ	$44		2-byte data buffer pointer which
accsav	equ	$45		overlaps accsav (temp acc save byte)
bloknml	equ	$46		used mostly as 16 bit block # pointer
zpt	equ	$48		highly used zero page index pointer
datptr	equ	$4A		ptr to data area of buffer.
sos	equ	$4C		sos buffer pointer.
usrbuf	equ	$4E		data ptr in user buffer.

* zero page variables for Bird's Better Bye

smparms	equ	$60		set mark parms
sm_refn	equ	$61		file reference number
fpos_lo	equ	$62		new file position (3 bytes)
fpos_mid equ	$63
fpos_hi	equ	$64
lstpntr	equ	$65		device list pointer (16 bit)
valcnt	equ	$67		name counter
filecount equ	$68		# of displayable files in directory
namelen	equ	$69		length of filename
gp_cnt	equ	$6A		general purpose counter
dlevel	equ	$6B		directory level
fnstore	equ	$6C		filename storage pointer (16 bit)
entlen	equ	$6E		directory entry length
entblk	equ	$6F		directory entries/block
filecnt	equ	$70		directory file count (16 bit)
blkfl	equ	$72		block flag / file counter
topname	equ	$73		index # of top name in display
filetyps equ	$74		128 byte table of filetypes

errnum	equ	$DE
tst128	equ	$0080		temp page 0 routine for memory test
auxsp	equ	$0101
ramdest	equ	$0200		load address for aux bank /RAM driver
inbuf	equ	$0200		keyboard buffer
pbuf	equ	$0280		prefix buffer
p3vect	equ	$03F0		page 3 vectors (16 bytes)
softev	equ	$03F2		RESET vector
pwredup	equ	$03F4		power up byte
nmivect	equ	$03FB		nmi handler
txtp2	equ	$0400		test location for aux card
vline10	equ	$04A8		line 10 of display
vmode	equ	$04FB		video firmware operating mode
vline11	equ	$0528		line 11 of display
clkmode	equ	$0538		clock mode
ch80col	equ	$057B		80 column ch position
vline12	equ	$05A8		line 12 of display
vline5	equ	$0600		line 5 of display
vline13	equ	$0628		line 13 of display
vline14	equ	$06A8		line 14 of display
vline23	equ	$0750		line 23 of display
vline16	equ	$07A8		line 16 of display
vline24	equ	$07D0		line 24 of display
mslot	equ	$07F8		slot being accessed
lodintrp equ	$0800
dbuf	equ	$0C00		8 page directory buffer
vblock1	equ	$0E00		ramdisk directory block
volbuf	equ	$0F00		volume buffer
dispadr	equ	$1000		system death dispatcher run address
iobuf	equ	$1400		i/o buffer
fbuf	equ	$1800		FCB buffer
op_buf	equ	$1C00		open file buffer (selector)
sysentry equ	$2000		.SYS file load address
prodos8	equ	$BF00		prodos MLI and global page
kbd	equ	$C000		keyboard latch (read)
store80off equ	$C000		disable 80-col store (write)
store80on equ	$C001		enable 80-col store
rdmainram equ	$C002		read from main 48K
rdcardram equ	$C003		read from alt 48K
wrmainram equ	$C004		write to main 48K
wrcardram equ	$C005		write to alt 48K
setstdzp equ	$C008		use main zero page/stack
setaltzp equ	$C009		use alt zero page/stack
int3rom	equ	$C00A		enable internal slot 3 ROM
slot3rom equ	$C00B		enable external slot 3 ROM
clr80vid equ	$C00C		disable 80 col hardware
clraltchar equ	$C00E		normal LC, flashing UC
kbdstrobe equ	$C010		turn off keypressed flag
rd80col  equ	$C018		if 80-column store
newvideo equ	$C029		video mode select
spkr     equ	$C030		click speaker
txtset   equ	$C051		switch in text
txtpage1 equ	$C054		switch in text page 1
txtpage2 equ	$C055		switch in text page 2
statereg equ	$C068		memory state register
phaseoff equ	$C080		disk port
romin1	equ	$C081		read ROM/write RAM bank 2
romin	equ	$C082		read ROM
altram	equ	$C083		read/write RAM bank 2
motoroff equ	$C088		disk port
motoron	equ	$C089		disk port
drv0en	equ	$C08A		disk port
ramin	equ	$C08B		read/write RAM bank 1
q6l	equ	$C08C		disk port
q6h	equ	$C08D		disk port
q7l	equ	$C08E		disk port
q7h	equ	$C08F		disk port
rdtcp	equ	$C108		Thunderclock read entry
wttcp	equ	$C10B		Thunderclock write entry
init80	equ	$C300		init 80 col card
slot3id1 equ	$C305		slot 3 card id 1
slot3id2 equ	$C307		slot 3 card id 2
slot3id3 equ	$C30B		slot 3 card id 3
ext80col equ	$C30C		slot 3 80 col id
auxmove	equ	$C311		move (3C)-(3E) to (42)
xfer	equ	$C314
slot3irq equ	$C3FA		slot 3 irq handler
clrrom   equ	$CFFF		switch out $C8 ROMs
rwts	equ	$D000		disk ii driver in bank 1
displc2	equ	$D100		system death routine stored in bank 2
pathbuf	equ	$D700		pathname buffer
tclk_in	equ	$D742		clock driver in bank 2
fcbbuf	equ	$D800		fcb buffer
vcbbuf	equ	$D900		vcb buffer
bmbuf	equ	$DA00		512 byte bitmap buffer
gbuf	equ	$DC00		general purpose 512 byte block buffer
xdosorg	equ	$DE00		xdos MLI in aux memory
romirq	equ	$FA41		monitor irq entry
breakv	equ	$FA59		monitor break vector
resetv	equ	$FA62		monitor reset entry
HFB1E	equ	$FB1E		version check byte
init     equ	$FB2F		init text screen
settxt   equ	$FB39		set text mode
tabv     equ	$FB5B		set vertical position
setpwrc  equ	$FB6F		create power-up byte
version  equ	$FBB3		monitor ROM id byte
zidbyte  equ	$FBC0		monitor ROM id byte
bell1    equ	$FBDD		generate bell tone
home     equ	$FC58		home cursor and clear screen
clreol   equ	$FC9C		clear to end of line
rdkey    equ	$FD0C		input char with cursor
crout    equ	$FD8E		issue carriage return
cout     equ	$FDED		output character
idroutine equ	$FE1F		returns system info
setinv   equ	$FE80		set inverse text mode
setnorm  equ	$FE84		set normal text mode
setkbd   equ	$FE89		reset input to keyboard
setvid   equ	$FE93		reset output to screen
lcdest	equ	$FF00		load address
bell     equ	$FF3A		output bell (ctl-G)
oldrst   equ	$FF59		monitor reset entry
* romrts equ	$FFCB		an rts location that must be in ROM
P8QUIT	equ	$E0D000
GSOS     equ	$E100A8
GSOS2    equ	$E100B0
OS_BOOT  equ	$E100BD		indicates O/S initially booted
